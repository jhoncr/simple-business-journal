# code repositoy: simple-business-journal

# files in the repositoy: 
# README.md
# backend/README.md
# backend/firestore.rules
# backend/functions/src/bg-accept-share.ts
# backend/functions/src/bg-add-contributors.ts
# backend/functions/src/bg-add-group.ts
# backend/functions/src/bg-add-log-entry.ts
# backend/functions/src/bg-create-new-journal.ts
# backend/functions/src/bg-delete-entry.ts
# backend/functions/src/cache-updates/bg-cache.ts
# backend/functions/src/common/common_types.ts
# backend/functions/src/common/const.ts
# backend/functions/src/common/schemas/CashflowSchema.ts
# backend/functions/src/common/schemas/InventorySchema.ts
# backend/functions/src/common/schemas/JournalSchema.ts
# backend/functions/src/common/schemas/common_schemas.ts
# backend/functions/src/common/schemas/configmap.ts
# backend/functions/src/common/schemas/quote_schema.ts
# backend/functions/src/index.ts
# backend/functions/src/lib/bg-consts.ts
# backend/storage.rules
# frontend/README.md
# frontend/components/QuoteEntryForm.tsx
# frontend/src/app/(auth)/@login/default.tsx
# frontend/src/app/(auth)/@login/loading.tsx
# frontend/src/app/(auth)/journal/actions/date-pick-with-range.tsx
# frontend/src/app/(auth)/journal/actions/delete-entry.tsx
# frontend/src/app/(auth)/journal/actions/export-to-csv.tsx
# frontend/src/app/(auth)/journal/comp/Entry.tsx
# frontend/src/app/(auth)/journal/comp/EntryView.tsx
# frontend/src/app/(auth)/journal/comp/chat.tsx
# frontend/src/app/(auth)/journal/comp/useFetch.tsx
# frontend/src/app/(auth)/journal/entry/page.tsx
# frontend/src/app/(auth)/journal/journal-types/cash-flow/CashFlowEntry.tsx
# frontend/src/app/(auth)/journal/journal-types/cash-flow/add-cf-entry.tsx
# frontend/src/app/(auth)/journal/journal-types/config.tsx
# frontend/src/app/(auth)/journal/journal-types/create-new-journal.tsx
# frontend/src/app/(auth)/journal/journal-types/inventory/InventoryItemEntry.tsx
# frontend/src/app/(auth)/journal/journal-types/inventory/add-inventory-entry.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/QuoteEntry.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/addQuote.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/AdjustmentForm.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/Adjustments.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/ContactInfo.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/EditNotes.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/NewItemForm.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/TEST_MATERIALS.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/TaxForm.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/header.tsx
# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/quoteStatus.tsx
# frontend/src/app/(auth)/journal/layout.tsx
# frontend/src/app/(auth)/journal/page.tsx
# frontend/src/app/(auth)/layout.tsx
# frontend/src/app/(auth)/nav_tool_handler.tsx
# frontend/src/app/(auth)/page.tsx
# frontend/src/app/about/page.tsx
# frontend/src/app/layout.tsx
# frontend/src/app/share/page.tsx
# frontend/src/app/wip/page.tsx
# frontend/src/components/InputUnit.tsx
# frontend/src/components/LogoUpload.tsx
# frontend/src/components/RadioG.tsx
# frontend/src/components/theme-provider.tsx
# frontend/src/components/ui/accordion.tsx
# frontend/src/components/ui/add-contributors.tsx
# frontend/src/components/ui/alert-dialog.tsx
# frontend/src/components/ui/avatar.tsx
# frontend/src/components/ui/badge.tsx
# frontend/src/components/ui/breadcrumb.tsx
# frontend/src/components/ui/button.tsx
# frontend/src/components/ui/calendar.tsx
# frontend/src/components/ui/card.tsx
# frontend/src/components/ui/checkbox.tsx
# frontend/src/components/ui/data-table.tsx
# frontend/src/components/ui/dialog.tsx
# frontend/src/components/ui/drawer.tsx
# frontend/src/components/ui/dropdown-menu.tsx
# frontend/src/components/ui/form.tsx
# frontend/src/components/ui/input.tsx
# frontend/src/components/ui/journal-info-card.tsx
# frontend/src/components/ui/label.tsx
# frontend/src/components/ui/popover.tsx
# frontend/src/components/ui/radio-group.tsx
# frontend/src/components/ui/scroll-area.tsx
# frontend/src/components/ui/select.tsx
# frontend/src/components/ui/separator.tsx
# frontend/src/components/ui/sharable-link.tsx
# frontend/src/components/ui/skeleton.tsx
# frontend/src/components/ui/switch.tsx
# frontend/src/components/ui/table.tsx
# frontend/src/components/ui/tabs.tsx
# frontend/src/components/ui/textarea.tsx
# frontend/src/components/ui/toast.tsx
# frontend/src/components/ui/toaster.tsx
# frontend/src/components/ui/tooltip.tsx
# frontend/src/components/ui/user-nav.tsx
# frontend/src/context/JournalContext.tsx
# frontend/src/hooks/use-media-query.ts
# frontend/src/hooks/use-toast.ts
# frontend/src/lib/auth_handler.tsx
# frontend/src/lib/custom_types.tsx
# frontend/src/lib/db_handler.tsx
# frontend/src/lib/schemas/contact-info.ts
# frontend/src/lib/utils.ts
# frontend/tailwind.config.ts


# README.md
# Simple Journal App

This is a simple journal app that allows users to create and manage different types of journals and collaborate with others.

## Screenshots

**Desktop:**
![Quote Desktop Screen](quote_desktop_screen.png)

**Phone:**
<img src="quote_phone_screen.png" alt="Quote Phone Screen" width="250">

## Example Output

You can view an example PDF output here: [Example Quote PDF](example.pdf)

## Supported Journal Types

Currently, the application supports the following journal types:

*   **Cashflow:** For tracking income and expenses, with entries including details like description, date, type (received/paid), value, and currency.
*   **Quote:** For creating and managing quotes with detailed line items (based on materials and labor), adjustments (like tax, discounts), customer and supplier contact information, and status tracking.

The project structure and schema definitions (e.g., `InventorySchema.ts`) also indicate the underlying data structures to support managing reusable material and labor items, integral to the Quote journal type and potentially evolving into a standalone inventory management feature.

## Features

*   **Journal Creation and Management:** Create and manage different types of journals.
*   **Entry Management:** Add, edit, and remove entries specific to each journal type (e.g., cash flow transactions, quote line items).
*   **Collaboration:** Share journals with other users and define their access levels.
*   **Role-Based Access Control:** Assign roles (Admin, Editor, Staff, Viewer) to collaborators to control their permissions within a journal.
*   **Search Functionality:** Search for journals and entries using filters like date ranges and keywords. Date range filtering is supported.
*   **Reporting:** Generate reports based on journal data (specific reports may vary by journal type, e.g., cash flow summaries, quote totals).
*   **Data Export:** Export journal data, currently supporting export to CSV format (e.g., quote details or cash flow entries).

### Roles

*   **Admin:** Has full administrative control over the journal, including managing entries, collaborators, and settings.
*   **Editor:** Can add, edit, and delete journal entries.
*   **Staff:** Can add new journal entries.
*   **Viewer:** Can only view journal entries and reports.

## Data Model and Firestore Structure

The application utilizes Firestore to store journal data. The data model is structured around journals, entries within journals, and supporting collections for entities like inventory items and customers.

The primary collections and document structures, based on the project's schema definitions, are:

*   `/journals`: This collection holds the main documents for each journal.
    *   **Journal Document (`/journals/{journalId}`):**
        *   `title` (string): The name of the journal.
        *   `journalType` (string): Indicates the type of journal (e.g., `"cash-flow"`, `"quote"`).
        *   `createdAt` (timestamp): The time the journal was created.
        *   `updatedAt` (timestamp): The time of the last update to the journal document.
        *   `access` (map): Defines the access levels for collaborators. Keys are user IDs, and values are objects containing user details and their assigned `role` (`"admin"`, `"editor"`, `"staff"`, `"viewer"`).
        *   `pendingAccess` (map): Stores pending invitations to collaborate, mapping email addresses to intended roles.
        *   `details` (object): Contains type-specific data for the journal.
            *   If `journalType` is `"quote"`, the `details` object conforms to the `quoteDetailsStateSchema`, including fields like `confirmedItems` (an array of line items), `status` (`"pending"`, `"accepted"`, `"rejected"`), `customer` (`contactInfoSchema`), `supplier` (`contactInfoSchema`), `logo`, `adjustments` (array of `adjustmentSchema`), `taxPercentage`, `currency` (`currencyCodeSchema`), and `notes`.

*   `/journals/{journalId}/entries`: This subcollection contains the individual entries for a specific journal.
    *   **Cashflow Entry Document (`/journals/{journalId}/entries/{entryId}`):** Represents a single cash flow transaction, conforming to `cashFlowEntryDetailsSchema`. It includes fields like `createdAt`, `createdBy`, `date`, `description`, `type` (`"received"` or `"paid"`), `value`, and `currency`.
    *   **Quote Line Item Document (`/journals/{journalId}/entries/{entryId}`):** Represents a single item or service on a quote, conforming to `lineItemSchema` (which includes `materialItemSchema`). It includes fields like `id`, `parentId`, `quantity`, optional `dimensions`, `description`, `createdAt`, and nested `material` details (like `unitPrice`, `dimensions`, `currency`).

*   `/inventory` (Inferred): A likely collection for managing reusable `materialItemSchema` and `laborItemSchema` documents, referenced by Quote line items.

*   `/customers` (Inferred): A likely collection for storing customer contact information, referenced by Quote journals using the `contactInfoSchema`.

*(Note: This structure is based on the project's schema definitions and file organization. The actual implementation might have minor variations in collection naming or data relationships.)*

## Development Status

The project is currently under active development.



# backend/README.md
# Backend

This directory contains the backend services for the application, primarily implemented using Firebase Cloud Functions.

## Structure

-   **functions/**: Contains the source code for the Cloud Functions.
    -   **src/**: TypeScript source files for the functions.
        -   **common/**: Shared types, constants, and schemas.
        -   **cache-updates/**: Functions related to cache management.
        -   **lib/**: Utility or helper functions.
    -   **tests/**: Test files for the functions.
    -   **package.json**: Node.js dependencies for the functions.
    -   **tsconfig.json**: TypeScript configuration.
-   **firebase.json**: Firebase project configuration, including Hosting and Functions settings.
-   **firestore.indexes.json**: Firestore index definitions.
-   **firestore.rules**: Firestore security rules.
-   **storage.rules**: Cloud Storage security rules.
-   **package.json**: (Potentially for backend-level scripts or configuration, though functions have their own).

## Key Components

-   **Cloud Functions**: Handle core business logic, data manipulation, and background tasks. (See `functions/src/` for details).
-   **Firestore**: NoSQL database used for data storage. Rules and indexes are defined here.
-   **Cloud Storage**: Used for file storage (e.g., logos). Rules are defined here.

## Implemented Cloud Functions (`functions/src`)

Based on the filenames, the following core functionalities are implemented as Cloud Functions:

-   `bg-accept-share.ts`: Handles the logic for accepting a shared journal or resource.
-   `bg-add-contributors.ts`: Manages adding new contributors or collaborators to journals.
-   `bg-add-group.ts`: Logic for adding a new group (context might be user groups or journal categorization).
-   `bg-add-log-entry.ts`: Responsible for adding new entries (like cash flow, inventory, quotes) to a specific journal.
-   `bg-create-new-journal.ts`: Handles the creation process for new journals of different types.
-   `bg-delete-entry.ts`: Manages the deletion of entries from a journal.
-   `index.ts`: Entry point that likely exports and organizes the callable functions.
-   `cache-updates/bg-cache.ts`: Contains logic related to updating cached data, possibly for performance optimization.

## Development

Refer to the main project README for overall development setup. To work specifically on the backend functions:

1.  Navigate to the `backend/functions` directory.
2.  Install dependencies: `npm install`
3.  Run the emulator suite (from the root or backend directory, depending on setup): `firebase emulators:start`
4.  Deploy functions: `firebase deploy --only functions`



# backend/firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Combined function: Checks both access and activity
    function hasAccessAndIsActive(journalId) {
      let logData = get(/databases/$(database)/documents/journals/$(journalId)).data;
      return request.auth.uid in logData.access_array && (logData.isActive == true || logData.isActive == null);
    }
    
     // Function to check if a document is active (handles null case) at the document level
    function isDocumentActive(docData) {
       return docData.isActive == true || docData.isActive == null;
    }

    match /journals/{journalId} {
      allow read: if request.auth.uid in resource.data.access_array && 
                    (resource.data.isActive == true || resource.data.isActive == null);

      match /{subcol}/{entryID} {
        // Check if the user has access to the parent log, the parent log is active, AND entry is active.
        allow read: if hasAccessAndIsActive(journalId) && isDocumentActive(resource.data);
      }
    }
  }
}


# backend/functions/src/bg-accept-share.ts
// backend/functions/src/bg-accept-share.ts

import { onCall, HttpsError } from "firebase-functions/v2/https";
import * as logger from "firebase-functions/logger";
import * as z from "zod";
import { getFirestore, FieldValue } from "firebase-admin/firestore";
import { initializeApp, getApps } from "firebase-admin/app";
// --- Update import ---
import { JOURNAL_COLLECTION } from "./common/const";
import { ALLOWED } from "./lib/bg-consts";
import { JournalSchemaType } from "./common/schemas/JournalSchema"; // Keep for typing

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

// --- Schema remains the same ---
const schema = z
  .object({
    journalID: z.string(),
    operation: z.enum(["accept", "ignore", "check"]),
  })
  .strict();

export const acceptShare = onCall(
  {
    cors: ALLOWED,
    enforceAppCheck: true, // Keep App Check enforcement
  },
  async (request) => {
    try {
      logger.info("acceptShare called");
      if (!request.auth || !request.auth.uid || !request.auth.token?.email) {
        throw new HttpsError(
          "unauthenticated",
          "You must be signed in to manage sharing.",
        );
      }

      const result = schema.safeParse(request.data);
      if (!result.success) {
        throw new HttpsError(
          "invalid-argument",
          result.error.issues.map((issue) => issue.message).join("\n"),
        );
      }

      const { journalID: journalId, operation } = result.data; // Use journalId for consistency with original code
      const uid = request.auth.uid;
      const email = request.auth.token?.email;

      if (operation === "ignore") {
        // Optionally: You could add logic here to record the ignore action if needed
        logger.info(
          `User ${uid} (${email}) ignored share for journal ${journalId}`,
        );
        return { result: "ok", message: "Ignored grant to access log" };
      }

      // Transaction to modify the journal document
      await db.runTransaction(async (transaction) => {
        const logDocRef = db.collection(JOURNAL_COLLECTION).doc(journalId);
        const logDoc = await transaction.get(logDocRef);

        if (!logDoc.exists) {
          throw new HttpsError(
            "not-found",
            "The journal document does not exist or you do not have access.", // Simplified message
          );
        }

        // Type assertion for convenience, ensure JournalSchemaType is imported
        const logData = logDoc.data() as JournalSchemaType;

        // Check if user already has access
        if (logData.access && logData.access[uid]) {
          logger.info(`User ${uid} already has access to journal ${journalId}`);
          // No error needed, just inform the user
          return; // Exit transaction successfully
        }

        // Check operation: Verify invitation exists
        if (operation === "check") {
          if (email && logData.pendingAccess && logData.pendingAccess[email]) {
            logger.info(
              `Access check successful for ${email} on journal ${journalId}`,
            );
            return; // Exit transaction successfully
          } else {
            logger.warn(
              `Access check failed for ${email} on journal ${journalId}. No pending access found.`,
            );
            throw new HttpsError(
              "not-found", // Or 'permission-denied'
              "You have not been invited to access this journal or the invitation was revoked.",
            );
          }
        }

        // Accept operation
        if (operation !== "accept") {
          // Should not happen if schema validation is correct, but good safety check
          throw new HttpsError(
            "invalid-argument",
            `Invalid operation: ${operation}`,
          );
        }

        // --- Core Logic: Move from pendingAccess to access ---
        if (
          email &&
          logData.pendingAccess && // Ensure pendingAccess exists
          Object.prototype.hasOwnProperty.call(logData.pendingAccess, email) // Safer check
        ) {
          logger.info(`Accepting share for ${email} on journal ${journalId}.`);
          const role = logData.pendingAccess[email]; // Get the role from pending

          // Prepare updates
          const updates: Record<string, any> = {
            // Add to access map
            [`access.${uid}`]: {
              role: role,
              email: email,
              displayName: request?.auth?.token?.name || "",
              photoURL: request?.auth?.token?.picture || "",
            },
            // Remove from pendingAccess map, only if email is not null
            [`pendingAccess.${email}`]: FieldValue.delete(),
            // Add UID to access_array
            access_array: FieldValue.arrayUnion(uid),
            updatedAt: FieldValue.serverTimestamp(), // Update timestamp
          };

          // --- REMOVED Parent Update Logic ---
          // No parent document to update in the new model.

          transaction.update(logDocRef, updates);
          logger.info(
            `User ${uid} (${email}) successfully added to journal ${journalId} with role ${role}.`,
          );
        } else {
          logger.warn(
            `Accept operation failed for ${email} on journal ${journalId}. No pending access found.`,
          );
          throw new HttpsError(
            "permission-denied",
            "You have not been invited to access this journal or the invitation may have been withdrawn.",
          );
        }
      }); // End transaction

      // If transaction completes without throwing, it was successful.
      if (operation === "check") {
        return { result: "ok", message: "You have a pending invitation." };
      }
      return { result: "ok", message: "Accepted grant to access journal" };
    } catch (error) {
      logger.error("Error accepting share for journal:", error);
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "Error accepting share. Please try again later.",
      );
    }
  },
);



# backend/functions/src/bg-add-contributors.ts
/**
 * Import function triggers from their respective submodules:
 *
 * import {onCall} from "firebase-functions/v2/https";
 * import {onDocumentWritten} from "firebase-functions/v2/firestore";
 *
 * See a full list of supported triggers at https://firebase.google.com/docs/functions
 */

import { onCall, HttpsError } from "firebase-functions/v2/https";
import * as logger from "firebase-functions/logger";
import * as z from "zod";
import { getFirestore, FieldValue } from "firebase-admin/firestore";
import { initializeApp, getApps } from "firebase-admin/app";
import { JOURNAL_COLLECTION } from "./common/const";
import { JournalSchemaType } from "./common/schemas/JournalSchema";
import { ALLOWED } from "./lib/bg-consts";

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

const ROLES = ["viewer", "reporter", "editor", "admin"] as const;
const SHARE_ROLES = new Set(["admin"]);

const updateShareRequest = z
  .object({
    email: z.string().email(),
    role: z.enum(ROLES),
    operation: z.enum(["add", "remove"]),
    journalId: z.string(),
  })
  .strict();

interface Contributor {
  role: string;
  email: string;
  displayName: string;
  photoURL: string;
  uid?: string;
}

// allow cors for all origins
export const addContributor = onCall(
  {
    cors: ALLOWED,
    enforceAppCheck: true,
  },
  async (request) => {
    try {
      logger.info("addContributor called");
      // return error if not authenticated
      if (!request.auth) {
        throw new HttpsError(
          "unauthenticated",
          "You must be signed in to add a message",
        );
      }

      // check if the request.data is valid
      const result = updateShareRequest.safeParse(request.data);
      if (!result.success) {
        throw new HttpsError(
          "invalid-argument",
          result.error.issues.map((issue) => issue.message).join("\n"),
        );
      }

      // get the journalId from the request
      const journalId = result.data.journalId;
      const uid = request.auth.uid;

      // transaction to add the people to logDoc.access map
      await db.runTransaction(async (transaction) => {
        // get the log document
        const logDocRef = db.collection(JOURNAL_COLLECTION).doc(journalId);
        const logDoc = await transaction.get(logDocRef);

        // check if the log document exists
        if (!logDoc.exists) {
          throw new HttpsError(
            "not-found",
            "The log document does not exist or you do not have access to it.",
          );
        }

        // check if the user is allowed to share a log entry
        const logData = logDoc.data();

        const hasAccess: { [uid: string]: Contributor } = logData?.access ?? {};
        if (!(uid in hasAccess) || !SHARE_ROLES.has(hasAccess[uid].role)) {
          throw new HttpsError(
            "permission-denied",
            "You do not have permission to add or remove contributors to this log entry.",
          );
        }

        logger.info("User is allowed to share this journal");
        logger.debug("logData", logData);
        logger.debug("result.data.", result.data);

        if (result.data.operation === "add") {
          handleAddOperation(
            transaction,
            logDocRef,
            result.data,
            logData as JournalSchemaType,
          );
        } else if (result.data.operation === "remove") {
          handleRemoveOperation(
            transaction,
            logDocRef,
            result.data,
            logData as JournalSchemaType,
          );
        }
      });
      // return success
    } catch (error) {
      logger.log("Error adding contributors", error);
      // check if errors is a https error
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "Error adding contributors. Please try again later.",
      );
    }

    // return ok
    return { result: "ok", message: "operation completed successfully" };
  },
);

const handleAddOperation = async (
  transaction: FirebaseFirestore.Transaction,
  logDocRef: FirebaseFirestore.DocumentReference<FirebaseFirestore.DocumentData>,
  data: z.infer<typeof updateShareRequest>,
  logData: JournalSchemaType,
) => {
  // check if the email is already in the access map, if so, only update the role
  const access = logData?.access ?? {};

  const cur = Object.entries(access).find(([key, value]) => {
    return value.email === data.email;
  });
  if (cur) {
    const [key, _] = cur;
    // update the role
    // TODO: block update of admin role
    transaction.update(logDocRef, {
      [`access.${key}.role`]: data.role,
    });

    return;
  }
  // if the email is not in the access map, add it to pendingAccess map
  const pendingAccess = logData?.pendingAccess ?? {};
  transaction.update(logDocRef, {
    pendingAccess: {
      ...pendingAccess,
      [data.email]: data.role,
    },
  });
  return;
};

const handleRemoveOperation = async (
  transaction: FirebaseFirestore.Transaction,
  logDocRef: FirebaseFirestore.DocumentReference<FirebaseFirestore.DocumentData>,
  data: z.infer<typeof updateShareRequest>,
  logData: JournalSchemaType,
) => {
  // check if the email is in the access map, if so, remove it from the access map
  const access = logData?.access ?? {};
  const cur = Object.entries(access).find(([key, value]) => {
    return value.email === data.email;
  });
  if (cur) {
    const [key, _] = cur;
    // remove the email from the access map
    transaction.update(logDocRef, {
      [`access.${key}`]: FieldValue.delete(),
    });

    // remove email from access_array, use FieldValue.arrayRemove
    transaction.update(logDocRef, {
      access_array: FieldValue.arrayRemove(data.email),
    });
    return;
  }
  // if the email is not in the access map, remove it from pendingAccess map
  const pendingAccess = logData?.pendingAccess ?? {};
  const cur2 = Object.entries(pendingAccess).find(([key, value]) => {
    return value === data.email;
  });
  // if the email is in the pendingAccess map, remove it from the pendingAccess map
  if (cur2) {
    const [key, _] = cur2;
    // remove the email from the pendingAccess map
    transaction.update(logDocRef, {
      [`pendingAccess.${key}`]: FieldValue.delete(),
    });
  }
  return;
};



# backend/functions/src/bg-add-group.ts
import { onCall, HttpsError } from "firebase-functions/v2/https";
import * as logger from "firebase-functions/logger";
import { getFirestore, FieldValue } from "firebase-admin/firestore";
import { initializeApp, getApps } from "firebase-admin/app";
import { JOURNAL_COLLECTION, JOURNAL_TYPES } from "./common/const";
import {
  JournalCreateBaseSchema,
  businessDetailsSchema,
  babyDetailsSchema,
} from "./common/schemas/JournalSchema";
import { ALLOWED } from "./lib/bg-consts";
import * as z from "zod";

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

const CreateJournalPayloadSchema = JournalCreateBaseSchema.extend({
  details: z.union([businessDetailsSchema, babyDetailsSchema]),
}).refine(
  (data) => {
    return (
      (data.journalType === JOURNAL_TYPES.BUSINESS &&
        businessDetailsSchema.safeParse(data.details).success) ||
      (data.journalType === JOURNAL_TYPES.BABY &&
        babyDetailsSchema.safeParse(data.details).success)
      // Add checks for other types as needed
    );
  },
  {
    message: "Details must match the specified journal type.",
    path: ["details"],
  },
);

// type CreateJournalPayloadType = z.infer<typeof CreateJournalPayloadSchema>;

export const createJournal = onCall(
  {
    cors: ALLOWED,
    enforceAppCheck: true,
  },
  async (request) => {
    logger.info("createJournal called");

    if (!request.auth) {
      throw new HttpsError(
        "unauthenticated",
        "You must be signed in to perform this operation.",
      );
    }

    const result = CreateJournalPayloadSchema.safeParse(request.data);
    if (!result.success) {
      logger.error("Invalid request data", result.error.format());
      throw new HttpsError("invalid-argument", result.error.message);
    }

    const uid = request.auth.uid;
    const access = {
      [uid]: {
        role: "admin",
        email: request.auth.token.email || null,
        displayName: request.auth.token.name || null,
        photoURL: request.auth.token.picture || null,
      },
    };

    const { title, journalType, details } = result.data;

    try {
      const journalDocRef = db.collection(JOURNAL_COLLECTION).doc();

      await journalDocRef.set({
        title,
        journalType,
        details,
        access,
        access_array: [uid],
        isActive: true,
        createdAt: FieldValue.serverTimestamp(),
        updatedAt: FieldValue.serverTimestamp(),
      });

      logger.info(
        `Journal of type ${journalType} created successfully with ID: ${journalDocRef.id}`,
      );
      return { journalId: journalDocRef.id };
    } catch (error: any) {
      logger.error("Journal creation failed", error);
      throw new HttpsError(
        "internal",
        `Journal creation failed: ${error.message || error}`,
      );
    }
  },
);

const UpdateJournalPayloadSchema = JournalCreateBaseSchema.partial()
  .extend({
    id: z.string().min(1),
    details: z
      .union([businessDetailsSchema.partial(), babyDetailsSchema.partial()])
      .optional(),
  })
  .refine(
    (data) => {
      const details = data.details;
      if (details) {
        if (
          data.journalType === JOURNAL_TYPES.BUSINESS &&
          !businessDetailsSchema.partial().safeParse(details).success
        ) {
return false;
}
        if (
          data.journalType === JOURNAL_TYPES.BABY &&
          !babyDetailsSchema.partial().safeParse(details).success
        ) {
return false;
}
      }
      return true;
    },
    {
      message: "Details must match the specified journal type.",
      path: ["details"],
    },
  );

// type UpdateJournalPayloadType = z.infer<typeof UpdateJournalPayloadSchema>;

export const updateJournal = onCall(
  {
    cors: ALLOWED,
    enforceAppCheck: true,
  },
  async (request) => {
    logger.info("updateJournal called");

    if (!request.auth) {
      throw new HttpsError(
        "unauthenticated",
        "You must be signed in to perform this operation.",
      );
    }

    const result = UpdateJournalPayloadSchema.safeParse(request.data);
    if (!result.success) {
      logger.error("Invalid request data for update", result.error.format());
      throw new HttpsError(
        "invalid-argument",
        "Invalid journal data for update.",
      );
    }

    const uid = request.auth.uid;
    const { id: journalId, title, details } = result.data;

    try {
      const docRef = db.collection(JOURNAL_COLLECTION).doc(journalId);
      const doc = await docRef.get();

      if (!doc.exists) {
        throw new HttpsError("not-found", "Journal not found");
      }

      const currentData = doc.data();
      if (!currentData) {
        throw new HttpsError("internal", "Journal data is missing.");
      }

      if (currentData.access?.[uid]?.role !== "admin") {
        throw new HttpsError("permission-denied", "Insufficient permissions");
      }

      const updateData: Record<string, any> = {};
      if (title !== undefined) updateData.title = title;
      if (details !== undefined) updateData.details = details;

      if (Object.keys(updateData).length > 0) {
        updateData.updatedAt = FieldValue.serverTimestamp();
        await docRef.update(updateData);
        logger.info(`Journal ${journalId} updated successfully.`);
      } else {
        logger.info(`No changes detected for journal ${journalId}.`);
      }

      return { success: true };
    } catch (error: any) {
      logger.error("Update failed", error);
      if (error instanceof HttpsError) throw error;
      throw new HttpsError(
        "internal",
        `Update failed: ${error.message || error}`,
      );
    }
  },
);



# backend/functions/src/bg-add-log-entry.ts
// backend/functions/src/bg-add-log-entry.ts
import { onCall, HttpsError } from "firebase-functions/v2/https";
import * as logger from "firebase-functions/logger";
import { getFirestore, FieldValue } from "firebase-admin/firestore";
import { initializeApp, getApps } from "firebase-admin/app";
import {
  JOURNAL_COLLECTION,
  ROLES_THAT_ADD, // --- Import ENTRY_CONFIG ---
} from "./common/const";
import { ENTRY_CONFIG,
  entrySchema, // --- Use updated entrySchema ---
  EntryType,
} from "./common/schemas/configmap";
import { ALLOWED, handleSchemaValidationError } from "./lib/bg-consts";
import { EntryItf } from "./common/common_types";

// import * as z from "zod"; // Import z

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

export const addLogFn = onCall(
  {
    cors: ALLOWED,
    enforceAppCheck: true,
  },
  async (request) => {
    try {
      logger.info("addLogFn called");
      if (!request.auth) {
        throw new HttpsError(
          "unauthenticated",
          "You must be signed in to add an entry",
        );
      }

      // --- Validate the request data against the base entry schema (includes entryType) ---
      const requestResult = entrySchema.safeParse(request.data);
      if (!requestResult.success) {
        // Use format() for better error logging
        logger.error(
          "Invalid request data format:",
          requestResult.error.format(),
        );
        throw new HttpsError(
          "invalid-argument",
          `Invalid request data: ${requestResult.error
            .format()
            ._errors?.join(", ")}`,
        );
      }

      // --- Destructure validated data, including entryType ---
      const {
        journalId,
        entryType, // --- Get entryType ---
        name,
        details: rawDetails,
        entryId,
      } = requestResult.data;
      const uid = request.auth.uid;

      // Get the main journal document to check access and journalType
      const journalDocRef = db.collection(JOURNAL_COLLECTION).doc(journalId);
      const journalDoc = await journalDocRef.get();
      if (!journalDoc.exists) {
        throw new HttpsError("not-found", "Journal not found or no access.");
      }
      const journalData = journalDoc.data() || {};
      const journalType = journalData.journalType; // Type of the parent journal (e.g., 'business', 'baby')

      // --- Check user permission ---
      if (
        !Object.getOwnPropertyDescriptor(journalData?.access ?? {}, uid) ||
        !ROLES_THAT_ADD.has(journalData?.access?.[uid]?.role)
      ) {
        throw new HttpsError(
          "permission-denied",
          "No access to add entries to this journal.",
        );
      }

      // --- Get subcollection configuration based on entryType ---
      const config = ENTRY_CONFIG[entryType as EntryType]; // Type assertion needed here
      if (!config) {
        throw new HttpsError(
          "invalid-argument",
          `Unsupported entryType: ${entryType}`,
        );
      }
      const { subcollection: targetSubcollectionName, schema: detailsSchema } =
        config;

      logger.info(
        `Processing entryType '${entryType}' for journal ${journalId} (type: ${journalType}).` +
          ` Target subcollection: ${targetSubcollectionName}`,
      );
      // --- Validate details against the specific schema for the entryType ---
      const detailsResult = detailsSchema.safeParse(rawDetails);
      if (!detailsResult.success) {
        // Use the utility function for schema errors
        handleSchemaValidationError(entryType, detailsResult);
      }
      const validatedDetails = detailsResult.data;

      logger.info(`Entry details for ${entryType} validated successfully.`);

      // Construct the base entry object (timestamps and details added below)
      const baseEntry: Omit<
        EntryItf,
        "createdAt" | "updatedAt" | "details" | "createdBy"
      > = {
        name: name,
        isActive: true,
        // createdBy will be set based on context (add vs update)
      };

      // --- Determine the target collection reference ---
      const entriesColRef = journalDocRef.collection(targetSubcollectionName);

      if (entryId) {
        // --- Update existing entry ---
        await db
          .runTransaction(async (transaction) => {
            const entryDocRef = entriesColRef.doc(entryId);
            // Optionally, verify the entry exists and belongs to the user if needed
            const existingEntryDoc = await transaction.get(entryDocRef);
            if (!existingEntryDoc.exists) {
              throw new HttpsError(
                "not-found",
                `Entry ${entryId} not found in ${targetSubcollectionName}.`,
              );
            }
            // Consider adding check if user is allowed to edit (e.g., createdBy === uid or role allows)

            transaction.update(entryDocRef, {
              ...baseEntry, // Include name, isActive
              details: validatedDetails,
              updatedAt: FieldValue.serverTimestamp(),
              // DO NOT update createdBy or createdAt on edits
            });
          })
          .catch((error) => {
            logger.error("Transaction failed during update: ", error);
            if (error instanceof HttpsError) throw error;
            throw new HttpsError(
              "internal",
              "Failed to update entry. Please try again later.",
            );
          });
        logger.info(
          `Entry ${entryId} in ${targetSubcollectionName} updated successfully`,
        );
        return {
          result: "ok",
          message: "Entry updated successfully",
          id: entryId,
        };
      } else {
        // --- Add new entry ---
        const docRef = await entriesColRef
          .add({
            ...baseEntry,
            createdBy: uid, // Set creator on add
            details: validatedDetails,
            createdAt: FieldValue.serverTimestamp(),
            updatedAt: FieldValue.serverTimestamp(),
          })
          .catch((error) => {
            logger.error("Error adding entry: ", error);
            throw new HttpsError(
              "internal",
              "Failed to add entry. Please try again later.",
            );
          });

        logger.info(
          `${entryType} entry successfully added to ${targetSubcollectionName} in journal ${journalId}`,
        );
        return {
          result: "ok",
          message: "Entry added successfully",
          id: docRef.id,
        };
      }
    } catch (error) {
      logger.error("Error in addLogFn:", error);
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "An unexpected error occurred. Please try again later.",
      );
    }
  },
);



# backend/functions/src/bg-create-new-journal.ts
/**
 * Import function triggers from their respective submodules:
 *
 * import {onCall} from "firebase-functions/v2/https";
 * import {onDocumentWritten} from "firebase-functions/v2/firestore";
 *
 * See a full list of supported triggers at https://firebase.google.com/docs/functions
 */

import { onCall, HttpsError } from "firebase-functions/v2/https";
import * as logger from "firebase-functions/logger";
import { getFirestore, FieldValue } from "firebase-admin/firestore";
import { initializeApp, getApps } from "firebase-admin/app";
import { ALLOWED } from "./lib/bg-consts";
import { JournalSchema } from "./common/schemas/JournalSchema";
import { JOURNAL_COLLECTION } from "./common/const";

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

// allow cors for all origins
export const createNewJournal = onCall(
  {
    cors: ALLOWED,
    enforceAppCheck: true,
  },
  async (request) => {
    try {
      logger.info("createNewJournal called");
      // retunn erro if not authenticated
      if (!request.auth) {
        throw new HttpsError(
          "unauthenticated",
          "You must be signed in to create a message",
        );
      }

      // check if the request.data is valid
      const result = JournalSchema.safeParse(request.data);
      if (!result.success) {
        // return error to the client
        logger.error("Invalid request data", result.error);
        throw new HttpsError("invalid-argument", result.error.message);
      }

      const uid = request.auth.uid;

      const journalData = {
        title: result.data.title,
        journalType: result.data.journalType,
        access: {
          [uid]: {
            role: "admin",
            email: request.auth.token.email || null,
            displayName: request.auth.token.name || null,
            photoURL: request.auth.token.picture || null,
          },
        },
        access_array: [uid],
        createdAt: FieldValue.serverTimestamp(),
        isActive: true,
        details: {
          parent: null,
          currency:
            result.data.details && "currency" in result.data.details ?
              result.data.details.currency :
              null,
        },
      };
      //
      // Validate against JournalDocumentSchema
      const validationResult = JournalSchema.safeParse(journalData);
      if (!validationResult.success) {
        logger.error("Journal data validation error", validationResult.error);
        throw new HttpsError(
          "invalid-argument",
          "Invalid journal data. Please check the data you are sending." +
            validationResult.error.message, // Optionally add more details from validationResult.error
        );
      }
      // Use validated journalData to create a new document
      const logDocRef = db.collection(JOURNAL_COLLECTION).doc();
      await logDocRef.set(validationResult.data);
      return {
        result: "ok",
        message: `Log journal created successfully. uuid: ${logDocRef.id}`,
      };
    } catch (error) {
      logger.error("Error creating new journal", error);
      throw new HttpsError(
        "internal",
        "Error creating new journal. Please try again later.",
      );
    }

    // return ok
  },
);



# backend/functions/src/bg-delete-entry.ts
// backend/functions/src/bg-delete-entry.ts (File can be renamed later if desired)
import { onCall, HttpsError } from "firebase-functions/v2/https";
import * as logger from "firebase-functions/logger";
import { getFirestore, FieldValue } from "firebase-admin/firestore";
import { initializeApp, getApps } from "firebase-admin/app";
import * as z from "zod";
// --- Update imports ---
import { JOURNAL_COLLECTION, ROLES_CAN_DELETE } from "./common/const"; // Use ROLES_CAN_DELETE
import { ENTRY_CONFIG } from "./common/schemas/configmap";
import { EntryType } from "./common/schemas/configmap";
import { ALLOWED } from "./lib/bg-consts";

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

// --- Schema for deleteJournal ---
const deleteJournalSchema = z.object({
  journalId: z.string().min(1),
});

export const deleteJournal = onCall(
  {
    cors: ALLOWED,
    enforceAppCheck: true,
  },
  async (request) => {
    logger.info("deleteJournal called");
    try {
      if (!request.auth) {
        throw new HttpsError("unauthenticated", "User is not logged in.");
      }
      const uid = request.auth.uid;

      const result = deleteJournalSchema.safeParse(request.data);
      if (!result.success) {
        logger.error("Invalid data for deleteJournal:", result.error.format());
        throw new HttpsError(
          "invalid-argument",
          "Invalid journal ID provided.",
        );
      }

      const { journalId } = result.data;
      const journalRef = db.collection(JOURNAL_COLLECTION).doc(journalId);
      const journalDoc = await journalRef.get();

      if (!journalDoc.exists) {
        throw new HttpsError("not-found", "Journal not found.");
      }

      const journalData = journalDoc.data();
      if (!journalData) {
        throw new HttpsError("internal", "Journal data is empty.");
      }

      // --- Check permissions using ROLES_CAN_DELETE ---
      const access = journalData.access;
      if (!access || !access[uid] || !ROLES_CAN_DELETE.has(access[uid].role)) {
        logger.warn(
          `User ${uid} does not have permission to delete journal ${journalId}. Role: ${access?.[uid]?.role}`,
        );
        throw new HttpsError(
          "permission-denied",
          "You do not have permission to delete this journal.",
        );
      }

      // --- Soft delete the main journal document ---
      await journalRef.update({
        isActive: false,
        deletedAt: FieldValue.serverTimestamp(),
        deletedBy: uid,
        updatedAt: FieldValue.serverTimestamp(), // Add updatedAt
      });

      logger.info(`Journal ${journalId} marked as deleted by user ${uid}.`);

      // --- REMOVED logic to delete children documents ---

      return { message: "Journal deleted successfully." };
    } catch (error) {
      logger.error("deleteJournal error:", error);
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "An error occurred while deleting the journal.",
      );
    }
  },
);

// --- Schema for deleteEntry ---
const deleteEntrySchema = z.object({
  journalId: z.string().min(1),
  entryId: z.string().min(1),
  entryType: z.enum(Object.keys(ENTRY_CONFIG) as [string, ...string[]]),
});

export const deleteEntry = onCall(
  {
    cors: ALLOWED,
    enforceAppCheck: true,
  },
  async (request) => {
    logger.info("deleteEntry called");
    try {
      if (!request.auth) {
        throw new HttpsError("unauthenticated", "User is not logged in.");
      }
      const uid = request.auth.uid;

      const result = deleteEntrySchema.safeParse(request.data);
      if (!result.success) {
        logger.error("Invalid data for deleteEntry:", result.error.format());
        throw new HttpsError(
          "invalid-argument",
          `Invalid data provided: ${result.error.format()._errors?.join(", ")}`,
        );
      }

      const { journalId, entryId, entryType } = result.data;

      // --- Get journal to check permissions ---
      const journalRef = db.collection(JOURNAL_COLLECTION).doc(journalId);
      const journalDoc = await journalRef.get();

      if (!journalDoc.exists) {
        throw new HttpsError("not-found", "Parent journal not found.");
      }
      const journalData = journalDoc.data();
      if (!journalData) {
        throw new HttpsError("internal", "Journal data is empty.");
      }

      // --- Check permissions using ROLES_CAN_DELETE ---
      const access = journalData.access;
      if (!access || !access[uid] || !ROLES_CAN_DELETE.has(access[uid].role)) {
        logger.warn(
          `User ${uid} does not have permission to delete entry` +
            `${entryId} in journal ${journalId}. Role: ${access?.[uid]?.role}`,
        );
        throw new HttpsError(
          "permission-denied",
          "You do not have permission to delete this entry.",
        );
      }

      // --- Determine target subcollection ---
      const config = ENTRY_CONFIG[entryType as EntryType]; // Type assertion
      if (!config) {
        throw new HttpsError(
          "invalid-argument",
          `Invalid entryType: ${entryType}`,
        );
      }
      const targetSubcollectionName = config.subcollection;

      const entryRef = journalRef
        .collection(targetSubcollectionName)
        .doc(entryId);

      // --- Soft delete the entry ---
      // Optionally check if entry exists before updating
      // const entryDoc = await entryRef.get();
      // if (!entryDoc.exists) {
      //     throw new HttpsError("not-found", `Entry ${entryId} not found in ${targetSubcollectionName}.`);
      // }

      await entryRef.update({
        isActive: false,
        deletedAt: FieldValue.serverTimestamp(),
        deletedBy: uid,
        updatedAt: FieldValue.serverTimestamp(), // Add updatedAt
      });

      logger.info(
        `Entry ${entryId} (${entryType}) in journal ${journalId} marked as deleted by user ${uid}.`,
      );
      return { message: "Entry deleted successfully." };
    } catch (error) {
      logger.error("deleteEntry error:", error);
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "An error occurred while deleting the entry.",
      );
    }
  },
);

// --- REMOVE original combined deleteItem/deleteEntry function ---
// export const deleteItem = ...



# backend/functions/src/cache-updates/bg-cache.ts
// backend/functions/src/cache-updates/bg-cache.ts
import { onDocumentWritten } from "firebase-functions/v2/firestore";
import { Firestore, getFirestore, FieldValue } from "firebase-admin/firestore";
import { initializeApp, getApps } from "firebase-admin/app";
import { EntryItf } from "../common/common_types";
import { materialItemSchema } from "../common/schemas/InventorySchema";
import { handleSchemaValidationError } from "../lib/bg-consts";
// --- Import correct constants ---
import { JOURNAL_COLLECTION, JOURNAL_TYPES } from "../common/const";
import { ENTRY_CONFIG } from "../common/schemas/configmap";
import * as logger from "firebase-functions/logger";

if (getApps().length === 0) {
  initializeApp();
}

const db: Firestore = getFirestore();

// --- Define the inventory subcollection name ---
const INVENTORY_SUBCOLLECTION = ENTRY_CONFIG.inventory.subcollection; // "inventory_items"

/**
 * triggered /journals/{journalId}/inventory_items collection is created or updated.
 * It updates the parent journal document with a cache of active inventory items.
 */
export const onInventoryEntryWrite = onDocumentWritten(
  // --- UPDATE the trigger path ---
  `${JOURNAL_COLLECTION}/{journalId}/${INVENTORY_SUBCOLLECTION}/{itemId}`,
  async (event) => {
    const { journalId, itemId } = event.params; // Parameters match the path segments
    const entryDataAfter = (event.data?.after.data() ||
      null) as EntryItf | null;
    const entryDataBefore = (event.data?.before.data() ||
      null) as EntryItf | null;

    if (!entryDataAfter && !entryDataBefore) {
      logger.warn(
        `∅ No data found for item ${itemId} in journal ${journalId}. Skipping update.`,
      );
      return;
    }

    // Get the parent journal document
    const journalDocRef = db.collection(JOURNAL_COLLECTION).doc(journalId);
    const journalDoc = await journalDocRef.get();

    if (!journalDoc.exists) {
      logger.warn(
        `∅ Parent journal document ${journalId} does not exist. Cannot update cache for item ${itemId}.`,
      );
      return;
    }

    const journalData = journalDoc.data();
    // --- Ensure this is a business journal ---
    if (journalData?.journalType !== JOURNAL_TYPES.BUSINESS) {
      logger.info(
        `Journal ${journalId} is not a business journal (type: ${journalData?.journalType}).` +
          ` Skipping inventory cache update for item ${itemId}.`,
      );
      return;
    }

    logger.info(
      `Inventory item written in journal ${journalId}, itemId: ${itemId}. Updating cache.`,
    );

    // Determine if it's a delete/deactivation or an add/update
    const isDeletion = !entryDataAfter || entryDataAfter.isActive === false;

    if (isDeletion) {
      // --- Handle deletion/deactivation: Remove from cache ---
      logger.info(
        `Deleting activeItems cache for item ${itemId} in journal ${journalId}`,
      );
      try {
        await journalDocRef.update({
          // --- UPDATE cache path --- (e.g., use 'inventoryCache' field)
          [`inventoryCache.${itemId}`]: FieldValue.delete(),
          updatedAt: FieldValue.serverTimestamp(),
        });
        logger.info(
          `Cache updated successfully for deletion of item ${itemId} in journal ${journalId}.`,
        );
      } catch (error) {
        logger.error(
          `Error deleting item ${itemId} from cache in journal ${journalId}:`,
          error,
        );
      }
    } else {
      // --- Handle add/update: Validate and update cache ---
      // Validate that entryDataAfter is still a valid inventory item entry
      const detailsResult = materialItemSchema.safeParse(
        entryDataAfter.details,
      );
      if (!detailsResult.success) {
        // Use utility function - maybe pass 'inventory' type explicitly
        handleSchemaValidationError("inventory", detailsResult);
        logger.error(
          `Invalid details for inventory item ${itemId} in journal ${journalId}. Aborting cache update.`,
        );
        return; // Don't update cache if details are invalid
      }

      // Prepare the cache entry - potentially simplify it if needed
      // For now, storing the whole entry might be fine
      const cacheEntry = {
        ...entryDataAfter, // Includes details, createdBy, timestamps etc.
        // You could simplify this to only store essential fields for the frontend if needed:
        // name: entryDataAfter.name,
        // details: validatedDetails, // Use validated details if needed
        // createdBy: entryDataAfter.createdBy,
        // createdAt: entryDataAfter.createdAt,
        // updatedAt: entryDataAfter.updatedAt
      };

      logger.info(
        `Updating inventoryCache for item ${itemId} in journal ${journalId} with data: ${JSON.stringify(
          cacheEntry,
        )}`,
      );
      try {
        await journalDocRef.update({
          // --- UPDATE cache path ---
          [`inventoryCache.${itemId}`]: cacheEntry,
          updatedAt: FieldValue.serverTimestamp(),
        });
        logger.info(
          `Cache updated successfully for item ${itemId} in journal ${journalId}.`,
        );
      } catch (error) {
        logger.error(
          `Error updating cache for item ${itemId} in journal ${journalId}:`,
          error,
        );
      }
    }
  },
);

// --- REMOVE or Adapt the generic onEntryWrite if it existed ---
// The specific onInventoryEntryWrite is now handling inventory.
// You might create similar specific triggers for other types (e.g., cashflow totals) if needed.

/*
// Example: Placeholder for a future cash flow trigger
export const onCashflowEntryWrite = onDocumentWritten(
  `${JOURNAL_COLLECTION}/{journalId}/${ENTRY_CONFIG.cashflow.subcollection}/{entryId}`,
  async (event) => {
    // ... logic to update cashflow totals on the parent journal ...
  }
);
*/



# backend/functions/src/common/common_types.ts
import { AccessMap } from "./schemas/common_schemas";
import { Timestamp } from "firebase-admin/firestore";

export interface EntryItf {
  name: string;
  isActive: boolean;
  deletedAt?: Timestamp;
  deletedBy?: string;
  createdBy: string;
  createdAt: Timestamp;
  updatedAt: Timestamp;
  details: {
    [key: string]: any;
  };
}

export enum JournalRole {
  "admin",
  "editor",
  "staff",
  "viewer",
}

export interface JournalUser {
  displayName: string;
  role: JournalRole;
  email: string;
  photoURL: string;
}

export interface JournalDocument {
  id?: string; // only for the UI, the UI library hydrates the doc with the document ID
  title: string;
  journalType: string;
  status: string;
  createdAt: Timestamp;
  updatedAt: Timestamp;
  access: AccessMap;
  pendingAccess: {
    [email: string]: JournalRole;
  };
}



# backend/functions/src/common/const.ts
// backend/functions/src/common/const.ts
import * as z from "zod";

export const ROLES_THAT_ADD = new Set(["reporter", "admin", "editor"]);
export const ROLES_CAN_DELETE = new Set(["admin", "editor"]);
export const JOURNAL_COLLECTION = "journals";
// --- REMOVE --- (no longer the primary way to identify entries)
// export const ENTRIES_SUBCOLLECTION = "entries";

export const JOURNAL_TYPES = {
  BUSINESS: "business",
  BABY: "baby",
} as const;

// --- NEW: Define Baby Entry Types ---
export const BABY_ENTRY_TYPES = {
  NAP: "nap",
  DIAPER: "diaper",
  FEED: "feed",
  GROWTH: "growth",
} as const;

// --- NEW/UPDATE: Map Entry Types to Subcollections and Schemas ---
// Define baby schemas (simple placeholders for now)
export const napDetailsSchema = z.object({
  start: z.coerce.date(),
  end: z.coerce.date().optional(),
  notes: z.string().optional(),
});
export const diaperDetailsSchema = z.object({
  time: z.coerce.date(),
  type: z.enum(["wet", "dirty", "mixed"]),
  notes: z.string().optional(),
});
export const feedDetailsSchema = z.object({
  time: z.coerce.date(),
  type: z.enum(["breast", "bottle"]),
  amount: z.number().optional(),
  unit: z.string().optional(),
  notes: z.string().optional(),
});
export const growthDetailsSchema = z.object({
  date: z.coerce.date(),
  weight: z.number().optional(),
  height: z.number().optional(),
  headCirc: z.number().optional(),
  notes: z.string().optional(),
});

export const CURRENCY_OPTIONS: {
  [symbol: string]: { code: string; name: string; symbol: string };
} = {
  USD: { code: "USD", name: "United States Dollar", symbol: "$" },
  BRL: { code: "BRL", name: "Brazilian Real", symbol: "R$" },
};



# backend/functions/src/common/schemas/CashflowSchema.ts
import * as z from "zod";

export const cashFlowEntryDetailsSchema = z.object({
  description: z
    .string()
    .min(3, {
      message: "The description must be at least 3 characters.",
    })
    .max(254, {
      message: "A max of 254 characters is allowed in the description.",
    }),
  date: z.coerce
    .date({
      required_error: "An entry date is required",
    })
    .nullable(),
  type: z.enum(["received", "paid"], {
    required_error: "Please select an entry type.", // Renamed to avoid confusion with journalType
  }),
  value: z.coerce.number().min(0.01, {
    message: "The value must be greater than 0.",
  }),
  currency: z.enum(["USD", "BRL"], {
    required_error: "Please select a currency.",
  }),
});

export type CashFlowEntryDetailsType = z.infer<
  typeof cashFlowEntryDetailsSchema
>;
// export interface CashFlowEntryDetailsType {
//   description: string;
//   date: Date;
//   type: "received" | "paid";
//   value: number;
// }



# backend/functions/src/common/schemas/InventorySchema.ts
import * as z from "zod";
import { allowedCurrencySchema } from "./common_schemas";

export const dimensionConfigSchema = z.object({
  type: z.enum(["area", "unit"]),
  unitLabel: z.enum(["m²", "ft²", "unit"]),
});

export const laborItemSchema = z.object({
  id: z.string(),
  laborRate: z.number().nonnegative(),
  laborType: z.enum(["quantity", "fixed", "percentage"]),
  description: z.string(),
});

export const materialItemSchema = z
  .object({
    id: z
      .string()
      .min(3, {
        message: "The description must be at least 3 characters.",
      })
      .max(254, {
        message: "A max of 254 characters is allowed in the description.",
      })
      .optional(),
    description: z.string(),
    unitPrice: z.number().nonnegative(),
    dimensions: dimensionConfigSchema,
    currency: allowedCurrencySchema.nullable(),
    labor: laborItemSchema.nullable().optional(), // Labor can be null or undefined
  })
  .strict();

export type materialItemSchemaType = z.infer<typeof materialItemSchema>;



# backend/functions/src/common/schemas/JournalSchema.ts
import * as z from "zod";
import {
  AccessSchema,
  ROLES,
  allowedCurrencySchema,
  contactInfoSchema,
} from "./common_schemas";
import { JOURNAL_TYPES } from "../const";

export const journalTypeSchema = z.nativeEnum(JOURNAL_TYPES);

export const businessDetailsSchema = z
  .object({
    currency: allowedCurrencySchema,
    contactInfo: contactInfoSchema,
    logo: z.string().nullable(),
  })
  .strict();

export const babyDetailsSchema = z
  .object({
    childName: z.string().min(1),
    dateOfBirth: z.coerce.date().optional().nullable(),
  })
  .strict();

export const JournalSchema = z
  .object({
    id: z.string().min(20).max(50).optional(),
    access: AccessSchema,
    access_array: z.array(z.string()),
    pendingAccess: z.record(z.string().email(), z.enum(ROLES)).optional(),
    createdAt: z.coerce.date(),
    journalType: journalTypeSchema,
    title: z.string(),
    details: z.union([businessDetailsSchema, babyDetailsSchema]).optional(),
    isActive: z.boolean(),
  })
  .strict();

export const JournalCreateBaseSchema = JournalSchema.omit({
  id: true,
  access: true,
  access_array: true,
  pendingAccess: true,
  createdAt: true,
  isActive: true,
});

export type JournalSchemaType = z.infer<typeof JournalSchema>;
export type BusinessDetailsType = z.infer<typeof businessDetailsSchema>;
export type BabyDetailsType = z.infer<typeof babyDetailsSchema>;
export type AccessMap = z.infer<typeof AccessSchema>;
export type PendingAccess = z.infer<typeof JournalSchema>["pendingAccess"];
export type JournalCreateBaseType = z.infer<typeof JournalCreateBaseSchema>;



# backend/functions/src/common/schemas/common_schemas.ts
// backend/functions/src/common/schemas/common_schemas.ts
import * as z from "zod";

export const ROLES = ["viewer", "reporter", "editor", "admin"] as const;

// User access schemas
export const UserSchema = z.object({
  displayName: z.string(),
  email: z.string().email(),
  photoURL: z.string().url().optional(),
  role: z.enum(ROLES),
});

export const AccessSchema = z.record(z.string(), UserSchema);
export const pendingAccessSchema = z.record(
  z.string().email({ message: "Please enter a valid email." }),
  z.enum(ROLES),
);

export const allowedCurrencySchema = z.enum(["USD", "BRL"], {
  required_error: "Allowed currency is mandatory.",
  invalid_type_error: "Allowed currency is mandatory.",
});

export type allowedCurrencySchemaType = z.infer<typeof allowedCurrencySchema>;

export const contactInfoSchema = z.object({
  name: z
    .string()
    .min(3, { message: "Name longer than 3 letters is required" })
    .max(50, { message: "Name must be less than 50 characters" }),
  email: z
    .string()
    .email({ message: "Please enter a valid email address" })
    .optional()
    .nullable(),
  phone: z
    .string()
    .min(10, { message: "Phone number must be at least 10 digits" })
    .regex(/^\+?[\d\s-()]+$/, {
      message: "Please enter a valid phone number",
    })
    .optional()
    .nullable(),
  address: z.object({
    street: z
      .string()
      .min(1, { message: "Street address is required" })
      .optional()
      .nullable(),
    city: z
      .string()
      .min(1, { message: "City is required" })
      .optional()
      .nullable(),
    state: z
      .string()
      .min(1, { message: "State is required" })
      .optional()
      .nullable(),
    zipCode: z
      .string()
      .regex(/^\d{5}(-\d{0,4})?$/, {
        message: "Please enter a valid ZIP code",
      })
      .optional()
      .nullable(),
  }),
});
export type contactInfoSchemaType = z.infer<typeof contactInfoSchema>;

export type AccessMap = z.infer<typeof AccessSchema>;

export type UserSchemaType = z.infer<typeof UserSchema>;

export type pendingAccessSchemaType = z.infer<typeof pendingAccessSchema>;



# backend/functions/src/common/schemas/configmap.ts
import * as z from "zod";
import {
  BABY_ENTRY_TYPES,
  napDetailsSchema,
  diaperDetailsSchema,
  feedDetailsSchema,
  growthDetailsSchema,
} from "../const";
import { cashFlowEntryDetailsSchema } from "./CashflowSchema";
import { materialItemSchema } from "./InventorySchema";
import { quoteDetailsStateSchema } from "./quote_schema";

// Define an interface for entry configuration
interface EntryConfig<T extends z.ZodTypeAny> {
  subcollection: string;
  schema: T;
  displayName?: string; // Optional human-readable name
  icon?: string; // Optional icon identifier
  category: "business" | "baby" | "other";
  sortField?: string; // Optional sort field
}

// Map EntryType -> EntryConfig
export const ENTRY_CONFIG = {
  // Business Entry Types
  cashflow: {
    subcollection: "cashflow_entries",
    schema: cashFlowEntryDetailsSchema,
    displayName: "Cash Flow",
    category: "business",
    sortField: "details.date", // Add sortField
  },
  inventory: {
    subcollection: "inventory_items",
    schema: materialItemSchema,
    displayName: "Inventory",
    category: "business",
    sortField: "createdAt", // Add sortField
  },
  quote: {
    subcollection: "quotes",
    schema: quoteDetailsStateSchema,
    displayName: "Quote",
    category: "business",
    sortField: "createdAt", // Add sortField
  },

  // Baby Entry Types
  [BABY_ENTRY_TYPES.NAP]: {
    subcollection: "naps",
    schema: napDetailsSchema,
    displayName: "Nap",
    category: "baby",
    sortField: "details.start", // Add sortField
  },
  [BABY_ENTRY_TYPES.DIAPER]: {
    subcollection: "diapers",
    schema: diaperDetailsSchema,
    displayName: "Diaper",
    category: "baby",
    sortField: "details.time", // Add sortField
  },
  [BABY_ENTRY_TYPES.FEED]: {
    subcollection: "feeds",
    schema: feedDetailsSchema,
    displayName: "Feed",
    category: "baby",
    sortField: "details.time", // Add sortField
  },
  [BABY_ENTRY_TYPES.GROWTH]: {
    subcollection: "growth_entries",
    schema: growthDetailsSchema,
    displayName: "Growth",
    category: "baby",
    sortField: "details.date", // Add sortField
  },
} as const satisfies Record<string, EntryConfig<any>>;

// Helper functions to filter entries by category
export const getBusinessEntries = () =>
  Object.entries(ENTRY_CONFIG)
    .filter(([_, config]) => config.category === "business")
    .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});

export const getBabyEntries = () =>
  Object.entries(ENTRY_CONFIG)
    .filter(([_, config]) => config.category === "baby")
    .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});

// Type helper to get subcollection names
export type SubcollectionName =
  (typeof ENTRY_CONFIG)[keyof typeof ENTRY_CONFIG]["subcollection"];

// export schema for entry type validation

export const entryTypeSchema = z.enum(
  Object.keys(ENTRY_CONFIG) as [string, ...string[]],
  {
    required_error: "Entry type is mandatory.",
    invalid_type_error: "Invalid entry type.",
  },
);
export type EntryType = keyof typeof ENTRY_CONFIG;
// Entry schema

export const entrySchema = z.object({
  entryId: z.string().optional(),
  journalId: z.string(),
  entryType: entryTypeSchema,
  name: z
    .string()
    .min(3, { message: "Name must be at least 3 characters." })
    .max(254, { message: "Name cannot exceed 254 characters." }),
  details: z.unknown(), // Will be validated based on entryType
});



# backend/functions/src/common/schemas/quote_schema.ts
import * as z from "zod";
import { contactInfoSchema, allowedCurrencySchema } from "./common_schemas";
import {
  materialItemSchema,
  laborItemSchema,
  dimensionConfigSchema,
} from "./InventorySchema";


export const currencyCodeSchema = allowedCurrencySchema; // ISO 4217 currency codes are 3 letters
// Add this near the top of the file, before the schemas
export const currencySchema = z
  .object({
    code: currencyCodeSchema, // ISO 4217 currency codes are 3 letters
    symbol: z.string(),
    name: z.string(),
  })
  .nullable();

export const lineItemSchema = z.object({
  id: z.string(),
  parentId: z.string(),
  quantity: z.number().nonnegative(),
  dimensions: z
    .object({
      length: z.number().nonnegative().optional(),
      width: z.number().nonnegative().optional(),
    })
    .optional(),
  description: z
    .string()
    .min(3, {
      message: "The description must be at least 3 characters.",
    })
    .max(254, {
      message: "A max of 254 characters is allowed in the description.",
    }),
  material: materialItemSchema,
});

const adjustmentSchema = z.object({
  type: z.enum([
    "addPercent",
    "addFixed",
    "discountPercent",
    "discountFixed",
    "taxPercent",
  ]),
  value: z.number().nonnegative(),
  description: z.string(),
});

export const quoteDetailsStateSchema = z.object({
  confirmedItems: z.array(lineItemSchema),
  status: z.enum(["pending", "accepted", "rejected"]),
  customer: contactInfoSchema,
  supplier: contactInfoSchema,
  logo: z.string().nullable(),
  adjustments: z.array(adjustmentSchema),
  taxPercentage: z.number().nonnegative(),
  currency: currencyCodeSchema,
  notes: z
    .string()
    .max(250, { message: "Notes must be less than 250 characters" })
    .optional()
    .nullable(),
});

export type quoteDetailsState = z.infer<typeof quoteDetailsStateSchema>;
export type contactInfoSchemaType = z.infer<typeof contactInfoSchema>;
export type LineItem = z.infer<typeof lineItemSchema>;
export type Adjustment = z.infer<typeof adjustmentSchema>;
export type MaterialItem = z.infer<typeof materialItemSchema>;
export type LaborItem = z.infer<typeof laborItemSchema>;
export type DimensionConfig = z.infer<typeof dimensionConfigSchema>;
// Add the type export
export type Currency = z.infer<typeof currencySchema>;
export type CurrencyCode = z.infer<typeof currencyCodeSchema>;



# backend/functions/src/index.ts
import { addLogFn } from "./bg-add-log-entry";
import { createNewJournal } from "./bg-create-new-journal";
import { initializeApp, getApps } from "firebase-admin/app";
import { addContributor } from "./bg-add-contributors";
import { acceptShare } from "./bg-accept-share";
import { deleteJournal, deleteEntry } from "./bg-delete-entry"; // Import new functions
import { onInventoryEntryWrite } from "./cache-updates/bg-cache";
import { createJournal, updateJournal } from "./bg-add-group";

if (getApps().length === 0) {
  initializeApp();
}

exports.addLogFn = addLogFn;
exports.createNewJournal = createNewJournal; // remore ?
exports.updateJournal = updateJournal;
exports.createJournal = createJournal;
exports.addContributor = addContributor;
exports.acceptShare = acceptShare;
exports.deleteJournal = deleteJournal; // Export new function
exports.deleteEntry = deleteEntry; // Export new function

exports.onInventoryEntryWrite = onInventoryEntryWrite; // This trigger path will need changing later



# backend/functions/src/lib/bg-consts.ts
import { HttpsError } from "firebase-functions/https";
import type { SafeParseError } from "zod";

// allow localhost in CORS if running in developemtn enviroment
const ALLOWED = ["*"];
if (process.env.NODE_ENV === "development") {
  ALLOWED.push("http://localhost:3000");
}

export { ALLOWED }; // Utility function to handle schema validation errors

/**
 * Handles a schema validation error by throwing an HttpsError with detailed information.
 *
 * @param {string} journalType - The type of journal which failed validation.
 * @param {SafeParseError<any>} detailsResult - The result from a safe parse operation containing validation issues.
 * @throws {HttpsError} Throws an error indicating an invalid argument if schema validation fails.
 *
 * @remarks
 * This function aggregates all issue messages into a single formatted error message and throws an error.
 */
export function handleSchemaValidationError(
  journalType: string,
  detailsResult: SafeParseError<any>,
): never {
  throw new HttpsError(
    "invalid-argument",
    `Invalid entry details for journalType ${journalType}: \n${detailsResult.error.issues
      .map((issue) => `${issue.path.join(".")}: ${issue.message}`)
      .join("\n")}`,
  );
}



# backend/storage.rules
rules_version = '2';

// Craft rules based on data in your Firestore database
// allow write: if firestore.get(
//    /databases/(default)/documents/users/$(request.auth.uid)).data.isAdmin;
service firebase.storage {
  match /b/{bucket}/o {
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}



# frontend/README.md
# Journal App Frontend

This is the frontend for the Journal App, a web application that allows users to create and manage various types of journals.

## Technologies Used

- **Next.js:** React framework for server-side rendering and routing.
- **React:** JavaScript library for building user interfaces.
- **TypeScript:** Typed superset of JavaScript that compiles to plain JavaScript.
- **Tailwind CSS:** A utility-first CSS framework for rapid styling.
- **shadcn/ui:** Reusable UI components built with Tailwind CSS and Radix UI.

## Features

- **User Authentication:** Secure user login and registration.
- **Multiple Journal Types:** Create and manage different types of journals, including:
    -   **Cash Flow:** Track income and expenses.
    -   **Inventory:** Manage inventory items.
    -   **Quote:** Generate and manage quotes.
- **Journal Entry Management:** Add, view, edit, and delete entries for each journal type.
- **Journal Sharing and Collaboration:** Share journals with other users and manage their permissions.
- **Responsive Design:** The application is designed to work well on various devices.
- **Reusable UI Components:** Built with a library of reusable and customizable UI components.

## Project Structure

-   `src/app/`: Contains the application's routes, pages, and layout. Includes authenticated routes under `(auth)`.
-   `src/components/`: Houses various React components, including UI components (`ui` folder) and specific feature components.
-   `src/context/`: Contains React context providers for managing global state, such as `JournalContext`.
-   `src/hooks/`: Custom React hooks used across the application.
-   `src/lib/`: Contains utility functions, authentication handling, client-side database interactions, and shared schema definitions.

## Data Management

The frontend interacts with the backend to manage data. Shared schemas are used to ensure data consistency between the frontend and backend.



# frontend/components/QuoteEntryForm.tsx



# frontend/src/app/(auth)/@login/default.tsx
// frontend/src/app/page.tsx (Landing Page)
"use client";

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import {
  PackagePlus,
  PencilRuler,
  Printer,
  Share2,
  Settings,
  List,
  Circle,
  BookOpen,
  CalendarDays,
  Search,
} from "lucide-react";
import Link from "next/link";
import Image from "next/image";
import { Label } from "@/components/ui/label";
import { useAuth } from "@/lib/auth_handler";
import { Sign } from "crypto";

const GoogleIcon = () => (
  <div className="flex items-center justify-center w-6 h-6 rounded-full shadow">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      width="24"
      height="24"
    >
      <path
        d="M12.48 10.92v3.28h7.84c-.24 1.84-.853 3.187-1.787 4.133-1.147 1.147-2.933 2.4-6.053 2.4-4.827 0-8.6-3.893-8.6-8.72s3.773-8.72 8.6-8.72c2.6 0 4.507 1.027 5.907 2.347l2.307-2.307C18.747 1.44 16.133 0 12.48 0 5.867 0 .307 5.387.307 12s5.56 12 12.173 12c3.573 0 6.267-1.173 8.373-3.36 2.16-2.16 2.84-5.213 2.84-7.667 0-.76-.053-1.467-.173-2.053H12.48z"
        fill="currentColor"
      />
    </svg>
  </div>
);
export default function LandingPage() {
  const { authUser, signInWithGoogle } = useAuth();

  const SignInButton = () => (
    <Button
      variant="outline"
      className="bg-primary text-primary-foreground hover:bg-primary-foreground hover:text-primary"
      size="lg"
      onClick={() => signInWithGoogle()}
    >
      <GoogleIcon />
      <span className="ml-2">Sign in with Google</span>
    </Button>
  );
  return (
    <div className="flex flex-col min-h-screen bg-background">
      {/* Hero Section */}
      <header className="bg-primary text-primary-foreground py-12">
        <div className="container mx-auto px-4 text-center">
          <h1 className="text-4xl md:text-6xl font-bold mb-4">
            Create Professional Quotes in Minutes
          </h1>
          <p className="text-lg md:text-xl mb-8">
            Simple Quotes helps you generate, customize, and print/share
            business quotes effortlessly.
          </p>

          <div className="mt-8">
            <Image
              src="/logo.svg"
              alt="Simple Business Journals App Logo"
              width={120}
              height={120}
              className="mx-auto"
            />
          </div>
          <h3 className="text-2xl font-bold mt-8 mb-4">
            Try it for free today!
          </h3>
          <SignInButton />
        </div>
      </header>

      <Separator className="my-6" />

      {/* How It Works Section */}
      <section className="container mx-auto px-4 py-16">
        <h2 className="text-3xl font-bold text-center mb-12">
          Creating Quotes is as Easy as 1-2-3
        </h2>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
          <Card>
            <CardHeader>
              <Circle className="h-6 w-6" />
              <CardTitle>
                <span className="font-bold">1. Add Items</span>
              </CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-muted-foreground">
                Quickly add items to your quote, from your inventory or create
                new ones on the fly.c cashflow entriss, inventrory, quotes
              </p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <Circle className="h-6 w-6" />
              <CardTitle>
                <span className="font-bold">2. Customize</span>
              </CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-muted-foreground">
                Set prices, add discounts, include taxes, and personalize with
                your company logo and contact information.
              </p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <Circle className="h-6 w-6" />
              <CardTitle>
                <span className="font-bold">3. Print or Share</span>
              </CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-muted-foreground">
                Generate a professional PDF quote to print, or share directly
                with your client via a unique link.
              </p>
            </CardContent>
          </Card>
        </div>
      </section>

      <Separator className="my-6" />

      {/* Benefits Section */}
      <section className="container mx-auto px-4 py-16">
        <h2 className="text-3xl font-bold text-center mb-12">
          Why Use Simple Business Journals?
        </h2>
        <ul className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
          <li className="flex items-center space-x-4">
            <BookOpen className="h-6 w-6 text-primary" />
            <div>
              <h3 className="font-semibold">Stay Organized</h3>
              <p className="text-muted-foreground">
                Stop wasting time with spreadsheets. Create quotes in a
                fraction of the time.
              </p>
            </div>
          </li>
          <li className="flex items-center space-x-4">
            <CalendarDays className="h-6 w-6 text-primary" />
            <div>
              <h3 className="font-semibold">Look Professional</h3>
              <p className="text-muted-foreground">
                Impress clients with polished, branded quotes.
              </p>
            </div>
          </li>
          <li className="flex items-center space-x-4">
            <Settings className="h-6 w-6 text-primary" />
            <div>
              <h3 className="font-semibold">Easy to Use</h3>
              <p className="text-muted-foreground">
                No complicated software to learn. Get started instantly.
              </p>
            </div>
          </li>
          <li className="flex items-center space-x-4">
            <PackagePlus className="h-6 w-6 text-primary" />
            <div>
              <h3 className="font-semibold">Inventory</h3>
              <p className="text-muted-foreground">
                Keep track of your inventory and prices
              </p>
            </div>
          </li>
        </ul>
      </section>

      {/* Final CTA */}
      <section className=" py-16">
        <div className="container mx-auto px-4 text-center">
          <h2 className="text-3xl font-bold mb-8">
            Sign up now and start creating professional quotes in minutes!{" "}
          </h2>

          <SignInButton />
        </div>
      </section>

      {/* Footer */}
      <footer className="py-6 text-center text-muted-foreground">
        <p>Simple Business Journals © {new Date().getFullYear()}</p>
      </footer>
    </div>
  );
}



# frontend/src/app/(auth)/@login/loading.tsx
export default function loadingLogin() {
    return (
    <div>Loading Logged In...</div>
    )
  }


# frontend/src/app/(auth)/journal/actions/date-pick-with-range.tsx
"use client"
import { useState } from "react"
import { CalendarSearch } from "lucide-react"
import { addDays, format } from "date-fns"
// import { DateRange } from "react-day-picker"
import { Button } from "@/components/ui/button"
import { Calendar } from "@/components/ui/calendar"
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover"
import { on } from "events"

/*
  * Date picker with range
  * @param date - date range
  * @param setDate - set date range
  * @returns JSX.Element

*/

interface DateRange {
  from: Date
  to: Date
}

export function DatePickerWithRange({
  daterange,
  setDate
}: {
  daterange: DateRange | undefined
  setDate: React.Dispatch<React.SetStateAction<DateRange | undefined>>
}) {

  const [selected, setSelected] = useState<DateRange | undefined>(daterange)


  const handleOpenChange = (open: boolean) => {
    if (!open) {
      console.log("closing", selected)
      setDate(selected)
    }
  }

  return (
      <Popover onOpenChange={handleOpenChange}>
        <PopoverTrigger asChild>
          <Button
            id="daterange"
            variant={"outline"}
            size={"icon"}
          >
            <CalendarSearch className="h-5 w-5" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-auto p-0" align="start">
          <Calendar
            initialFocus
            mode="range"
            defaultMonth={ daterange?.from ?? new Date() }
            selected={selected}
            onSelect={ (date) => { date && setSelected(date as DateRange) } }
            numberOfMonths={2}
            
          />
        </PopoverContent>
      </Popover>

  )
}

// {date?.from ? (
//   date.to ? (
//     <>
//       {format(date.from, "LLL dd, y")} -{" "}
//       {format(date.to, "LLL dd, y")}
//     </>
//   ) : (
//     format(date.from, "LLL dd, y")
//   )
// ) : (
//   <span>Pick a date</span>
// )}



# frontend/src/app/(auth)/journal/actions/delete-entry.tsx
// frontend/src/app/(auth)/journal/actions/delete-entry.tsx
import { useState } from "react";
import {
  Dialog,
  DialogTrigger,
  DialogContent,
  // DialogFooter, // Removed as custom buttons are used
  DialogTitle,
  DialogDescription,
  DialogHeader,
  DialogClose, // Import DialogClose
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import * as z from "zod";
import { getFunctions, httpsCallable } from "firebase/functions";
import { Trash } from "lucide-react";
import { functions } from "@/lib/auth_handler"; // Import configured functions
import { useToast } from "@/hooks/use-toast"; // Import useToast
// --- Import EntryType and ENTRY_CONFIG keys ---
import {
  EntryType,
  entryTypeSchema,
} from "@/../../backend/functions/src/common/schemas/configmap"; // Import EntryType
// import { ENTRY_CONFIG } from "@/../../backend/functions/src/common/const"; // Use backend const

// --- Updated Backend Function Call ---
const deleteEntryFn = httpsCallable(functions, "deleteEntry", {
  // Renamed variable for clarity
  limitedUseAppCheckTokens: true,
});

// --- Updated Zod Schema ---
const deleteEntrySchema = z.object({
  journalId: z.string().min(1), // Use journalId for clarity
  entryId: z.string().min(1),
  entryType: entryTypeSchema, // Validate against known entry types
});

type DeletePayload = z.infer<typeof deleteEntrySchema>;

interface DeleteEntryBtnProps {
  journalId: string; // Use journalId
  entryId: string;
  entryType: EntryType; // --- ADD entryType prop ---
  entryName?: string; // Optional name for confirmation message
  onDeleted: () => void;
}

export function DeleteEntryBtn({
  journalId,
  entryId,
  entryType, // Get entryType from props
  entryName = "this item", // Default name
  onDeleted,
}: DeleteEntryBtnProps) {
  const [pending, setPending] = useState(false);
  const [open, setOpen] = useState(false);
  const { toast } = useToast();

  const onSubmit = async () => {
    console.log(
      `Deleting entry ${entryId} of type ${entryType} in journal ${journalId}`,
    );
    setPending(true);

    const payload: DeletePayload = { journalId, entryId, entryType };

    // --- Validate payload client-side (optional but good practice) ---
    const validation = deleteEntrySchema.safeParse(payload);
    if (!validation.success) {
      console.error("Invalid delete payload:", validation.error.format());
      toast({
        title: "Error",
        description: "Invalid data for deletion.",
        variant: "destructive",
      });
      setPending(false);
      return; // Don't proceed
    }

    try {
      // Close the dialog first visually
      setOpen(false);

      // Call backend function after a short delay (allows dialog to close smoothly)
      // You might adjust delay or remove if closing animation isn't critical
      setTimeout(async () => {
        try {
          console.log("Calling deleteEntryFn with payload:", validation.data);
          await deleteEntryFn(validation.data); // Send validated data

          toast({
            title: "Entry Deleted",
            description: `"${entryName}" has been deleted successfully.`,
          });

          onDeleted(); // Call the callback provided by the parent
        } catch (error: any) {
          console.error("Error during deletion call:", error);
          toast({
            title: "Deletion Failed",
            description: error.message || "Could not delete the entry.",
            variant: "destructive",
          });
          // Don't call onDeleted if backend failed
        } finally {
          // Ensure pending is reset even if the inner try fails
          // Set pending false here if you remove the setTimeout
        }
      }, 100); // 100ms delay - adjust or remove as needed
    } catch (error) {
      // Catch errors from validation or initial setup
      console.error("Error setting up deletion:", error);
      toast({
        title: "Error",
        description: "An unexpected error occurred before deletion.",
        variant: "destructive",
      });
      setPending(false); // Ensure pending is false if outer try fails
    } finally {
      // If using setTimeout, pending should be reset inside the timeout's finally block
      // If not using setTimeout, reset it here:
      if (typeof setTimeout === "undefined") {
        // Basic check if setTimeout is available
        setPending(false);
      }
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        {/* Allow customization or provide a default trigger */}
        <Button
          variant="ghost"
          className="p-0 h-auto font-normal text-destructive hover:text-destructive/90 w-full justify-start"
        >
          <Trash className="h-4 w-4 inline mr-2" />
          Delete Entry
        </Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Confirm Deletion</DialogTitle>
          <DialogDescription>
            Are you sure you want to delete {entryName}? This action cannot be
            undone and will permanently remove the item.
          </DialogDescription>
        </DialogHeader>
        <div className="flex justify-end gap-3 pt-4">
          {" "}
          {/* Added pt-4 */}
          <DialogClose asChild>
            <Button variant="outline" disabled={pending}>
              Cancel
            </Button>
          </DialogClose>
          <Button variant="destructive" onClick={onSubmit} disabled={pending}>
            {pending ? "Deleting..." : "Delete Entry"}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}



# frontend/src/app/(auth)/journal/actions/export-to-csv.tsx
import React from "react";
// import the downlload icon form lucide
import { Download } from "lucide-react";
import { Timestamp } from "firebase/firestore";
import { AccessMap } from "@/../../backend/functions/src/common/schemas/common_schemas";
import { Button } from "@/components/ui/button";

interface DataObject {
  [key: string]: any;
}

interface Props {
  entry_list: DataObject[];
  filename: string;
  access: AccessMap;
}

// TODO: add createdBy using email instead of uid
// TODO: maybe change the date format to a more human readable on google sheets
const dataToCSV = (entry_list: DataObject[], access: AccessMap) => {
  try {
    const headers = Object.keys(entry_list[0])
      .map((header) => {
        // if details, return the keys of details (e.g. details.date, details.description, details.value)
        // else return the header
        if (header.startsWith("details")) {
          let details = entry_list[0].details;
          return Object.keys(details).map(
            (detailKey) => `details.${detailKey}`,
          );
        }
        return header;
      })
      .flat();

    const csv = [headers.join(",")];

    // base date as Dec 30, 1899 in UTC time
    entry_list.forEach((object) => {
      const values = headers.map((header) => {
        if (header === "createdBy") {
          return access?.[object[header]]?.email || object[header];
        }
        let v;
        if (header.startsWith("details.")) {
          const detailKey = header.split(".")[1];
          v = object.details ? object.details[detailKey] : "";
        } else {
          v = object[header];
        }
        if (v instanceof Timestamp) {
          return v.toDate().toISOString();
        }
        v = v.toString();
        v.replaceAll('"', '""');
        return `"${v}"`;
      });
      csv.push(values.join(","));
    });

    return csv.join("\r\n");
  } catch (error) {
    console.error("Error generating CSV:", error);
    console.error("entry_list", entry_list);
    throw new Error("Error generating CSV");
  }
};

const ExportToCSV = ({ entry_list, filename, access }: Props) => {
  const downloadCSV = () => {
    const csv = dataToCSV(entry_list, access);
    const blob = new Blob([csv], { type: "text/csv" });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };
  return entry_list.length === 0 ? null : (
    <Button
      onClick={downloadCSV}
      className="flex flex-row items-center text-sm font-bold space-x-2"
      variant="brutalist"
    >
      <Download size={16} />
      <p>Download</p>
    </Button>
  );
};

export default ExportToCSV;



# frontend/src/app/(auth)/journal/comp/Entry.tsx
// frontend/src/app/(auth)/journal/comp/Entry.tsx
import React, { memo } from "react";
import { DBentry, User } from "../../../../lib/custom_types";
import { getEntryComponent } from "../journal-types/config";
import { EntryType } from "@/../../backend/functions/src/common/schemas/configmap"; // Import EntryType

// --- Update Props ---
export interface EntryProps {
  // Renamed from EntryViewProps to avoid confusion
  journalId: string; // --- ADD journalId ---
  entryType: EntryType; // --- ADD entryType ---
  entry: DBentry;
  user: User; // Creator user info
  role: string; // Logged-in user's role
  removeFn: (entry: DBentry) => void;
}

export const Entry = memo(function Entry({
  journalId, // Get props
  entryType,
  entry,
  user,
  role,
  removeFn,
}: EntryProps) {
  // Use updated props type
  // --- Determine Component based on entryType ---
  const ViewComponent = getEntryComponent(entryType); // Use entryType

  if (!ViewComponent) {
    console.warn(`No component configured for entry type: ${entryType}`);
    return (
      <div className="pl-4 text-sm text-red-500">
        Error: Unknown entry type {entryType}
      </div>
    );
  }

  // Dynamically render the component, passing necessary props
  return React.createElement(
    ViewComponent as React.ComponentType<any>, // Use 'any' or a more generic prop type if needed
    {
      journalId, // Pass down
      entry,
      entryType, // Pass down
      user,
      role,
      removeFn,
    },
  );
});



# frontend/src/app/(auth)/journal/comp/EntryView.tsx
// frontend/src/app/(auth)/journal/comp/EntryView.tsx
import React, { memo } from "react";
import { DBentry, User } from "@/lib/custom_types"; // Keep using DBentry
import { ROLES_CAN_DELETE } from "@/../../backend/functions/src/common/const";
import { DeleteEntryBtn } from "../actions/delete-entry";
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { MoreVertical } from "lucide-react";
import { EntryType } from "@/../../backend/functions/src/common/schemas/configmap"; // Import EntryType

// --- Update Props ---
export interface EntryViewProps<T extends DBentry> {
  journalId: string; // Use journalId for clarity
  entry: T;
  entryType: EntryType; // --- ADD entryType prop ---
  user: User; // User who created the entry (from access map)
  role: string; // Role of the *logged-in* user viewing the entry
  removeFn: (entry: T) => void; // Callback for UI removal
  children: React.ReactNode; // Type-specific content
}

export const EntryView = memo(function EntryView<T extends DBentry>({
  journalId, // Get journalId
  entry,
  entryType, // --- Get entryType ---
  user,
  role, // This is the viewing user's role
  removeFn,
  children,
}: EntryViewProps<T>) {
  return (
    // Consider adding data attributes for easier testing/styling
    <div
      className="pl-4 pb-2 w-full border-t border-border pt-2"
      data-entry-id={entry.id}
      data-entry-type={entryType}
    >
      <div className="flex items-start justify-between">
        <div className="flex-grow pr-2">
          {" "}
          {/* Add padding right */}
          {children} {/* Render type-specific details here */}
        </div>

        {/* --- Check role for delete permission --- */}
        {ROLES_CAN_DELETE.has(role) && (
          <div className="flex-shrink-0 ml-auto" id={`entry-menu-${entry.id}`}>
            {" "}
            {/* Use ml-auto */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" className="h-8 w-8">
                  <MoreVertical className="h-4 w-4" />
                  <span className="sr-only">Open menu</span>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem
                  className="text-destructive focus:text-destructive focus:bg-destructive/10 p-0" // Remove default padding
                  onSelect={(e) => e.preventDefault()} // Prevent default close/action
                >
                  {/* --- Pass props to DeleteEntryBtn --- */}
                  <DeleteEntryBtn
                    journalId={journalId} // Pass journalId
                    entryId={entry.id}
                    entryType={entryType} // --- Pass entryType ---
                    entryName={entry.name || entryType} // Pass entry name or type
                    onDeleted={() => removeFn(entry)}
                  />
                </DropdownMenuItem>
                {/* Add Edit option here later if needed */}
                {/* <DropdownMenuItem>Edit</DropdownMenuItem> */}
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        )}
      </div>
    </div>
  );
});



# frontend/src/app/(auth)/journal/comp/chat.tsx
import React, { useState, useEffect, useCallback, memo, useRef } from "react";
import { DBentry } from "../../../../lib/custom_types";
import { AccessMap } from "@/../../backend/functions/src/common/schemas/common_schemas";
import { Button } from "@/components/ui/button";
import { ChevronsUp, User } from "lucide-react";
import { Entry } from "./Entry";
import { useFetchEntries } from "./useFetch";
import { useAuth } from "@/lib/auth_handler";
import { AddInventoryEntryForm } from "../journal-types/inventory/add-inventory-entry";
import { EntryType } from "@/../../backend/functions/src/common/schemas/configmap"; // Import EntryType

//TODO: handle delete of entries
interface MessageListProps {
  messages: DBentry[];
  journalId: string; // --- ADD journalId ---
  entryType: EntryType; // --- ADD entryType ---
  access: AccessMap;
  loading: boolean;
  role: string; // Logged-in user's role
  BottomFn?: () => void;
  removeFn: (entry: DBentry) => void;
}
const MessageList = memo(function MessageList({
  messages,
  journalId, // Get prop
  entryType, // Get prop
  access,
  loading,
  role,
  BottomFn,
  removeFn,
}: MessageListProps) {
  const [showToTopButton, setShowToTopButton] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    console.log("initializing MessageList");
  }, []);

  const handleScroll = useCallback(
    (event: React.UIEvent<HTMLDivElement>) => {
      const { scrollTop, clientHeight, scrollHeight } = event.currentTarget;
      console.log("scrolling");
      setShowToTopButton(scrollTop > 10);
      // check if we are at the bottom of the page and user is scrolling down
      if (scrollTop + clientHeight >= scrollHeight - 1) {
        BottomFn && BottomFn();
      }
    },
    [BottomFn],
  );

  const ButtonGoTop = () => {
    const goTopFn = useCallback(() => {
      // smooth scroll to top
      console.log("scrolling to top");
      // scroll to top if the scrollTop function is available
      if (scrollRef.current) {
        scrollRef.current.scrollTo({
          top: -10,
          behavior: "smooth",
        });
      }
    }, []);

    return (
      // Show this button on top of the scroll
      <Button
        // show button on top center of the scroll component
        className={`h-14 w-14 rounded-full transform -translate-x-1/2 -translate-y-1/2 z-50 absolute top-10 left-1/2 bg-primary
            ${showToTopButton ? "visible" : "invisible"}`}
        variant="outline"
        onClick={goTopFn}
      >
        <ChevronsUp />
      </Button>
    );
  };

  const Loading = () => {
    return (
      <div className="w-full h-14">
        {loading ? (
          <p className="text-center text-xs">Loading...</p>
        ) : (
          <p className="text-center text-xs">No more entries</p>
        )}
      </div>
    );
  };

  return (
    <div className="w-full h-full relative">
      <ButtonGoTop />
      <div
        className="w-full flex flex-col overflow-y-auto h-screen space-y-2"
        ref={scrollRef}
        onScroll={handleScroll}
      >
        {messages.map((entry: DBentry) => {
          const creatorInfo = access[entry.createdBy];
          if (!creatorInfo) {
            console.warn(
              `Creator info missing for user ID: ${entry.createdBy} on entry ${entry.id}`,
            );
            // Optionally render a placeholder or skip
            // return null;
          }
          // Ensure the fallback object includes all required fields for the User type
          // If creatorInfo exists, spread it and add the uid. Otherwise, use the fallback.
          const userProps = creatorInfo
            ? { ...creatorInfo, uid: entry.createdBy } // Add uid from entry.createdBy
            : {
                uid: entry.createdBy, // Use the creatorBy ID as the fallback uid
                displayName: "Unknown User",
                email: "", // Provide a default empty string or placeholder
                role: "viewer", // Provide a default role or handle appropriately
                // photoURL is optional
              };
          return entry?.createdBy ? (
            <Entry
              key={entry.id}
              journalId={journalId} // --- Pass journalId ---
              entryType={entryType} // --- Pass entryType ---
              entry={entry}
              user={userProps} // Pass creator info or fallback with required fields
              removeFn={removeFn}
              role={role} // Pass logged-in user's role
            />
          ) : null;
        })}
        <Loading />
      </div>
    </div>
  );
});

interface ChatBoxProps {
  journalId: string; // Changed journalId to journalId
  entryType: EntryType; // --- ADD entryType ---
  access: AccessMap;
  actionButton: React.ReactNode;
  filterList: DBentry[]; // Assuming filter list is of the same entryType
  hasFilter: boolean;
  // journalType is replaced by entryType
  removeFilterEntry: (entry: DBentry) => void;
}
// Create a component to render the chat box
export function ChatBox({
  journalId, // Use journalId
  entryType, // --- Get entryType ---
  access,
  actionButton,
  filterList,
  hasFilter,
  removeFilterEntry,
}: ChatBoxProps) {
  const [page, setPage] = useState(0);
  // --- Update useFetchEntries if needed ---
  const { loading, error, list, removeEntry } = useFetchEntries(
    journalId,
    entryType,
    page,
  ); // Pass entryType
  const { authUser } = useAuth();
  const viewerRole = (authUser && access[authUser.uid]?.role) || "viewer"; // Get viewer role safely

  const handleAtBottom = useCallback(() => {
    console.log("AtBottom Function called");
    setPage((prevPage) => prevPage + 1); // Use functional update
  }, []);

  // Render the chat box, if on mobile, the chat box will be full screen
  // if on desktop, the chat box will cover 2/3 of the screen
  return (
    <div className="h-full flex flex-col space-y-1 md:max-w-2xl w-full mx-auto">
      {" "}
      {/* Added mx-auto */}
      {authUser &&
        (hasFilter ? (
          <MessageList
            messages={filterList}
            journalId={journalId} // Pass journalId
            entryType={entryType} // Pass entryType
            access={access}
            BottomFn={handleAtBottom} // Pass directly
            loading={loading}
            role={viewerRole} // Pass viewer role
            removeFn={removeFilterEntry}
          />
        ) : (
          <MessageList
            messages={list}
            journalId={journalId} // Pass journalId
            entryType={entryType} // Pass entryType
            access={access}
            BottomFn={handleAtBottom} // Pass directly
            loading={loading}
            role={viewerRole} // Pass viewer role
            removeFn={removeEntry}
          />
        ))}
      <div
        id="action-btn"
        className="fixed bottom-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-content h-content"
      >
        {actionButton}
      </div>
    </div>
  );
}



# frontend/src/app/(auth)/journal/comp/useFetch.tsx
import { useState, useEffect, useCallback } from "react";
import { fetchOlderEntrys, useEntriesSubCol } from "@/lib/db_handler"; // These should now accept entryType
import { DBentry, DBentryMap } from "../../../../lib/custom_types"; // Types remain the same
import { EntryType } from "@/../../backend/functions/src/common/schemas/configmap"; // Import EntryType

const FETCH_LIMIT = 20; // Items per page

// --- Sorting Function ---
// This function seems okay, it prioritizes details.date if available,
// otherwise falls back to createdAt. Ensure the relevant 'date' field
// (e.g., details.date, details.time, details.start) exists for sorting.
// The sortField is defined in FE_ENTRY_CONFIG in db_handler.tsx now.
// Let's make this sort more robust based on potential date fields.
const sortEntries = (entries: DBentryMap): DBentry[] => {
  const getSortableDate = (entry: DBentry): number => {
    // Prioritize common date fields in details
    const detailsDate =
      entry.details?.date || entry.details?.time || entry.details?.start;
    if (detailsDate && typeof detailsDate.toMillis === "function") {
      return detailsDate.toMillis();
    }
    // Fallback to createdAt
    return entry.createdAt?.toMillis() ?? 0;
  };

  const sortedEntries = Object.values(entries)
    // Filter out entries without necessary data for sorting (optional but safer)
    .filter((entry) => entry && entry.createdAt)
    .sort((a, b) => {
      const dateA = getSortableDate(a);
      const dateB = getSortableDate(b);

      // Primary sort: Date (descending)
      if (dateA !== dateB) {
        return dateB - dateA; // Newer dates first
      }

      // Secondary sort: Creation time (descending) for same date
      const createdAtA = a.createdAt?.toMillis() ?? 0;
      const createdAtB = b.createdAt?.toMillis() ?? 0;
      return createdAtB - createdAtA; // Newer creation times first
    });
  return sortedEntries;
};

// --- Update Hook Signature ---
export function useFetchEntries(
  journalId: string,
  entryType: EntryType, // --- ADD entryType ---
  page: number = 0,
) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null); // Add error state
  const [list, setList] = useState<DBentry[]>([]); // Store sorted array
  const [hasMore, setHasMore] = useState(true); // Track if more pages exist
  const [combinedDocs, setCombinedDocs] = useState<DBentryMap>({}); // Store all fetched docs

  // --- Watch latest entries using the updated hook ---
  // useEntriesSubCol now takes entryType
  const headDocs = useEntriesSubCol(journalId, entryType);

  // --- Update combinedDocs whenever headDocs changes ---
  useEffect(() => {
    setCombinedDocs((prevDocs) => ({ ...prevDocs, ...headDocs }));
  }, [headDocs]);

  // --- Fetch Older Entries Function ---
  const fetchOlder = useCallback(async () => {
    // Prevent fetching if already loading or no more entries exist
    if (loading || !hasMore || list.length === 0) {
      if (!hasMore)
        console.log(`fetchOlder (${entryType}): No more entries to fetch.`);
      return;
    }

    console.log(`<<< Fetching older ${entryType} messages (Page ${page}) >>>`);
    setLoading(true);
    setError(null);

    const oldestEntryInList = list[list.length - 1]; // Get the actual oldest entry currently displayed

    try {
      // --- Call fetchOlderEntrys with entryType ---
      const fetchedMessages = await fetchOlderEntrys(
        journalId,
        entryType, // Pass entryType
        oldestEntryInList,
        FETCH_LIMIT,
      );

      const numFetched = Object.keys(fetchedMessages).length;
      console.log(`Fetched ${numFetched} older ${entryType} entries.`);

      if (numFetched === 0) {
        setHasMore(false); // No more entries found
      } else {
        // Merge fetched messages into combinedDocs
        setCombinedDocs((prevDocs) => ({ ...prevDocs, ...fetchedMessages }));
      }
    } catch (err: any) {
      console.error(`Error fetching older ${entryType} entries:`, err);
      setError(err.message || `Failed to load older ${entryType} entries.`);
      // Optionally stop trying to fetch more on error?
      // setHasMore(false);
    } finally {
      setLoading(false);
    }
  }, [journalId, entryType, page, list, loading, hasMore]); // Add dependencies

  // --- Effect to trigger fetchOlder when page changes ---
  useEffect(() => {
    // Only fetch older if page > 0 (initial load is handled by headDocs)
    if (page > 0) {
      console.log(
        `Paging changed for ${entryType} to ${page}, fetching older.`,
      );
      fetchOlder();
    }
    // Reset hasMore when switching journal/type (page goes back to 0)
    if (page === 0) {
      setHasMore(true);
    }
  }, [page, fetchOlder, entryType]); // Depend on page and fetchOlder

  // --- Effect to sort and update the final list ---
  useEffect(() => {
    console.log(
      `Sorting ${Object.keys(combinedDocs).length} combined ${entryType} docs`,
    );
    const sortedList = sortEntries(combinedDocs);
    setList(sortedList);
    // console.log(`Updated list for ${entryType}:`, sortedList.length, "items");
  }, [combinedDocs, entryType]); // Depend on combinedDocs

  // --- Remove Entry Function ---
  // This function removes an entry from the local state
  const removeEntry = useCallback(
    (entryToRemove: DBentry) => {
      console.log(
        `Removing entry ${entryToRemove.id} (${entryType}) from local state.`,
      );
      setCombinedDocs((prevDocs) => {
        const newDocs = { ...prevDocs };
        if (newDocs[entryToRemove.id]) {
          delete newDocs[entryToRemove.id];
          return newDocs;
        }
        return prevDocs; // No change if not found
      });
      // The list state will update automatically via the useEffect watching combinedDocs
    },
    [entryType],
  ); // Depend on entryType for logging consistency

  return { loading, error, list, hasMore, removeEntry }; // Return error and hasMore
}



# frontend/src/app/(auth)/journal/entry/page.tsx
// frontend/src/app/(auth)/journal/entry/page.tsx
"use client";
import { useEffect, useState, Suspense } from "react";
import { useSearchParams, useRouter } from "next/navigation";

import { QuoteDetails } from "@/app/(auth)/journal/journal-types/quote/addQuote";
// --- Store import removed ---
// import { useJournalStore } from "@/lib/store/journalStore";
import { Skeleton } from "@/components/ui/skeleton";
import Link from "next/link";
import { useJournalContext } from "@/context/JournalContext"; // Import the context hook
import { JOURNAL_TYPES } from "@/../../backend/functions/src/common/const";
import { BusinessDetailsType } from "@/../../backend/functions/src/common/schemas/JournalSchema";
import { EntryItf } from "@/../../backend/functions/src/common/common_types";
import {
  contactInfoSchemaType,
  allowedCurrencySchemaType,
} from "@/../../backend/functions/src/common/schemas/common_schemas";

// Default empty contact info (useful for initialization)
const initInfo: contactInfoSchemaType = {
  name: "",
  email: null,
  phone: null,
  address: { street: null, city: null, state: null, zipCode: null },
};

// Component to render content - needed because hooks like useSearchParams
// need to be called within a Suspense boundary in the main export default function
function EditQuoteEntryPageContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const journalId = searchParams.get("jid");
  const entryId = searchParams.get("eid") || undefined; // Keep entryId optional

  // --- Use context state ---
  const {
    journal, // The loaded journal object (or null/undefined)
    loading: isJournalLoading, // Loading state from the context
    error: contextJournalError, // Error state from the context
  } = useJournalContext();

  // State for this page's specific validation error
  const [validationError, setValidationError] = useState<string | null>(null);

  // --- Effect 1: Validate IDs from URL ---
  useEffect(() => {
    setValidationError(null); // Reset validation error on ID change

    if (!journalId) {
      setValidationError("Journal ID (jid) is missing in the URL.");
      // Optionally redirect: router.replace('/');
      return;
    }

    // Basic validation for entryId format if present
    if (entryId && !/^[a-zA-Z0-9-_]{15,}$/.test(entryId)) {
      // Adjusted regex (example)
      setValidationError("Invalid entry ID (eid) format in the URL.");
      return;
    }

    // If validation passes, clear error
    setValidationError(null);
  }, [journalId, entryId, router]); // Rerun validation if IDs change

  // --- Prepare Props for QuoteDetails ---
  let supplierInfo: contactInfoSchemaType = initInfo;
  let supplierLogo: string | null = null;
  let journalCurrency: allowedCurrencySchemaType | undefined;
  let journalInventoryCache: Record<string, EntryItf> = {};

  if (journal && journal.journalType === JOURNAL_TYPES.BUSINESS) {
    const details = journal.details as BusinessDetailsType | undefined;
    supplierInfo = details?.contactInfo || initInfo;
    supplierLogo = details?.logo || null;
    journalCurrency = details?.currency;
    // Access inventory cache - might need 'any' cast or type update
    journalInventoryCache = (journal as any)?.inventoryCache || {};
  }

  // Combine validation and context errors
  const combinedError = validationError || contextJournalError;

  // --- Render Logic ---

  // Handle validation errors or context errors
  if (combinedError) {
    return (
      <div className="p-4 text-center text-destructive">
        <p>Error: {combinedError}</p>
        <Link href="/" className="text-primary underline mt-4 inline-block">
          Go Home
        </Link>
      </div>
    );
  }

  // Show loading skeleton while context is loading the journal
  if (isJournalLoading) {
    return (
      <div className="p-4 space-y-4 max-w-4xl mx-auto">
        <Skeleton className="h-20 w-full" /> {/* Placeholder for header */}
        <Skeleton className="h-24 w-full" /> {/* Placeholder for customer */}
        <Skeleton className="h-40 w-full" /> {/* Placeholder for items */}
        <Skeleton className="h-20 w-full" /> {/* Placeholder for notes */}
      </div>
    );
  }

  // If loading is complete but journal wasn't found (also covered by error state)
  if (!journal) {
    return (
      <div className="p-4 text-center text-muted-foreground">
        <p>Journal not found or access denied.</p>
        <Link href="/" className="text-primary underline mt-4 inline-block">
          Go Home
        </Link>
      </div>
    );
  }

  // Check if it's the correct journal type
  if (journal.journalType !== JOURNAL_TYPES.BUSINESS) {
    return (
      <div className="p-4 text-center text-destructive">
        <p>Error: Quotes can only be added to Business journals.</p>
        <Link href="/" className="text-primary underline mt-4 inline-block">
          Go Home
        </Link>
      </div>
    );
  }

  // Check if currency is set (required for quotes)
  if (!journalCurrency) {
    return (
      <div className="p-4 text-center text-destructive">
        <p>Error: The Business journal is missing a currency setting.</p>
        {/* Optionally link to settings or home */}
        <Link
          href={`/journal?jid=${journalId}`}
          className="text-primary underline mt-4 inline-block"
        >
          Back to Journal
        </Link>
      </div>
    );
  }

  // --- Render QuoteDetails with Props ---
  return (
    <div className="w-full">
      <QuoteDetails
        journalId={journalId!} // Pass journalId (non-null asserted)
        entryId={entryId} // Pass optional entryId
        // Pass data derived from the context's journal object
        supplierInfo={supplierInfo}
        supplierLogo={supplierLogo}
        journalCurrency={journalCurrency}
        journalInventoryCache={journalInventoryCache}
      />
    </div>
  );
}

export default function EditQuoteEntryPage() {
  // Wrap the main content in Suspense because it uses useSearchParams
  return (
    <Suspense fallback={<div className="p-4">Loading...</div>}>
      <EditQuoteEntryPageContent />
    </Suspense>
  );
}



# frontend/src/app/(auth)/journal/journal-types/cash-flow/CashFlowEntry.tsx
// frontend/src/app/(auth)/journal/journal-types/cash-flow/CashFlowEntry.tsx
import React, { memo } from "react";
import { DBentry, User } from "../../../../../lib/custom_types"; // Adjusted path
import { formattedDate, formatCurrency } from "@/lib/utils"; // Adjusted path
import {
  EntryView,
  // EntryViewProps as BaseEntryViewProps, // Alias not strictly needed anymore
} from "../../comp/EntryView";
import { Label } from "@/components/ui/label";
import { EntryType } from "@/../../backend/functions/src/common/schemas/configmap";
// --- Store import removed ---
// import { useJournalStore } from "@/lib/store/journalStore";
import { MoveUpRight, MoveDownRight } from "lucide-react";

// --- Updated Props Interface ---
interface CashFlowEntryProps {
  journalId: string;
  entry: DBentry;
  entryType: EntryType; // Expect 'cashflow'
  user: User; // Creator
  role: string; // Viewer's role
  removeFn: (entry: DBentry) => void;
  // activeCurrency: string; // Accept currency as prop
}

// --- Main Component ---
export const CashFlowEntry = memo(function CashFlowEntry({
  journalId,
  entry,
  entryType,
  user,
  role,
  removeFn,
}: // activeCurrency, // Use prop
CashFlowEntryProps) {
  // --- Get currency from prop ---
  // const getActiveCurrency = useJournalStore(...); // Removed
  // const activeCurrency = getActiveCurrency(); // Removed

  // Basic validation
  if (
    !journalId ||
    !entry ||
    entryType !== "cashflow" ||
    !entry.details ||
    // !activeCurrency // Ensure currency is provided
    !entry.details.currency
  ) {
    console.error("Invalid props for CashFlowEntry:", {
      journalId,
      entry,
      entryType,
      // activeCurrency,
    });
    return (
      <div className="text-xs text-destructive pl-4">
        Error displaying entry. Missing data.
      </div>
    );
  }

  const { description, date, type, value } = entry.details;
  const isPaid = type === "paid";
  const amountColor = isPaid ? "text-destructive" : "text-green-600";
  const TypeIcon = isPaid ? MoveDownRight : MoveUpRight;

  return (
    <EntryView
      journalId={journalId}
      entry={entry}
      entryType={entryType}
      user={user}
      removeFn={removeFn}
      role={role}
      // journalId prop removed if EntryView standardized
    >
      {/* --- Specific Cash Flow Details --- */}
      <div className="flex items-center justify-between gap-4">
        <p className="text-base flex-1 mr-2 truncate" title={description}>
          {description || "No description"}
        </p>
        <div className="flex items-center gap-2 flex-shrink-0">
          <span className={`text-lg font-semibold ${amountColor}`}>
            {/* Format currency using prop */}
            {formatCurrency(value || 0, entry.details.currency)}
          </span>
        </div>
      </div>
      <div className="flex items-center justify-between text-xs text-muted-foreground mt-1">
        <span>
          {`${user?.displayName || user?.email || "User"} | ${formattedDate(
            date || entry.createdAt,
          )}`}
        </span>
        <span className="flex items-center gap-1">
          <TypeIcon
            className={`h-3 w-3 ${
              isPaid ? "text-destructive/80" : "text-green-600/80"
            }`}
          />
          {type?.charAt(0).toUpperCase() + type?.slice(1) || "N/A"}
        </span>
      </div>
    </EntryView>
  );
});



# frontend/src/app/(auth)/journal/journal-types/cash-flow/add-cf-entry.tsx
// frontend/src/app/(auth)/journal/journal-types/cash-flow/add-cf-entry.tsx
"use client";
import { useState, useEffect } from "react";
import { CalendarIcon } from "@radix-ui/react-icons";
import { format } from "date-fns";
import * as z from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { cn } from "@/lib/utils";

import { Checkbox } from "@/components/ui/checkbox";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Calendar } from "@/components/ui/calendar";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Textarea } from "@/components/ui/textarea";
import { Separator } from "@/components/ui/separator";
import { Send, Download, Upload, MessageSquarePlus } from "lucide-react";
import { httpsCallable } from "firebase/functions";
import { functions } from "@/lib/auth_handler";
import {
  cashFlowEntryDetailsSchema,
  CashFlowEntryDetailsType,
} from "@/../../backend/functions/src/common/schemas/CashflowSchema";
import { EntryType } from "@/../../backend/functions/src/common/schemas/configmap";
import { useToast } from "@/hooks/use-toast";

import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogFooter,
  DialogTitle,
  DialogClose,
} from "@/components/ui/dialog";
import { NumericInput } from "@/components/InputUnit";
import { currencyToSymbol } from "@/lib/utils";
import { useJournalContext } from "@/context/JournalContext";

const addLogFn = httpsCallable(functions, "addLogFn", {
  limitedUseAppCheckTokens: true,
});

const cashFlowFormSchema = cashFlowEntryDetailsSchema;
type CashFlowFormValues = z.infer<typeof cashFlowFormSchema>;

export function AddLogEntryForm({
  journalId,
}: {
  journalId: string | undefined;
}) {
  const [pending, setPending] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const [calendarOpen, setCalendarOpen] = useState(false);
  const { toast } = useToast();
  const { journal, loading, error } = useJournalContext();

  const activeCurrency =
    journal?.details && "currency" in journal.details
      ? journal.details.currency
      : undefined;

  const form = useForm<CashFlowFormValues>({
    resolver: zodResolver(cashFlowFormSchema),
    defaultValues: {
      description: "",
      date: new Date(),
      type: undefined,
      value: 0,
      currency: activeCurrency || undefined,
    },
  });

  useEffect(() => {
    if (activeCurrency) {
      form.setValue("currency", activeCurrency, { shouldValidate: true });
    }
  }, [activeCurrency, form.setValue]);

  const onSubmit = async (data: CashFlowFormValues) => {
    if (!journalId) {
      toast({
        title: "Error",
        description: "Journal ID is missing.",
        variant: "destructive",
      });
      return;
    }

    if (!data.currency) {
      toast({
        title: "Error",
        description: "Currency information is missing from the journal.",
        variant: "destructive",
      });
      return;
    }

    console.log(`Sending cashflow data:`, data);
    setPending(true);

    try {
      const payload = {
        journalId: journalId,
        entryType: "cashflow", //as EntryType,
        name: data.description.substring(0, 50) || "Cash Flow Entry",
        details: data,
      };

      console.log("Payload for addLogFn:", payload);
      const result = await addLogFn(payload);
      console.log("addLogFn result:", result);

      toast({
        title: "Entry Added",
        description: `Cash flow entry "${payload.name}" saved.`,
      });

      form.reset({
        description: "",
        date: new Date(),
        type: undefined,
        value: 0,
        currency: activeCurrency || undefined,
      });
      setIsOpen(false);
    } catch (error: any) {
      console.error("Error adding cash flow entry:", error);
      toast({
        title: "Error Adding Entry",
        description: error.message || "Failed to save cash flow entry.",
        variant: "destructive",
      });
    } finally {
      setPending(false);
    }
  };

  const handleOpenChange = (nextOpen: boolean) => {
    if (nextOpen === false) {
      form.reset({
        description: "",
        date: new Date(),
        type: undefined,
        value: 0,
        currency: activeCurrency || undefined,
      });
    }
    setIsOpen(nextOpen);
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>
        <Button
          variant="brutalist"
          className="text-sm flex items-center"
          disabled={!journalId}
        >
          <MessageSquarePlus className="pr-2" />
          Add Entry
        </Button>
      </DialogTrigger>

      <DialogContent>
        <DialogTitle>Add Cash Flow Entry</DialogTitle>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(onSubmit)}
            className="space-y-4 px-4"
          >
            <div className="grid grid-cols-3 gap-4 items-end">
              <FormField
                control={form.control}
                name="value"
                render={({ field }) => (
                  <FormItem className="col-span-1">
                    <FormLabel>Amount</FormLabel>
                    <FormControl>
                      <NumericInput
                        prefix={currencyToSymbol(activeCurrency || "")}
                        placeholder="0.00"
                        className="peer text-center"
                        value={field.value.toString()}
                        onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                          const value = parseFloat(e.target.value);
                          field.onChange(
                            isNaN(value) || value < 0 ? 0 : value,
                          );
                        }}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="type"
                render={({ field }) => (
                  <FormItem className="col-span-2">
                    <FormLabel>Type</FormLabel>
                    <FormControl>
                      <RadioGroup
                        onValueChange={field.onChange}
                        value={field.value}
                        className="flex gap-2 pt-2"
                      >
                        <div className="flex items-center space-x-2 border p-2 rounded-md has-[[data-state=checked]]:border-primary has-[[data-state=checked]]:bg-secondary">
                          <RadioGroupItem value="received" id="received" />
                          <Label
                            htmlFor="received"
                            className="flex items-center cursor-pointer"
                          >
                            <Download className="w-4 h-4 mr-1" /> Received
                          </Label>
                        </div>
                        <div className="flex items-center space-x-2 border p-2 rounded-md has-[[data-state=checked]]:border-primary has-[[data-state=checked]]:bg-secondary">
                          <RadioGroupItem value="paid" id="paid" />
                          <Label
                            htmlFor="paid"
                            className="flex items-center cursor-pointer"
                          >
                            <Upload className="w-4 h-4 mr-1" /> Paid
                          </Label>
                        </div>
                      </RadioGroup>
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <FormField
              control={form.control}
              name="date"
              render={({ field }) => (
                <FormItem className="flex flex-col pt-2">
                  <FormLabel>Date</FormLabel>
                  <div className="flex items-center justify-between">
                    <Popover
                      modal
                      open={calendarOpen}
                      onOpenChange={setCalendarOpen}
                    >
                      <PopoverTrigger asChild>
                        <FormControl>
                          <Button
                            variant={"outline"}
                            className={cn(
                              "w-[200px] justify-start text-left font-normal",
                              !field.value && "text-muted-foreground",
                            )}
                          >
                            <CalendarIcon className="mr-2 h-4 w-4" />
                            {field.value ? (
                              format(field.value, "PPP")
                            ) : (
                              <span>Pick a date</span>
                            )}
                          </Button>
                        </FormControl>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar
                          mode="single"
                          selected={field.value || undefined}
                          onSelect={(date) => {
                            field.onChange(date || new Date());
                            setCalendarOpen(false);
                          }}
                          disabled={(date) =>
                            date > new Date() || date < new Date("1900-01-01")
                          }
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                    <div className="flex items-center text-sm">
                      <Separator orientation="vertical" className="mx-2 h-4" />
                      <Label
                        htmlFor="today-checkbox"
                        className="mr-2 text-muted-foreground"
                      >
                        Today
                      </Label>
                      <Checkbox
                        id="today-checkbox"
                        checked={
                          field.value?.toDateString() ===
                          new Date().toDateString()
                        }
                        onCheckedChange={(checked) => {
                          field.onChange(checked ? new Date() : null);
                        }}
                        className="ml-1"
                      />
                    </div>
                  </div>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea
                      placeholder="Add a short description (e.g., Office Supplies)"
                      className="resize-none"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <DialogFooter className="w-full pt-4 flex justify-between">
              <DialogClose asChild>
                <Button type="button" variant="secondary">
                  Cancel
                </Button>
              </DialogClose>
              <Button
                type="submit"
                variant="brutalist"
                disabled={pending || !activeCurrency}
                onClick={() => {
                  if (form.formState.isValid) {
                    console.log("Form is valid, submitting...");
                  } else {
                    console.log("Form is invalid, not submitting.");
                    console.log("Form errors:", form.formState.errors);
                  }
                }}
              >
                <Send className="h-4 w-4 mr-2" />
                Save Entry
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}



# frontend/src/app/(auth)/journal/journal-types/config.tsx
import { Coins, Package, List, FileText, PencilRuler } from "lucide-react";
import { CashFlowEntry } from "./cash-flow/CashFlowEntry";
import { InventoryItemEntry } from "./inventory/InventoryItemEntry";
import { AddInventoryEntryForm } from "./inventory/add-inventory-entry";
import { AddLogEntryForm } from "./cash-flow/add-cf-entry";
import React from "react";
import { AddNewQuoteBtn } from "./quote/addQuote";
import { QuoteEntry } from "./quote/QuoteEntry";
import { DBentry } from "@/lib/custom_types";
import { EntryViewProps } from "../comp/EntryView";

const JOURNAL_CONFIG: {
  [key: string]: {
    icon: React.ReactNode;
    title: string;
    entryComponent: React.ComponentType<EntryViewProps<DBentry>> | null;
    addEntryForm?: React.ComponentType<{ journalId: string }> | null;
  };
} = {
  cashflow: {
    icon: <Coins className="h-4 w-4" />,
    title: "Simple Cashflow",
    entryComponent: CashFlowEntry,
    addEntryForm: AddLogEntryForm,
  },
  inventory: {
    icon: <Package className="h-4 w-4" />,
    title: "Inventory",
    entryComponent: InventoryItemEntry,
    addEntryForm: AddInventoryEntryForm,
  },
  quote: {
    icon: <PencilRuler className="h-4 w-4" />,
    title: "Quotes",
    entryComponent: QuoteEntry,
    addEntryForm: AddNewQuoteBtn,
  },
  group: {
    icon: <FileText className="h-4 w-4" />,
    title: "Group",
    entryComponent: null,
    addEntryForm: null,
  },
};

export const getJournalIcon = (type: string) => {
  return JOURNAL_CONFIG[type as keyof typeof JOURNAL_CONFIG]?.icon ?? null;
};

export const getEntryComponent = (type: string) => {
  return (
    JOURNAL_CONFIG[type as keyof typeof JOURNAL_CONFIG]?.entryComponent ?? null
  );
};

export const getJournalOptions = () => {
  return Object.entries(JOURNAL_CONFIG).map(([key, value]) => ({
    value: key,
    label: value.title,
    icon: value.icon,
  }));
};

export const getJournalTitles = () => {
  return Object.entries(JOURNAL_CONFIG).map(([key, value]) => value.title);
};

export const getAddEntryForm = (type: string) => {
  const addEntryComponent =
    JOURNAL_CONFIG[type as keyof typeof JOURNAL_CONFIG]?.addEntryForm ?? null;
  return addEntryComponent;
};



# frontend/src/app/(auth)/journal/journal-types/create-new-journal.tsx
// frontend/src/app/(auth)/journal/journal-types/create-new-journal.tsx
import { useState, useEffect } from "react"; // Added useEffect
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormMessage,
} from "@/components/ui/form";
import * as z from "zod";
import { zodResolver } from "@hookform/resolvers/zod";

import { useForm } from "react-hook-form";

import { Input } from "@/components/ui/input";
import { FilePlus2, Building2 } from "lucide-react"; // Removed Plus import
import { httpsCallable } from "firebase/functions";
import { functions, useAuth } from "@/lib/auth_handler";
import {
  allowedCurrencySchema,
  contactInfoSchema,
} from "@/../../backend/functions/src/common/schemas/common_schemas"; // Use common_schemas for currency/contact
import {
  // JournalGroupSchema, // Removed
  businessDetailsSchema, // Import specific details schema
} from "@/../../backend/functions/src/common/schemas/JournalSchema"; // Update path if needed
import { JOURNAL_TYPES } from "@/../../backend/functions/src/common/const"; // Import JOURNAL_TYPES
import { LogoUpload } from "@/components/LogoUpload";
import { useRouter } from "next/navigation";
import { useToast } from "@/hooks/use-toast"; // Import useToast

// --- Define Frontend Schema for the Form ---
// This schema matches the structure needed for the 'business' journal type details
const BusinessFormSchema = z.object({
  title: z.string().min(3, "Business name must be at least 3 characters"), // Use title for business name
  details: businessDetailsSchema, // Use the specific details schema
});

type FormValues = z.infer<typeof BusinessFormSchema>;

const getCurrencyOptions = () => {
  return allowedCurrencySchema.options.map((currency) => ({
    value: currency,
    label: currency,
  }));
};

// --- Updated Response Type ---
interface CreateJournalResponse {
  journalId: string; // Expecting journalId now
}

interface CreateNewJournalProps {
  isEdit?: boolean;
  initialData?: FormValues; // Use the new FormValues type
  journalId?: string;
  onClose?: () => void;
  trigger?: React.ReactNode;
}

export function CreateNewJournal({
  isEdit = false,
  initialData, // This needs careful mapping if the source structure differs
  journalId,
  onClose,
  trigger,
}: CreateNewJournalProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [pending, setPending] = useState(false);
  const { authUser } = useAuth();
  const router = useRouter();
  const { toast } = useToast(); // Initialize toast

  // --- Initialize Form ---
  // Setup default values, mapping from potentially different initialData structure if needed
  const defaultValues: FormValues = {
    title: initialData?.title || "",
    details: {
      currency: initialData?.details.currency || "USD",
      contactInfo: initialData?.details.contactInfo || {
        name: initialData?.title || "", // Use business name as default for contact name
        email: null,
        phone: null,
        address: { street: null, city: null, state: null, zipCode: null },
      },
      logo: initialData?.details.logo || null,
    },
  };

  const form = useForm<FormValues>({
    resolver: zodResolver(BusinessFormSchema),
    defaultValues: defaultValues,
  });

  // Effect to reset form when initialData changes (for edit mode)
  useEffect(() => {
    if (isEdit && initialData) {
      form.reset({
        title: initialData.title,
        details: {
          currency: initialData.details.currency,
          contactInfo: initialData.details.contactInfo,
          logo: initialData.details.logo,
        },
      });
    } else if (!isEdit) {
      form.reset(defaultValues); // Reset to defaults when switching to create mode
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialData, isEdit, form.reset]);

  // Add this effect to sync the business name and contact name
  useEffect(() => {
    const subscription = form.watch((value, { name }) => {
      if (name === "title") {
        // When title changes, update contact name
        form.setValue("details.contactInfo.name", value.title || "");
      }
    });

    return () => subscription.unsubscribe();
  }, [form]);

  const onSubmit = async (data: FormValues) => {
    setPending(true);

    // --- Construct Payload for Backend ---
    // For creation, we need journalType and full details
    // For update, we only send changed fields and the ID
    let payload: any = {
      title: data.title, // Use the title from the form
      details: data.details, // Send the whole details object
    };

    if (isEdit && journalId) {
      payload.id = journalId;
      // Optionally: Only send changed fields for updates?
      // This requires comparing 'data' with 'initialData'
    } else {
      // Add journalType for creation
      payload.journalType = JOURNAL_TYPES.BUSINESS;
    }

    console.log("Payload:", payload);

    // --- Call Correct Backend Function ---
    const functionName = isEdit ? "updateJournal" : "createJournal";
    const callable = httpsCallable(functions, functionName, {
      limitedUseAppCheckTokens: true,
    });

    try {
      const result = await callable(payload);
      console.log(`${functionName} successful:`, result.data);

      toast({
        // Add toast notification
        title: isEdit ? "Business Updated" : "Business Created",
        description: `Your business "${data.title}" has been saved successfully.`,
      });

      form.reset(defaultValues); // Reset form to defaults after success
      setIsOpen(false);
      if (onClose) onClose();

      // --- Redirect on Creation ---
      if (!isEdit && result.data) {
        const response = result.data as CreateJournalResponse;
        router.push(`/journal?jid=${response.journalId}`); // Use the returned journalId
      } else if (isEdit) {
        // Optional: Force refresh or update local state if needed after edit
        router.refresh(); // Simple way to refresh data on the current page
      }
    } catch (error: any) {
      console.error(`${functionName} failed:`, error);
      toast({
        // Add error toast
        title: `Error ${isEdit ? "Updating" : "Creating"} Business`,
        description: error.message || "An unexpected error occurred.",
        variant: "destructive",
      });
    } finally {
      setPending(false);
    }
  };

  const handleOpenChange = (nextOpen: boolean) => {
    if (nextOpen === false && !isEdit) {
      // Only reset fully if creating
      form.reset(defaultValues);
    } else if (nextOpen === true && isEdit && initialData) {
      // Reset to initialData when opening edit
      form.reset({
        title: initialData.title,
        details: {
          currency: initialData.details.currency,
          contactInfo: initialData.details.contactInfo,
          logo: initialData.details.logo,
        },
      });
    }
    setIsOpen(nextOpen);
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>
        {trigger || (
          <div className="fixed bottom-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-content h-content print-hide">
            <Button variant="brutalist" className="text-sm flex items-center">
              <Building2 className="pr-2" />
              New Business
            </Button>
          </div>
        )}
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>
            {isEdit ? "Edit Business" : "New Business"}
          </DialogTitle>
          <DialogDescription>
            {isEdit
              ? "Update your business information."
              : "Create a new business journal to manage quotes, inventory, and cash flow."}
          </DialogDescription>
        </DialogHeader>
        <Form {...form}>
          {/* --- Use form.handleSubmit --- */}
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            {/* --- Business Name (Title) --- */}
            <FormField
              control={form.control}
              name="title"
              render={({ field }) => (
                <FormItem>
                  <div className="grid grid-cols-4 items-center gap-4">
                    <FormDescription className="text-start col-span-1">
                      Name
                    </FormDescription>
                    <FormControl className="col-span-3">
                      <Input placeholder="Business Name" {...field} />
                    </FormControl>
                  </div>
                  <FormMessage className="col-start-2 col-span-3" />{" "}
                  {/* Adjust message position */}
                </FormItem>
              )}
            />

            {/* --- Logo --- */}
            <FormField
              control={form.control}
              name="details.logo"
              render={({ field }) => (
                <FormItem>
                  <div className="grid grid-cols-4 items-center gap-4">
                    <FormDescription className="text-start">
                      Logo
                    </FormDescription>
                    <div className="col-span-3">
                      <FormControl>
                        {/* Pass field.value and field.onChange */}
                        <LogoUpload
                          logo={field.value}
                          setLogo={(newLogo) => field.onChange(newLogo)}
                        />
                      </FormControl>
                    </div>
                  </div>
                  <FormMessage className="col-start-2 col-span-3" />
                </FormItem>
              )}
            />

            {/* --- Currency --- */}
            <FormField
              control={form.control}
              name="details.currency"
              render={({ field }) => (
                <FormItem>
                  <div className="grid grid-cols-4 items-center gap-4">
                    <FormDescription className="text-start">
                      Currency
                    </FormDescription>
                    <FormControl className="col-span-3">
                      <select
                        className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm"
                        value={field.value} // Use field.value
                        onChange={field.onChange} // Use field.onChange
                        required
                      >
                        {getCurrencyOptions().map((option) => (
                          <option key={option.value} value={option.value}>
                            {option.label}
                          </option>
                        ))}
                      </select>
                    </FormControl>
                  </div>
                  <FormMessage className="col-start-2 col-span-3" />
                </FormItem>
              )}
            />

            {/* --- Contact Information Fields --- */}
            <div className="space-y-4 border-t pt-4">
              <h3 className="font-medium text-sm col-span-4 mb-2">
                Contact Information
              </h3>
              {/* Email */}
              <FormField
                control={form.control}
                name="details.contactInfo.email"
                render={({ field }) => (
                  <FormItem>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <FormDescription className="text-start">
                        Email
                      </FormDescription>
                      <FormControl className="col-span-3">
                        <Input
                          placeholder="Email address"
                          type="email"
                          {...field}
                          value={field.value || ""}
                        />
                      </FormControl>
                    </div>
                    <FormMessage className="col-start-2 col-span-3" />
                  </FormItem>
                )}
              />
              {/* Phone */}
              <FormField
                control={form.control}
                name="details.contactInfo.phone"
                render={({ field }) => (
                  <FormItem>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <FormDescription className="text-start">
                        Phone
                      </FormDescription>
                      <FormControl className="col-span-3">
                        <Input
                          placeholder="Phone number"
                          {...field}
                          value={field.value || ""}
                        />
                      </FormControl>
                    </div>
                    <FormMessage className="col-start-2 col-span-3" />
                  </FormItem>
                )}
              />
              {/* Street */}
              <FormField
                control={form.control}
                name="details.contactInfo.address.street"
                render={({ field }) => (
                  <FormItem>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <FormDescription className="text-start">
                        Street
                      </FormDescription>
                      <FormControl className="col-span-3">
                        <Input
                          placeholder="Street address"
                          {...field}
                          value={field.value || ""}
                        />
                      </FormControl>
                    </div>
                    <FormMessage className="col-start-2 col-span-3" />
                  </FormItem>
                )}
              />
              {/* City, State, Zip */}
              <div className="grid grid-cols-3 gap-4">
                <FormField
                  control={form.control}
                  name="details.contactInfo.address.city"
                  render={({ field }) => (
                    <FormItem>
                      <FormDescription className="text-start">
                        City
                      </FormDescription>
                      <FormControl>
                        <Input {...field} value={field.value || ""} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <FormField
                  control={form.control}
                  name="details.contactInfo.address.state"
                  render={({ field }) => (
                    <FormItem>
                      <FormDescription className="text-start">
                        State
                      </FormDescription>
                      <FormControl>
                        <Input {...field} value={field.value || ""} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <FormField
                  control={form.control}
                  name="details.contactInfo.address.zipCode"
                  render={({ field }) => (
                    <FormItem>
                      <FormDescription className="text-start">
                        ZIP
                      </FormDescription>
                      <FormControl>
                        <Input
                          placeholder="ZIP Code"
                          {...field}
                          value={field.value || ""}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
            </div>

            <DialogFooter>
              <Button type="submit" disabled={pending} variant={"brutalist"}>
                <FilePlus2 className="pr-2" />
                {pending
                  ? isEdit
                    ? "Saving..."
                    : "Creating..."
                  : isEdit
                  ? "Save Changes"
                  : "Create Business"}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}



# frontend/src/app/(auth)/journal/journal-types/inventory/InventoryItemEntry.tsx
import React from "react";
import { EntryView, EntryViewProps } from "../../comp/EntryView";
import { DBentry, User } from "@/lib/custom_types";
import { formattedDate, formatCurrency } from "@/lib/utils";
import { Hammer, Package } from "lucide-react";
// No schema imports needed here if structure is assumed correct via props
import { EntryType } from "@/../../backend/functions/src/common/schemas/configmap";

// --- Update Props Interface (Align with EntryViewProps) ---
// This interface defines what InventoryItemEntry *expects* to receive.
interface InventoryItemEntryProps {
  journalId: string;
  entry: DBentry; // Should contain details adhering to materialItemSchema
  entryType: EntryType; // Will be 'inventory'
  user: User; // Creator info
  role: string; // Viewer's role
  removeFn: (entry: DBentry) => void;
}

// --- Details Component (Remains mostly the same) ---
// Renders the specific details of the inventory item
const InventoryItemDetails = ({ entry }: { entry: DBentry }) => {
  // Assume entry.details matches materialItemSchema structure
  const { name } = entry; // Use top-level name if available (added in form refactor)
  const { description, unitPrice, labor, dimensions, currency } =
    entry.details || {}; // Destructure safely

  // Handle cases where details might be missing (though schema validation should prevent this)
  if (!dimensions || unitPrice === undefined || currency === undefined) {
    console.error("Inventory item details incomplete:", entry);
    return (
      <div className="text-red-500 text-xs">Error: Incomplete item data.</div>
    );
  }

  // Format currency (using util function)
  const displayPrice = formatCurrency(unitPrice, currency);
  const displayUnit = dimensions.unitLabel || "unit"; // Fallback if unitLabel missing

  // Function to get the appropriate material rate display
  const getLaborRateDisplay = (
    laborType: string,
    rate: number,
    itemCurrency: string, // Renamed to avoid conflict
    itemDimensions: { unitLabel?: string },
  ): string => {
    const formattedRate = formatCurrency(rate, itemCurrency);
    const laborUnit = itemDimensions.unitLabel || "unit";

    switch (laborType) {
      case "percentage":
        return `${rate}%`; // Percentage doesn't need currency symbol
      case "fixed":
        return `fixed at ${formattedRate}`;
      case "quantity":
        // Use specific unit label from dimensions if available
        return `${formattedRate} per ${laborUnit}`;
      default:
        return `${rate}`; // Fallback
    }
  };

  return (
    <div className="w-full border-0">
      <div className="flex justify-between items-start gap-2">
        {" "}
        {/* Added gap */}
        {/* Left side: Name and description */}
        <div className="flex-1 min-w-0">
          {" "}
          {/* Allow shrinking/wrapping */}
          <div className="flex flex-wrap items-center gap-x-3 gap-y-1">
            {" "}
            {/* Allow wrapping */}
            <span className="flex items-center gap-1">
              <Package className="h-4 w-4 text-muted-foreground" />{" "}
              {/* Icon */}
              <p className="text-base font-medium truncate" title={name}>
                {name || "Unnamed Item"}
              </p>
            </span>
            {/* <p className="text-xs text-muted-foreground">
               Added: {formattedDate(entry.createdAt)} {/* Use createdAt */}
            {/* </p> */}
          </div>
          {description && ( // Only show description if it exists
            <p className="text-sm text-muted-foreground mt-1">{description}</p>
          )}
        </div>
        {/* Right side: Price */}
        <div className="flex flex-col items-end flex-shrink-0">
          {" "}
          {/* Prevent shrinking */}
          <p className="font-semibold">{displayPrice}</p>
          <p className="text-xs text-muted-foreground">per {displayUnit}</p>
        </div>
      </div>

      {/* Bottom: Labor info */}
      {labor && (
        <div className="flex flex-row justify-start items-center gap-2 mt-2 text-xs text-muted-foreground border border-dashed rounded px-2 py-1 w-fit">
          {" "}
          {/* Fit content */}
          <Hammer className="h-3 w-3" /> {/* Smaller icon */}
          <span>
            {"Labor: "}
            {getLaborRateDisplay(
              labor.laborType,
              labor.laborRate,
              currency, // Pass currency
              dimensions, // Pass dimensions
            )}
          </span>
          {/* Optional: Show labor description if needed */}
          {/* {labor.description && <span className="italic">({labor.description})</span>} */}
        </div>
      )}
    </div>
  );
};

// --- Main Component ---
export const InventoryItemEntry = React.memo(function InventoryItemEntry({
  journalId,
  entry,
  entryType,
  user, // Creator info
  role, // Viewer's role
  removeFn,
}: InventoryItemEntryProps) {
  // Basic validation (already checked by parent, but good practice)
  if (!journalId || !entry || entryType !== "inventory") return null;

  return (
    // Pass all necessary props *up* to EntryView
    <EntryView
      journalId={journalId}
      entry={entry}
      entryType={entryType} // Pass entryType
      user={user} // Pass creator info
      role={role} // Pass viewer role
      removeFn={removeFn}
    >
      {/* Render the specific details as children */}
      <InventoryItemDetails entry={entry} />
    </EntryView>
  );
});



# frontend/src/app/(auth)/journal/journal-types/inventory/add-inventory-entry.tsx
// frontend/src/app/(auth)/journal/journal-types/inventory/add-inventory-entry.tsx
"use client";
import { useEffect, useState, useMemo, useId } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { httpsCallable } from "firebase/functions";
import * as z from "zod";

import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogTitle,
  DialogFooter,
  DialogClose,
} from "@/components/ui/dialog";
import { PackagePlus } from "lucide-react";
import { materialItemSchema } from "@/../../backend/functions/src/common/schemas/InventorySchema";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
// --- Store import removed ---
// import { useJournalStore } from "@/lib/store/journalStore";
import { Label } from "@/components/ui/label";
import { functions } from "@/lib/auth_handler";
import { EntryType } from "@/../../backend/functions/src/common/schemas/configmap"; // Import EntryType
import { useJournalContext } from "@/context/JournalContext"; // Import the context hook
import { NumericInput } from "@/components/InputUnit";
import { currencyToSymbol } from "@/lib/utils";

// Backend function call (no change)
const addLogFn = httpsCallable(functions, "addLogFn", {
  limitedUseAppCheckTokens: true,
});

// Schema (no change)
const inventoryFormSchema = z
  .object({
    name: z
      .string()
      .min(3, { message: "Name must be at least 3 characters." }),
    details: materialItemSchema,
  })
  .strict();

type InventoryFormValues = z.infer<typeof inventoryFormSchema>;

const dimensionOptions = [
  { id: "unit", label: "Unit", value: { type: "unit", unitLabel: "unit" } },
  { id: "m2", label: "m²", value: { type: "area", unitLabel: "m²" } },
  { id: "ft2", label: "ft²", value: { type: "area", unitLabel: "ft²" } },
];

// --- Updated Props Interface ---
interface AddInventoryEntryFormProps {
  journalId: string; // This is the journalId
  // d: allowedCurrencySchemaType | null; // Accept currency as prop
}

// --- Main Component (Uses Props) ---
export function AddInventoryEntryForm({
  journalId, // journalId
}: // activeCurrency, // Use prop
AddInventoryEntryFormProps) {
  const [pending, setPending] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const { journal, loading, error } = useJournalContext(); // Get journal from context
  const { toast } = useToast();
  const id = useId(); // For radio group

  // Safely access currency by checking if 'currency' property exists in details
  // Moved hook calls before conditional returns
  const activeCurrency = useMemo(() => {
    return journal?.details && "currency" in journal.details
      ? journal.details.currency
      : null;
  }, [journal]); // Depend only on journal for activeCurrency calculation

  // --- Default Values (depend on journal context) ---
  // Moved hook call before conditional returns
  const defaultValues: InventoryFormValues = useMemo(
    () => ({
      name: "",
      details: {
        description: "",
        unitPrice: 0,
        dimensions: { type: "unit" as "unit", unitLabel: "unit" as "unit" },
        labor: null,
        currency: activeCurrency || null, // Use journal context for default
      },
    }),
    [activeCurrency], // Depend on activeCurrency derived from journal
  );

  // Moved hook call before conditional returns
  const form = useForm<InventoryFormValues>({
    resolver: zodResolver(inventoryFormSchema),
    defaultValues,
  });

  // --- Sync form currency if journal context changes after mount ---
  // Moved hook call before conditional returns
  useEffect(() => {
    if (
      activeCurrency &&
      form.getValues("details.currency") !== activeCurrency
    ) {
      form.setValue("details.currency", activeCurrency);
    }
    // If prop becomes null, should we clear the form currency? Depends on desired behavior.
    // else if (!activeCurrency) {
    //   form.setValue("details.currency", null);
    // }
  }, [activeCurrency, form]);

  // Conditional returns now happen *after* all hooks have been called
  if (loading) return null; // Loading state
  if (error) {
    console.error("Error loading journal:", error);
    // Display the error message correctly, whether it's a string or an Error object
    return <div>Error loading journal: {error}</div>;
  }

  if (!journal) {
    console.error("No journal found in context.");
    return <div>No journal found.</div>;
  }

  const labor = form.watch("details.labor");

  const onSubmit = async (data: InventoryFormValues) => {
    if (!activeCurrency) {
      toast({
        title: "Missing Currency",
        description: "Cannot add item. Business currency is not set.",
        variant: "destructive",
      });
      return;
    }
    setPending(true);
    try {
      const payload = {
        journalId: journalId,
        entryType: "inventory" as EntryType,
        name: data.name,
        details: {
          ...data.details,
          currency: activeCurrency, // Ensure currency from prop is sent
        },
      };

      console.log("Sending payload to addLogFn:", payload);
      const result = await addLogFn(payload);
      console.log("addLogFn result:", result);

      toast({
        title: "Inventory Item Added",
        description: `"${data.name}" has been added to your inventory.`,
      });

      form.reset(defaultValues);
      setIsOpen(false);
    } catch (error: any) {
      console.error("Error adding inventory entry:", error);
      toast({
        title: "Error Adding Item",
        description: error.message || "Failed to add inventory item.",
        variant: "destructive",
      });
    } finally {
      setPending(false);
    }
  };

  const handleOpenChange = (nextOpen: boolean) => {
    if (nextOpen === false) {
      form.reset(defaultValues);
    }
    setIsOpen(nextOpen);
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>
        <Button
          variant="brutalist"
          className="text-sm flex items-center"
          // Disable if journalId OR activeCurrency is missing
          disabled={!journalId || !activeCurrency}
        >
          <PackagePlus className="pr-2" />
          Add Item
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogTitle>Add Inventory Item</DialogTitle>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            {/* --- Name Field --- */}
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Item Name</FormLabel>
                  <FormControl>
                    <Input placeholder="e.g., Premium Widget" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* --- Details: Description --- */}
            <FormField
              control={form.control}
              name="details.description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description (Optional)</FormLabel>
                  <FormControl>
                    <Input placeholder="Additional details..." {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* --- Details: Unit Price --- */}
            <FormField
              control={form.control}
              name="details.unitPrice"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Unit Price</FormLabel>
                  <FormControl>
                    <NumericInput
                      // Use activeCurrency prop for symbol
                      prefix={currencyToSymbol(activeCurrency || "")}
                      placeholder="0.00"
                      className="peer text-center"
                      value={field.value.toString()}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                        const value = parseFloat(e.target.value);
                        field.onChange(isNaN(value) || value < 0 ? 0 : value);
                      }}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* --- Details: Dimensions Type --- */}
            <FormField
              control={form.control}
              name="details.dimensions"
              render={({ field }) => (
                <FormItem className="space-y-3">
                  <FormLabel>Dimensions</FormLabel>
                  <FormControl>
                    <RadioGroup
                      onValueChange={(valueString) => {
                        try {
                          const selectedOption = dimensionOptions.find(
                            (opt) => JSON.stringify(opt.value) === valueString,
                          );
                          if (selectedOption) {
                            field.onChange(selectedOption.value);
                          }
                        } catch (e) {
                          console.error("Error parsing dimension value", e);
                        }
                      }}
                      defaultValue={JSON.stringify(field.value)}
                      className="flex flex-wrap gap-2"
                    >
                      {dimensionOptions.map((option) => (
                        <div
                          key={option.id}
                          className="flex items-center space-x-2 border p-2 rounded-md has-[[data-state=checked]]:border-primary has-[[data-state=checked]]:bg-secondary/50"
                        >
                          <RadioGroupItem
                            value={JSON.stringify(option.value)}
                            id={`${id}-dim-${option.id}`} // Use generated id
                          />
                          <Label
                            htmlFor={`${id}-dim-${option.id}`} // Use generated id
                            className="font-normal cursor-pointer"
                          >
                            {option.label}
                          </Label>
                        </div>
                      ))}
                    </RadioGroup>
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* --- Details: Labor --- */}
            <div className="grid grid-cols-2 gap-4 border-t pt-4">
              {/* Labor Type Select */}
              <FormField
                control={form.control}
                name="details.labor.laborType"
                render={({ field: typeField }) => (
                  <FormItem>
                    <FormLabel>Labor Type</FormLabel>
                    <FormControl>
                      <select
                        className="w-full h-10 px-3 rounded-md border border-input bg-background"
                        value={labor?.laborType ?? "null"}
                        onChange={(e) => {
                          const value = e.target.value;
                          if (value === "null") {
                            form.setValue("details.labor", null);
                          } else {
                            form.setValue("details.labor", {
                              id: crypto.randomUUID(),
                              description: "↳ Labor",
                              laborRate:
                                form.getValues("details.labor.laborRate") || 0, // Keep existing rate if possible
                              laborType: value as any, // Cast needed
                            });
                          }
                        }}
                      >
                        <option value="null">No Labor</option>
                        <option value="percentage">Percentage</option>
                        <option value="fixed">Fixed Rate</option>
                        <option value="quantity">Per Unit</option>
                      </select>
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Labor Rate Input (Conditional) */}
              {labor && (
                <FormField
                  control={form.control}
                  name="details.labor.laborRate"
                  render={({ field: rateField }) => (
                    <FormItem>
                      <FormLabel>
                        {labor.laborType === "percentage"
                          ? "Labor %"
                          : "Labor Rate"}
                      </FormLabel>
                      <FormControl>
                        <NumericInput
                          prefix={
                            labor.laborType === "percentage"
                              ? ""
                              : currencyToSymbol(activeCurrency || "")
                          }
                          suffix={labor.laborType === "percentage" ? "%" : ""}
                          placeholder="0.00"
                          className="peer text-center"
                          value={rateField.value?.toString() ?? "0"}
                          onChange={(
                            e: React.ChangeEvent<HTMLInputElement>,
                          ) => {
                            const value = parseFloat(e.target.value);
                            rateField.onChange(
                              isNaN(value) || value < 0 ? 0 : value,
                            );
                          }}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              )}
            </div>

            <DialogFooter className="pt-4">
              <DialogClose asChild>
                <Button type="button" variant="secondary">
                  {" "}
                  Cancel{" "}
                </Button>
              </DialogClose>
              <Button
                type="submit"
                disabled={pending || !activeCurrency}
                variant={"brutalist"}
              >
                {pending ? "Adding..." : "Add Item"}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
// --- End of Component ---



# frontend/src/app/(auth)/journal/journal-types/quote/QuoteEntry.tsx
import React from "react";
import { Label } from "@/components/ui/label";
import { CardHeader, CardContent } from "@/components/ui/card"; // Card components might not be needed if EntryView handles the card structure
import {
  EntryView,
  EntryViewProps as BaseEntryViewProps,
} from "../../comp/EntryView"; // Use alias
// --- Import backend schema/types ---
import {
  Adjustment,
  LineItem,
  quoteDetailsState,
} from "@/../../backend/functions/src/common/schemas/quote_schema";
import { EntryType } from "@/../../backend/functions/src/common/schemas/configmap";
// --- Import frontend types ---
import { DBentry, User } from "@/lib/custom_types";
import { formatCurrency, formattedDate } from "@/lib/utils"; // Import utils
// --- Remove if CURRENCY_OPTIONS not used directly ---
// import { CURRENCY_OPTIONS } from "@/../../backend/functions/src/common/const";
import Link from "next/link";
import { Badge } from "@/components/ui/badge"; // For status
import { FileText } from "lucide-react"; // Icon for quote

// --- Define Props Interface ---
interface QuoteEntryProps {
  journalId: string;
  entry: DBentry; // Details should match quoteDetailsState
  entryType: EntryType; // Will be 'quote'
  user: User; // Creator info
  role: string; // Viewer's role
  removeFn: (entry: DBentry) => void;
}

// Helper Interface for calculated totals
interface QuoteTotals {
  itemsTotal: number;
  adjustmentsTotal: number;
  taxAmount: number;
  grandTotal: number;
}

// Helper function to calculate totals (can be memoized if complex)
const calculateQuoteTotals = (
  details: quoteDetailsState | undefined,
): QuoteTotals => {
  if (!details)
    return { itemsTotal: 0, adjustmentsTotal: 0, taxAmount: 0, grandTotal: 0 };

  const { confirmedItems = [], adjustments = [], taxPercentage = 0 } = details;

  const itemsTotal = confirmedItems.reduce(
    (sum: number, item: Partial<LineItem>) => {
      const quantity = item.quantity || 0;
      // Safely access nested properties
      const unitPrice = item.material?.unitPrice || 0;
      return sum + quantity * unitPrice;
    },
    0,
  );

  const adjustmentsTotal = adjustments.reduce(
    (sum: number, adj: Adjustment): number => {
      const value = adj.value || 0;
      let adjustmentValue = 0;
      switch (adj.type) {
        case "addFixed":
          adjustmentValue = value;
          break;
        case "discountFixed":
          adjustmentValue = -value;
          break;
        case "addPercent":
          adjustmentValue = (itemsTotal * value) / 100;
          break;
        case "discountPercent":
          adjustmentValue = -(itemsTotal * value) / 100;
          break;
        // taxPercent is not an adjustment to sum here
        default:
          break;
      }
      return sum + adjustmentValue;
    },
    0,
  );

  const subtotalBeforeTax = itemsTotal + adjustmentsTotal;
  const taxAmount = (subtotalBeforeTax * taxPercentage) / 100;
  const grandTotal = subtotalBeforeTax + taxAmount;

  return { itemsTotal, adjustmentsTotal, taxAmount, grandTotal };
};

// --- Main Component ---
export const QuoteEntry = React.memo(function QuoteEntry({
  journalId,
  entry,
  entryType,
  user,
  role,
  removeFn,
}: QuoteEntryProps) {
  // --- Basic validation ---
  if (!journalId || !entry || entryType !== "quote" || !entry.details) {
    console.error("Invalid props for QuoteEntry:", {
      journalId,
      entry,
      entryType,
    });
    return null;
  }

  // --- Safely access details ---
  // Cast details, assuming it matches quoteDetailsState structure based on entryType
  const details = entry.details as quoteDetailsState;
  const {
    customer,
    confirmedItems = [],
    adjustments = [],
    status = "pending", // Default status
    taxPercentage = 0,
    currency, // Currency code (e.g., "USD") is stored in details
    notes,
  } = details;

  // --- Calculate Totals ---
  const { itemsTotal, adjustmentsTotal, taxAmount, grandTotal } =
    calculateQuoteTotals(details);

  // --- Determine Status Color ---
  const getStatusBadgeVariant = (
    status: quoteDetailsState["status"],
  ): "default" | "secondary" | "destructive" | "outline" => {
    switch (status) {
      case "accepted":
        return "default"; // Greenish (using primary here, maybe customize later)
      case "rejected":
        return "destructive"; // Red
      case "pending":
      default:
        return "secondary"; // Yellowish/Grey
    }
  };

  return (
    // --- Pass props to EntryView ---
    <EntryView
      journalId={journalId}
      entry={entry}
      entryType={entryType}
      user={user}
      role={role}
      removeFn={removeFn}
    >
      {/* --- Quote Specific Summary --- */}
      {/* Link wraps the main content area */}
      <Link
        href={`/journal/entry?jid=${journalId}&eid=${entry.id}`} // Use journalId
        className="block hover:bg-accent/50 transition-colors rounded-md -m-2 p-2" // Make link cover area, adjust margins/padding
      >
        {/* Top Row: Customer Name, Grand Total, Status */}
        <div className="flex flex-wrap items-center justify-between gap-x-4 gap-y-1 mb-1">
          <div className="flex items-center gap-2 min-w-0">
            {" "}
            {/* Allow shrinking */}
            <FileText className="h-4 w-4 text-muted-foreground flex-shrink-0" />{" "}
            {/* Icon */}
            <span
              className="font-medium truncate"
              title={customer?.name || "No Customer"}
            >
              {customer?.name || "No Customer"}
            </span>
          </div>
          <div className="flex items-center gap-2">
            {/* <Badge variant={getStatusBadgeVariant(status)} className="text-xs">
              {status.charAt(0).toUpperCase() + status.slice(1)}
            </Badge> */}
            <span className="font-semibold text-base">
              {formatCurrency(grandTotal, currency || "USD")}{" "}
              {/* Use currency code from details */}
            </span>
          </div>
        </div>

        {/* Middle Row: Contact Info (Optional) */}
        <div className="text-xs text-muted-foreground mb-2 space-x-3">
          {customer?.email && (
            <span className="truncate" title={customer.email}>
              {customer.email}
            </span>
          )}
          {customer?.phone && <span>{customer.phone}</span>}
        </div>

        {/* Bottom Row: Summary of items/adjustments/notes */}
        <div className="text-xs text-muted-foreground space-y-1">
          {confirmedItems.length > 0 && (
            <p className="truncate">
              {confirmedItems.length} item(s):{" "}
              {confirmedItems
                .slice(0, 2) // Show first 2 items max
                .map(
                  (item: Partial<LineItem>) =>
                    item.material?.description || item.description || "item",
                ) // Safer access
                .join(", ")}
              {confirmedItems.length > 2 ? "..." : ""}
            </p>
          )}
          {adjustments.length > 0 && (
            <p className="truncate">
              {adjustments.length} adjustment(s)
              {/* Maybe show first adjustment desc? */}
              {/* {adjustments[0].description && ` (${adjustments[0].description})`} */}
            </p>
          )}
          {notes && <p className="truncate italic">Notes: {notes}</p>}
        </div>

        {/* Creator and Date Info (Optional - can be moved/removed) */}
        {/* <div className="text-xs text-muted-foreground mt-1 text-right">
             {`${user?.displayName || 'User'} | ${formattedDate(entry.createdAt)}`}
         </div> */}
      </Link>
    </EntryView>
  );
});



# frontend/src/app/(auth)/journal/journal-types/quote/addQuote.tsx
// frontend/src/app/(auth)/journal/journal-types/quote/addQuote.tsx
"use client";

import React, {
  useState,
  useEffect,
  useRef,
  useCallback,
  forwardRef,
  useMemo,
} from "react";
import { ChevronLeft, Printer, MinusCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { ContactInfo, ContactInfoRef } from "./subcomponents/ContactInfo";
import { NewItemForm } from "./subcomponents/NewItemForm";
import {
  LineItem,
  Adjustment,
  quoteDetailsState,
  quoteDetailsStateSchema,
} from "@/../../backend/functions/src/common/schemas/quote_schema";
import { InvoiceBottomLines } from "./subcomponents/Adjustments";
import {
  contactInfoSchemaType,
  allowedCurrencySchemaType,
  // EntryType,
  ROLES,
} from "@/../../backend/functions/src/common/schemas/common_schemas";
import { httpsCallable } from "firebase/functions";
import { functions } from "@/lib/auth_handler";
import { fetchEntry } from "@/lib/db_handler";
import { formattedDate, formatCurrency } from "@/lib/utils";
import { QuoteHeader } from "./subcomponents/header";
import { InlineEditTextarea } from "./subcomponents/EditNotes";
import Link from "next/link";
import { useToast } from "@/hooks/use-toast";
import { useRouter } from "next/navigation";
import { EntryItf } from "@/../../backend/functions/src/common/common_types"; // Import EntryItf for inventory cache type
import { useAuth } from "@/lib/auth_handler"; // Import useAuth
import { useJournalContext } from "@/context/JournalContext"; // Import useJournalContext

// --- Constants ---
const ADD_LOG_FN_NAME = "addLogFn";
const QUOTE_ENTRY_TYPE = "quote";

// Initial Contact Info remains the same
const initInfo: contactInfoSchemaType = {
  name: "",
  email: null, // Allow null
  phone: null, // Allow null
  address: {
    street: null, // Allow null
    city: null, // Allow null
    state: null, // Allow null
    zipCode: null, // Allow null
  },
};

// Backend function call remains the same name
const addLogFn = httpsCallable(functions, ADD_LOG_FN_NAME, {
  limitedUseAppCheckTokens: true,
});

// --- Updated Props Interface ---
interface QuoteDetailsProps {
  journalId: string; // Standardized name
  entryId?: string | null; // Optional for new quotes
  // Props passed down from parent (using JournalContext)
  supplierInfo: contactInfoSchemaType;
  supplierLogo: string | null;
  journalCurrency: allowedCurrencySchemaType;
  journalInventoryCache: Record<string, EntryItf>; // Receive inventory cache
}

// --- Main Component ---
// Use forwardRef if necessary, otherwise a standard functional component is fine
export const QuoteDetails = React.memo(function QuoteDetails({
  journalId,
  entryId: initialEntryId, // Rename prop to avoid conflict with state
  supplierInfo,
  supplierLogo,
  journalCurrency,
  journalInventoryCache,
}: QuoteDetailsProps) {
  // --- State Variables ---
  const [confirmedItems, setConfirmedItems] = useState<LineItem[]>([]);
  const [status, setStatus] = useState<quoteDetailsState["status"]>("pending");
  const [customer, setCustomer] = useState<contactInfoSchemaType>(initInfo);
  // supplier, logo, currency state removed -> use props
  const [adjustments, setAdjustments] = useState<Adjustment[]>([]);
  const [taxPercentage, setTaxPercentage] = useState(0);
  const [notes, setNotes] = useState<string>("");
  const [loading, setLoading] = useState(true); // Still need loading state for fetching *entry*
  const [createdDate, setCreatedDate] = useState<string | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const [entryId, setEntryId] = useState<string | null | undefined>(
    initialEntryId,
  );
  const [entryError, setEntryError] = useState<string | null>(null);

  // --- Refs and Hooks ---
  const customerRef = useRef<ContactInfoRef>(null);
  const { toast } = useToast();
  const router = useRouter();
  const { authUser } = useAuth(); // Get authenticated user
  const { journal } = useJournalContext(); // Get journal context

  // Determine user role
  const userRole: (typeof ROLES)[number] = useMemo(() => {
    if (!authUser || !journal || !journal.access) {
      return "viewer"; // Default to viewer if no user or journal access info
    }
    return journal.access[authUser.uid]?.role || "viewer"; // Get role or default to viewer
  }, [authUser, journal]);

  // --- Fetch existing entry data (if entryId exists) ---
  useEffect(() => {
    setEntryId(initialEntryId); // Sync prop with state initially

    async function loadEntryData() {
      // No need to fetch the *journal* here, assume parent did via context
      setLoading(true);
      setEntryError(null);

      if (!journalId) {
        setEntryError("Journal ID is missing.");
        setLoading(false);
        return;
      }

      // Only fetch if we have an ID to edit
      if (initialEntryId) {
        try {
          const entry = await fetchEntry(
            journalId,
            QUOTE_ENTRY_TYPE,
            initialEntryId,
          );
          console.log("Fetched entry:", entry);

          if (!entry) {
            setEntryError("Quote entry not found or access denied.");
          } else if (entry.details) {
            const details = entry.details as quoteDetailsState;
            const validation = quoteDetailsStateSchema.safeParse(details);
            if (!validation.success) {
              console.error(
                "Fetched quote details failed validation:",
                validation.error,
              );
              setEntryError("Loaded quote data is invalid.");
            } else {
              // Set state based on fetched entry data
              setConfirmedItems(validation.data.confirmedItems || []);
              setStatus(validation.data.status || "pending");
              setCustomer(validation.data.customer || initInfo);
              setAdjustments(validation.data.adjustments || []);
              setTaxPercentage(validation.data.taxPercentage || 0);
              setNotes(validation.data.notes || "");
              setCreatedDate(formattedDate(entry.createdAt));
            }
          }
        } catch (error) {
          console.error("Error loading quote entry:", error);
          setEntryError("Failed to load quote details. Please try again.");
        } finally {
          setLoading(false);
        }
      } else {
        // New quote: Reset fields (supplier/logo/currency come from props)
        setConfirmedItems([]);
        setStatus("pending");
        setCustomer(initInfo);
        setAdjustments([]);
        setTaxPercentage(0);
        setNotes("");
        setCreatedDate(formattedDate(new Date())); // Set to now
        setLoading(false); // Finished "loading" (no entry to fetch)
      }
    }

    loadEntryData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [journalId, initialEntryId]); // Rerun if journalId or initialEntryId changes

  // --- Event Handlers ---
  const addConfirmedItem = (items: LineItem[]) => {
    const newItems = [...confirmedItems, ...items];
    setConfirmedItems(newItems);
    handleSave({ confirmedItems: newItems });
  };

  const removeConfirmedItem = (id: string) => {
    const newItems = confirmedItems.filter(
      (item) => item.id !== id && item.parentId !== id,
    );
    setConfirmedItems(newItems);
    handleSave({ confirmedItems: newItems });
  };

  const calculateSubtotal = useCallback(() => {
    return confirmedItems.reduce(
      (sum, item) => sum + item.quantity * item.material.unitPrice,
      0,
    );
  }, [confirmedItems]);

  // Use journalCurrency prop
  const currencyFormat = useCallback(
    (amount: number) => {
      return journalCurrency
        ? formatCurrency(amount, journalCurrency)
        : amount.toFixed(2);
    },
    [journalCurrency],
  );

  // --- Updated handleSave ---
  const handleSave = useCallback(
    async (updates: Partial<quoteDetailsState> = {}) => {
      if (isSaving || !journalId || !journalCurrency) {
        console.warn(
          "Save aborted. Already saving or missing Journal ID/Currency.",
        );
        if (!journalCurrency) {
          toast({
            title: "Missing Currency",
            description: "Cannot save quote, journal currency is not set.",
            variant: "destructive",
          });
        }
        return;
      }
      setIsSaving(true);

      // Validate Customer Info
      if (customerRef.current) {
        const isValid = await customerRef.current.validate();
        if (!isValid) {
          console.warn("Customer contact info is invalid. Aborting save.");
          toast({
            title: "Invalid Customer Info",
            description: "Please correct customer details before saving.",
            variant: "destructive",
          });
          setIsSaving(false);
          return;
        }
      } else {
        // Handle ref not ready (should be rare)
        toast({
          title: "Save Error",
          description: "Could not validate customer info.",
          variant: "destructive",
        });
        setIsSaving(false);
        return;
      }

      // Construct Details Payload using props and state
      const quoteDetailsData: quoteDetailsState = {
        confirmedItems: updates.confirmedItems ?? confirmedItems,
        status: updates.status ?? status,
        customer: updates.customer ?? customer,
        supplier: supplierInfo || initInfo, // Use prop
        logo: supplierLogo || null, // Use prop
        adjustments: updates.adjustments ?? adjustments,
        taxPercentage: updates.taxPercentage ?? taxPercentage,
        currency: journalCurrency, // Use prop
        notes: updates.notes ?? notes,
      };

      // Validate final details object
      const detailsValidation =
        quoteDetailsStateSchema.safeParse(quoteDetailsData);
      if (!detailsValidation.success) {
        console.error(
          "Quote details validation failed before save:",
          detailsValidation.error.format(),
        );
        toast({
          title: "Invalid Quote Data",
          description:
            "Could not save quote due to invalid data. Check console for details.",
          variant: "destructive",
        });
        setIsSaving(false);
        return;
      }
      const validatedDetails = detailsValidation.data;

      // Construct Backend Payload
      const payload = {
        journalId: journalId, // Use prop
        entryType: QUOTE_ENTRY_TYPE,
        name: `Quote for ${validatedDetails.customer.name || "Unknown"}`,
        details: validatedDetails,
        ...(entryId && { entryId }), // Include entryId if editing
      };

      console.log("Saving quote with payload:", payload);

      // Call Backend Function
      try {
        const result = await addLogFn(payload);
        console.log("Quote save successful:", result.data);

        const returnedId = (result.data as any)?.id;
        if (returnedId && !entryId) {
          setEntryId(returnedId);
          const url = new URL(window.location.href);
          url.searchParams.set("eid", returnedId);
          router.replace(url.toString(), { scroll: false });
          console.log("Set new entryId:", returnedId);
        }

        toast({
          title: entryId ? "Quote Updated" : "Quote Saved",
          description: `Quote for ${validatedDetails.customer.name} saved successfully.`,
        });
      } catch (error: any) {
        console.error("Error saving quote:", error);
        toast({
          title: "Save Failed",
          description: error.message || "Could not save the quote.",
          variant: "destructive",
        });
      } finally {
        setIsSaving(false);
      }
    },
    [
      isSaving,
      journalId,
      journalCurrency, // Use prop
      confirmedItems,
      status,
      customer,
      supplierInfo, // Use prop
      supplierLogo, // Use prop
      adjustments,
      taxPercentage,
      notes,
      entryId,
      toast,
      router,
    ],
  );

  // --- Render Logic ---
  if (loading) {
    // Loading state while fetching entry
    return <div className="text-center p-10">Loading quote details...</div>;
  }
  if (entryError) {
    // Display error if fetching entry failed
    return <div className="text-center p-10 text-red-600">{entryError}</div>;
  }
  // Ensure necessary props are available (parent should handle this loading)
  if (!journalCurrency || !supplierInfo) {
    return (
      <div className="text-center p-10 text-muted-foreground">
        Journal details (currency, supplier) not available.
      </div>
    );
  }

  // --- JSX Structure ---
  return (
    <div
      id="quote-printable-container"
      className="w-full print:max-w-none mx-auto p-2 border-none relative pb-20 md:pb-4 lg:pr-[430px]" // Add right padding on large screens
    >
      {/* --- Header (Passes props) --- */}
      <QuoteHeader logo={supplierLogo} contactInfo={supplierInfo} />

      {/* --- Content --- */}
      <div className="space-y-4 px-2 md:px-4">
        {/* Customer Info */}
        <div>
          <h3 className="text-lg font-semibold mt-4 mb-2">Customer</h3>
          <ContactInfo
            ref={customerRef}
            info={customer}
            setInfo={(newInfo) => {
              setCustomer(newInfo);
              // Consider debouncing or saving on blur/button click
              // handleSave({ customer: newInfo }); // Auto-save on change (can be noisy)
            }}
            onSave={() => handleSave({ customer })} // Pass specific update on explicit save
          />
        </div>
        {/* Items Section */}
        <div>
          <h3 className="text-lg font-semibold pt-4 mb-2">Items</h3>
          <div className="border rounded-md p-2">
            {/* Items Table */}
            <div className="space-y-2">
              <table className="w-full text-sm">
                {/* ... Table Head ... */}
                <thead>
                  <tr className="text-xs text-muted-foreground border-b">
                    <th className="text-left py-2 px-1 font-medium w-20">
                      Qty
                    </th>
                    <th className="text-left py-2 px-1 font-medium">
                      Description
                    </th>
                    <th className="text-right py-2 px-2 font-medium w-24">
                      Price
                    </th>
                    <th className="text-right py-2 px-1 font-medium w-24">
                      Total
                    </th>
                    <th className="w-8 print-hide"></th>
                  </tr>
                </thead>
                <tbody>
                  {confirmedItems.map((item) => (
                    <tr
                      key={item.id}
                      className={`border-b border-dashed last:border-0 ${
                        item.parentId == "root" ? "bg-secondary/30" : "" // Adjusted bg
                      }`}
                    >
                      {/* Quantity Cell */}
                      <td className="py-2 px-1 text-left align-top">
                        <div className="flex flex-col items-center w-min">
                          {item.quantity}
                          <div className="text-xs text-muted-foreground">
                            {`${item.material.dimensions.unitLabel}`}
                          </div>
                        </div>
                      </td>
                      {/* Description Cell */}
                      <td className="py-2 px-1 align-top">
                        {item.description && (
                          <div className="text-sm">{item.description}</div>
                        )}
                        <div className="text-xs text-muted-foreground flex flex-row items-center gap-1">
                          {item.material.description}
                          {":"}
                          {item.material.dimensions.type === "area" &&
                            item.dimensions && (
                              <div className="">
                                {item.dimensions.length} ×{" "}
                                {item.dimensions.width}{" "}
                                {item.material.dimensions.unitLabel}
                              </div>
                            )}
                        </div>
                      </td>
                      {/* Price Cell */}
                      <td className="py-2 px-1 align-top">
                        <div className="text-right pr-2">
                          {currencyFormat(item.material.unitPrice)}
                          <div className="text-xs text-muted-foreground">
                            {`/${item.material.dimensions.unitLabel}`}
                          </div>
                        </div>
                      </td>
                      {/* Total Cell */}
                      <td className="py-2 px-1 text-right align-top">
                        {currencyFormat(
                          item.quantity * item.material.unitPrice,
                        )}
                      </td>
                      {/* Remove Button Cell */}
                      <td className="py-2 px-1 print-hide align-top">
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => removeConfirmedItem(item.id)}
                          disabled={isSaving}
                          className="h-8 w-8" // Ensure consistent button size
                        >
                          <MinusCircle className="h-4 w-4 text-muted-foreground" />
                        </Button>
                      </td>
                    </tr>
                  ))}
                  {confirmedItems.length === 0 && (
                    <tr>
                      <td
                        colSpan={5}
                        className="text-center py-4 text-sm text-muted-foreground"
                      >
                        Add items using the form below.
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>

            {/* --- Add New Item Form (Passes props) --- */}
            <NewItemForm
              onAddItem={addConfirmedItem}
              currency={journalCurrency}
              // Pass inventory cache down
              inventoryCache={journalInventoryCache}
              userRole={userRole} // Pass userRole
            />

            {/* Totals and Adjustments (Passes props) */}
            <InvoiceBottomLines
              itemSubtotal={calculateSubtotal()}
              adjustments={adjustments}
              setAdjustments={(newAdjustments) => {
                setAdjustments(newAdjustments);
                handleSave({ adjustments: newAdjustments });
              }}
              taxPercentage={taxPercentage}
              setTaxPercentage={(newTaxPercentage) => {
                setTaxPercentage(newTaxPercentage);
                handleSave({ taxPercentage: newTaxPercentage });
              }}
              currency={journalCurrency}
              userRole={userRole} // Pass userRole
            />
          </div>
        </div>
        {/* Notes */}
        <div className="space-y-2">
          <Label htmlFor="notes">Notes</Label>
          <InlineEditTextarea
            initialValue={notes}
            onSave={(value) => {
              setNotes(value);
              handleSave({ notes: value });
            }}
            placeholder="Add any additional notes..."
            disabled={isSaving}
          />
        </div>
      </div>

      {/* Actions Bar */}
      <div
        id="quote-actions-bar"
        className="print-hide flex justify-between items-center mt-6 px-2 md:px-4"
      >
        <Button variant="brutalist" asChild size="sm">
          <Link href={`/journal?jid=${journalId}`}>
            <ChevronLeft className="h-4 w-4 mr-2" /> Back
          </Link>
        </Button>
        {/* Explicit Save Button (Optional) */}
        {/* <Button variant="default" size="sm" onClick={() => handleSave()} disabled={isSaving}>
          {isSaving ? "Saving..." : "Save Quote"}
        </Button> */}
        <Button
          variant="brutalist"
          size="sm"
          onClick={() => window.print()}
          disabled={isSaving} // Disable print while saving to avoid inconsistencies
        >
          <Printer className="h-4 w-4 mr-2" /> Print
        </Button>
      </div>

      {/* Print Styles (No changes needed here) */}
      <style jsx global>{`
        @media print {
          body * {
            visibility: hidden;
            color-adjust: exact !important;
            -webkit-print-color-adjust: exact !important;
          }

          /* Hide placeholders when printing */
          #quote-printable-container input::placeholder,
          #quote-printable-container textarea::placeholder {
            color: transparent !important;
            opacity: 0 !important;
          }

          /* Target the quote container by ID */
          #quote-printable-container,
          #quote-printable-container * {
            visibility: visible;
          }
          #quote-printable-container {
            position: absolute;
            left: 50%;
            top: 0;
            width: 100%;
            max-width: 8.5in; /* Standard letter width */
            transform: translateX(-50%); /* Center horizontally */
            padding-top: 0.1in; /* Add some padding for better print layout */
            color: black !important;
            background-color: white !important;
            margin: 0 !important;
          }
          /* Make all text and backgrounds black and white */
          #quote-printable-container * {
            color: black !important;
            background-color: transparent !important;
            border-color: black !important;
            text-shadow: none !important;
            box-shadow: none !important;
          }
          /* Elements with .print-color should preserve their color */
          .print-color {
            filter: none !important;
            -webkit-filter: none !important;
            color-adjust: exact !important;
            -webkit-print-color-adjust: exact !important;
          }
          /* Also ensure parent elements don't override with their grayscale filter */
          .print-color * {
            filter: none !important;
            -webkit-filter: none !important;
          }
          /* Hide specific elements by ID */
          .print-hide {
            display: none !important;
          }
        }
      `}</style>
    </div>
  );
});

// --- AddNewQuoteBtn Component (No changes needed here) ---
export const AddNewQuoteBtn = ({ journalId }: { journalId: string }) => {
  // Rename journalId to journalId for consistency internally if preferred
  return (
    <div>
      <Button variant="brutalist" className="mb-4" asChild>
        {/* Use journalId in the link */}
        <Link href={`/journal/entry?jid=${journalId}`}>New Quote</Link>
      </Button>
    </div>
  );
};



# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/AdjustmentForm.tsx
"use client";

import { useState, useId, useMemo } from "react"; // Import useMemo
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { useMediaQuery } from "@/hooks/use-media-query";
import {
  Drawer,
  DrawerContent,
  DrawerHeader,
  DrawerTitle,
  DrawerClose,
  DrawerFooter,
  DrawerTrigger,
} from "@/components/ui/drawer";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { NumericInput } from "@/components/InputUnit";
import { currencyToSymbol } from "@/lib/utils";
import { ListPlus, Plus } from "lucide-react";
import {
  quoteDetailsState,
  quoteDetailsStateSchema,
} from "@/../../backend/functions/src/common/schemas/quote_schema";
import { ROLES_THAT_ADD } from "@/../../backend/functions/src/common/const"; // Import ROLES_THAT_ADD

export type Adjustment = quoteDetailsState["adjustments"][number];

interface AdjustmentFormProps {
  onSubmit: (adj: Adjustment) => void;
  onTaxSubmit?: (value: number) => void;
  currency?: string;
  taxPercentage?: number;
  userRole?: string; // Added userRole prop for permission check
}

// Define adjustment types for better type safety
const ADJUSTMENT_TYPES = [
  { value: "addFixed", label: "Fee flat ($)" },
  { value: "addPercent", label: "Fee %" },
  { value: "discountFixed", label: "Discount flat $" },
  { value: "discountPercent", label: "Discount %" },
  { value: "taxPercent", label: "Tax %" },
] as const;

// Type selector component
function AdjustmentTypeSelector({
  value,
  onChange,
  id,
}: {
  value: Adjustment["type"];
  onChange: (value: Adjustment["type"]) => void;
  id: string;
}) {
  return (
    <RadioGroup
      className="grid grid-cols-2 gap-2"
      value={value}
      onValueChange={(value) => onChange(value as Adjustment["type"])}
    >
      {ADJUSTMENT_TYPES.map((type) => (
        <div
          key={`${id}-${type.value}`}
          className="border-input hover:bg-accent/50 has-data-[state=checked]:border-ring has-data-[state=checked]:bg-accent relative flex flex-col items-start rounded-md border p-3 shadow-xs outline-none transition-colors"
        >
          <div className="flex items-center gap-2">
            <RadioGroupItem
              id={`${id}-${type.value}`}
              value={type.value}
              className="after:absolute after:inset-0"
            />
            <Label htmlFor={`${id}-${type.value}`}>{type.label}</Label>
          </div>
        </div>
      ))}
    </RadioGroup>
  );
}

export function AdjustmentForm({
  onSubmit,
  onTaxSubmit,
  currency,
  taxPercentage,
  userRole = "viewer", // Default to viewer if undefined
}: AdjustmentFormProps) {
  // Consolidated form state
  const [formState, setFormState] = useState<{
    type: Adjustment["type"];
    value: string;
    description: string;
  }>({
    type: "addFixed",
    value: "",
    description: "",
  });

  const isMobile = useMediaQuery("(max-width: 768px)");
  const [drawerOpen, setDrawerOpen] = useState(false);
  const id = useId();

  // --- Add permission check ---
  const canModify = useMemo(() => ROLES_THAT_ADD.has(userRole), [userRole]);
  // --- End permission check ---

  // Form update helpers
  const updateField = <K extends keyof typeof formState>(
    key: K,
    value: (typeof formState)[K],
  ) => {
    setFormState((prev) => ({ ...prev, [key]: value }));
  };

  const resetForm = () => {
    setFormState({
      type: "addFixed",
      value: "",
      description: "",
    });
  };

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const numericValue = Number.parseFloat(formState.value);
    if (isNaN(numericValue)) return;

    if (formState.type === "taxPercent") {
      onTaxSubmit?.(numericValue);
    } else {
      onSubmit({
        type: formState.type,
        value: numericValue,
        description: formState.description,
      });
    }

    resetForm();
    if (isMobile) setDrawerOpen(false);
  };

  const isPercentType = formState.type.includes("Percent");
  const isTaxType = formState.type === "taxPercent";

  const formContent = (
    <form
      id="quote-adjustments-form"
      onSubmit={handleSubmit}
      className="space-y-4"
      // No direct disable on form, disable inputs instead
    >
      {!isMobile && (
        <legend className="text-foreground text-sm leading-none font-medium mb-3">
          Add Adjustment
        </legend>
      )}
      <div
        className={cn(
          "gap-4",
          isMobile ? "space-y-4" : "grid grid-cols-[1fr_1fr]", // Changed from grid-cols-[2fr_2fr_auto] to 2 columns
        )}
      >
        <div>
          <fieldset className="space-y-4" disabled={!canModify}>
            {" "}
            {/* Disable fieldset */}
            <AdjustmentTypeSelector
              id={id}
              value={formState.type}
              onChange={(value) => updateField("type", value)}
            />
          </fieldset>
        </div>

        <div className="flex flex-col gap-2">
          <Label htmlFor="adjustmentDescription" className="sr-only">
            Description {!isTaxType && "(Optional)"}
          </Label>
          <Input
            id="adjustmentDescription"
            value={formState.description}
            onChange={(e) => updateField("description", e.target.value)}
            placeholder={isTaxType ? "Tax %" : "Description (Optional)"}
            disabled={isTaxType || !canModify} // Disable input
            className="transition-all"
          />

          <div>
            <Label htmlFor="adjustmentValue-id" className="sr-only">
              Value
            </Label>
            <NumericInput
              id="adjustmentValue-id"
              className="peer text-center"
              prefix={isPercentType ? "" : currencyToSymbol(currency || "")}
              suffix={isPercentType ? "%" : ""}
              value={formState.value}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                const inputValue = e.target.value;
                if (inputValue === "" || !isNaN(parseFloat(inputValue))) {
                  updateField("value", inputValue);
                }
              }}
              disabled={!canModify} // Disable input
            />
          </div>
        </div>
      </div>

      {/* Add button moved to a new row */}
      {!isMobile && (
        <div className="flex justify-end mt-4">
          <Button
            type="submit"
            className="w-1/3"
            variant="brutalist"
            disabled={!formState.value || !canModify} // Disable button
          >
            <Plus className="mr-1" />
            Add
          </Button>
        </div>
      )}
    </form>
  );

  if (isMobile) {
    return (
      <div className="mobile-form print-hide">
        <Drawer open={drawerOpen} onOpenChange={setDrawerOpen}>
          <DrawerTrigger asChild>
            <Button
              variant="brutalist"
              className="w-full"
              disabled={!canModify} // Disable trigger
            >
              <ListPlus className="mr-2" />
              Add Adjustment
            </Button>
          </DrawerTrigger>
          <DrawerContent className="sm:max-w-[420px] px-6 pt-2">
            <DrawerHeader>
              <DrawerTitle>Add Adjustment</DrawerTitle>
            </DrawerHeader>
            {formContent}
            <DrawerFooter className="pt-2">
              <Button
                type="submit"
                form="quote-adjustments-form"
                variant="brutalist"
                disabled={!formState.value || !canModify} // Disable button
              >
                <Plus className="mr-1" /> Add
              </Button>
              <Button variant="outline" onClick={() => setDrawerOpen(false)}>
                Cancel
              </Button>
            </DrawerFooter>
          </DrawerContent>
        </Drawer>
      </div>
    );
  }

  return <div className="print-hide">{formContent}</div>;
}



# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/Adjustments.tsx
"use client";

import * as React from "react";
import { cn } from "@/lib/utils";
import { AdjustmentForm, Adjustment } from "./AdjustmentForm";
import { Button } from "@/components/ui/button";
import { MinusCircle } from "lucide-react";
import { allowedCurrencySchemaType } from "@/../../backend/functions/src/common/schemas/common_schemas";
import { ROLES_THAT_ADD } from "@/../../backend/functions/src/common/const"; // Import ROLES_THAT_ADD
import { ROLES } from "@/../../backend/functions/src/common/schemas/common_schemas"; // Import ROLES type

interface InvoiceBottomLinesProps {
  itemSubtotal: number;
  adjustments: Adjustment[];
  setAdjustments: (adjustments: Adjustment[]) => void;
  taxPercentage: number;
  setTaxPercentage: (percentage: number) => void;
  currency: allowedCurrencySchemaType;
  onSave?: (updates: any) => void; // Add this new prop
  userRole: (typeof ROLES)[number]; // Add userRole prop
}

const currencyFormat = (
  amount: number,
  currency: allowedCurrencySchemaType,
) => {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
};

export function InvoiceBottomLines({
  itemSubtotal,
  adjustments,
  setAdjustments,
  taxPercentage,
  setTaxPercentage,
  currency,
  onSave, // Add this new prop
  userRole, // Use prop
}: InvoiceBottomLinesProps) {
  // Check if user has permission to modify
  const canModify = React.useMemo(
    () => ROLES_THAT_ADD.has(userRole),
    [userRole],
  );

  const calculateAdjustmentAmount = React.useCallback(
    (adjustment: Adjustment): number => {
      if (!adjustment || typeof adjustment.value !== "number") return 0;
      const value = adjustment.value;
      const calculations = {
        addFixed: () => value || 0,
        addPercent: () => ((itemSubtotal || 0) * value) / 100,
        discountFixed: () => -(value || 0),
        discountPercent: () => -((itemSubtotal || 0) * value) / 100,
        taxPercent: () => 0, // this is a tax percentage, not an adjustment
      };
      return calculations[adjustment.type]?.() ?? 0;
    },
    [itemSubtotal],
  );

  const totalAdjustments = React.useMemo(
    () =>
      adjustments.reduce(
        (sum, adjustment) =>
          sum + (calculateAdjustmentAmount(adjustment) || 0),
        0,
      ),
    [adjustments, calculateAdjustmentAmount],
  );

  const { totalBeforeTax, taxAmount, grandTotal } = React.useMemo(() => {
    const totalBeforeTax = (itemSubtotal || 0) + (totalAdjustments || 0);
    const taxAmount = ((totalBeforeTax || 0) * (taxPercentage || 0)) / 100;
    return {
      totalBeforeTax,
      taxAmount,
      grandTotal: totalBeforeTax + taxAmount,
    };
  }, [itemSubtotal, totalAdjustments, taxPercentage]);

  const handleAddAdjustment = (newAdjustment: Adjustment) => {
    setAdjustments([...adjustments, newAdjustment]);
    // Call onSave if provided
    if (onSave) {
      onSave({ adjustments: [...adjustments, newAdjustment] });
    }
  };
  const handleDeleteAdjustment = (index: number) => {
    const newAdjustments = adjustments.filter((_, i) => i !== index);
    setAdjustments(newAdjustments);
    // Call onSave if provided
    if (onSave) {
      onSave({ adjustments: newAdjustments });
    }
  };

  const handleTaxChange = (newTaxPercentage: number) => {
    setTaxPercentage(newTaxPercentage);
    // Call onSave if provided
    if (onSave) {
      onSave({ taxPercentage: newTaxPercentage });
    }
  };

  const formatDescription = (adjustment: Adjustment) => {
    if (!adjustments.length) return "";
    return (
      (adjustment.description ||
        `${adjustment.type.includes("add") ? "Addition" : "Discount"}`) +
      " " +
      (adjustment.type.includes("Percent")
        ? `( ${adjustment.value}% )`
        : currencyFormat(adjustment.value, currency))
    );
  };

  return (
    <div className="space-y-2 pt-4 border-t">
      <div className="md:max-w-[50%]  print:max-w-[50%] md:ml-auto print:ml-auto">
        <div className="flex justify-between items-center">
          <span>Subtotal</span>
          <span className="pr-10 print:pr-0">
            {currencyFormat(itemSubtotal, currency)}
          </span>
        </div>
        {adjustments.map((adjustment, index) => (
          <div key={index} className="flex justify-between items-center">
            <span>{formatDescription(adjustment)}</span>
            <span
              className={cn(
                "font-medium",
                calculateAdjustmentAmount(adjustment) >= 0
                  ? "text-green-600"
                  : "text-red-600",
              )}
            >
              {calculateAdjustmentAmount(adjustment) >= 0 ? "+" : "-"}
              {currencyFormat(
                Math.abs(calculateAdjustmentAmount(adjustment)),
                currency,
              )}
              <Button
                variant="ghost"
                key={`${index}-delete`}
                aria-label="Delete adjustment"
                data-testid={`delete-adjustment-${index}`}
                className="print-hide"
                size="icon"
                onClick={() => {
                  handleDeleteAdjustment(index);
                }}
                disabled={!canModify} // Disable delete button
                title={
                  !canModify
                    ? "You don't have permission to remove adjustments"
                    : ""
                } // Add tooltip
              >
                <MinusCircle className="h-4 w-4 text-muted-foreground" />
              </Button>
            </span>
          </div>
        ))}
        {taxPercentage > 0 && (
          <>
            <div className="flex justify-between items-center pt-2 border-t">
              <span>Total before Tax</span>
              <div>
                <span className="pr-10 print:pr-0">
                  {currencyFormat(totalBeforeTax, currency)}
                </span>
              </div>
            </div>
            <div className="flex justify-between items-center">
              <span>Tax ({taxPercentage}%)</span>
              <div>
                <span>{currencyFormat(taxAmount, currency)}</span>
                <Button
                  variant="ghost"
                  key="delete-tax"
                  aria-label="Delete tax"
                  size="icon"
                  className="print-hide ml-1"
                  onClick={() => {
                    handleTaxChange(0);
                  }}
                  disabled={!canModify} // Disable delete tax button
                  title={
                    !canModify ? "You don't have permission to remove tax" : ""
                  } // Add tooltip
                >
                  <MinusCircle className="h-4 w-4 text-muted-foreground" />
                </Button>
              </div>
            </div>
          </>
        )}
        <div className="flex justify-between pt-4 mt-2 items-center border-t-4 border-double">
          <span className="text-md font-medium">Grand Total</span>
          <h1 className="pr-10 print:pr-0 text-xl font-bold text-primary">
            {currencyFormat(grandTotal, currency)}
          </h1>
        </div>
      </div>
      <div className="print-hide space-y-2">
        <AdjustmentForm
          onSubmit={handleAddAdjustment}
          onTaxSubmit={handleTaxChange}
          currency={currency}
          taxPercentage={taxPercentage}
          userRole={userRole} // Pass userRole down
        />
      </div>
    </div>
  );
}



# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/ContactInfo.tsx
"use client";

import React, { useState, useImperativeHandle, forwardRef } from "react";
import {
  FormControl,
  FormField,
  FormItem,
  FormMessage,
  Form,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Edit2, Mail, MapPin, Phone, User, X, AtSignIcon } from "lucide-react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  contactInfoSchema,
  contactInfoSchemaType,
} from "@/../../backend/functions/src/common/schemas/common_schemas";

export interface ContactInfoRef {
  validate: () => Promise<boolean>;
}

interface ContactInfoProps {
  info: contactInfoSchemaType;
  setInfo: (info: contactInfoSchemaType) => void;
  onSave?: (updates: any) => void;
}

// Improved ContactSummary layout
const ContactSummary = ({ info }: { info: contactInfoSchemaType }) => (
  <div className="flex flex-wrap justify-between items-start gap-4 flex-grow">
    {/* Name and company info */}
    <div className="flex flex-col">
      <div className="flex items-center space-x-2">
        <User className="h-5 w-5 text-primary" />
        <h2 className="text-xl font-bold">{info.name || "Not set"}</h2>
      </div>

      {/* Address below name */}
      {info.address?.street && ( // Add optional chaining to safely access address properties
        <div className="mt-2 text-sm text-muted-foreground">
          <div className="flex items-center space-x-2">
            <MapPin className="h-4 w-4 text-muted-foreground" />
            <div className="flex flex-wrap gap-2">
              <span>{info.address.street}</span>
              <div>
                {info.address.city}, {info.address.state}{" "}
                {info.address.zipCode}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>

    {/* Contact details on right side */}
    <div className="flex flex-wrap justify-between items-center gap-4 sm:flex-col sm:items-end grow">
      <div className="flex items-center space-x-2">
        <Phone className="h-4 w-4 text-muted-foreground" />
        <a
          href={`tel:${info.phone}`}
          className="text-sm text-muted-foreground hover:text-primary"
        >
          {info.phone || "Not set"}
        </a>
      </div>
      <div className="flex items-center space-x-2">
        <Mail className="h-4 w-4 text-muted-foreground" />
        <a
          href={`mailto:${info.email}`}
          className="text-sm text-muted-foreground hover:text-primary"
        >
          {info.email || "Not set"}
        </a>
      </div>
    </div>
  </div>
);

export const ContactInfo = forwardRef<ContactInfoRef, ContactInfoProps>(
  ({ info, setInfo, onSave }, ref) => {
    const [isEditing, setIsEditing] = useState(!info.name);
    const [isSubmitting, setIsSubmitting] = useState(false);

    const form = useForm<contactInfoSchemaType>({
      resolver: zodResolver(contactInfoSchema),
      defaultValues: info,
    });

    const handleCancel = () => {
      form.reset(info);
      setIsEditing(false);
    };

    const handleSubmit = async (data: contactInfoSchemaType) => {
      try {
        setIsSubmitting(true);
        setInfo(data);
        if (onSave) {
          onSave({ customer: data });
        }
        setIsEditing(false);
      } catch (error) {
        console.error("Error submitting form:", error);
      } finally {
        setIsSubmitting(false);
      }
    };

    useImperativeHandle(ref, () => ({
      validate: () => form.trigger(),
    }));

    return (
      <Card className="relative">
        <CardHeader className="flex items-center justify-between pr-4 pb-2 pt-2">
          {isEditing && (
            <div className="flex flex-row-reverse items-center justify-start space-x-2 w-full  print:hidden">
              <Button
                variant="brutalist"
                size="icon"
                onClick={handleCancel}
                disabled={!contactInfoSchema.safeParse(info).success}
                aria-label="Cancel editing"
              >
                <X className="h-4 w-4" />
              </Button>
            </div>
          )}
        </CardHeader>
        <CardContent className="p-4 pt-0">
          <div className="hidden print:block">
            <ContactSummary info={info} />
          </div>
          {isEditing ? (
            <Form {...form}>
              <form
                onSubmit={form.handleSubmit(handleSubmit)}
                className="space-y-4 print-hide"
              >
                <FormField
                  control={form.control}
                  name="name"
                  render={({ field }) => (
                    <FormItem>
                      <div className="relative">
                        <FormControl>
                          <Input
                            className="peer ps-9"
                            placeholder="John Doe"
                            {...field}
                          />
                        </FormControl>
                        <div className="text-muted-foreground/80 pointer-events-none absolute inset-y-0 start-0 flex items-center justify-center ps-3 peer-disabled:opacity-50">
                          <User size={16} aria-hidden="true" />
                        </div>
                      </div>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="email"
                  render={({ field }) => (
                    <FormItem>
                      <div className="relative">
                        <FormControl>
                          <Input
                            className="peer ps-9"
                            placeholder="email@example.com"
                            value={field.value ?? ""}
                            onChange={field.onChange}
                            onBlur={field.onBlur}
                            name={field.name}
                            ref={field.ref}
                          />
                        </FormControl>
                        <div className="text-muted-foreground/80 pointer-events-none absolute inset-y-0 start-0 flex items-center justify-center ps-3 peer-disabled:opacity-50">
                          <AtSignIcon size={16} aria-hidden="true" />
                        </div>
                        <FormMessage />
                      </div>
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="phone"
                  render={({ field }) => (
                    <FormItem>
                      <div className="relative">
                        <FormControl>
                          <Input
                            className="peer ps-9"
                            placeholder="(555) 555-5555"
                            value={field.value ?? ""}
                            onChange={field.onChange}
                            onBlur={field.onBlur}
                            name={field.name}
                            ref={field.ref}
                          />
                        </FormControl>
                        <div className="text-muted-foreground/80 pointer-events-none absolute inset-y-0 start-0 flex items-center justify-center ps-3 peer-disabled:opacity-50">
                          <Phone size={16} aria-hidden="true" />
                        </div>
                        <FormMessage />
                      </div>
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="address.street"
                  render={({ field }) => (
                    <FormItem>
                      <div className="text-sm font-medium">Street Address</div>
                      <FormControl>
                        <Input
                          placeholder="123 Main St"
                          value={field.value ?? ""}
                          onChange={field.onChange}
                          onBlur={field.onBlur}
                          name={field.name}
                          ref={field.ref}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="grid grid-cols-3 gap-4">
                  <FormField
                    control={form.control}
                    name="address.city"
                    render={({ field }) => (
                      <FormItem>
                        <div className="text-sm font-medium">City</div>
                        <FormControl>
                          <Input
                            value={field.value ?? ""}
                            onChange={field.onChange}
                            onBlur={field.onBlur}
                            name={field.name}
                            ref={field.ref}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="address.state"
                    render={({ field }) => (
                      <FormItem>
                        <div className="text-sm font-medium">State</div>
                        <FormControl>
                          <Input
                            value={field.value ?? ""}
                            onChange={field.onChange}
                            onBlur={field.onBlur}
                            name={field.name}
                            ref={field.ref}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="address.zipCode"
                    render={({ field }) => (
                      <FormItem>
                        <div className="text-sm font-medium">ZIP Code</div>
                        <FormControl>
                          <Input
                            placeholder="12345"
                            value={field.value ?? ""}
                            onChange={field.onChange}
                            onBlur={field.onBlur}
                            name={field.name}
                            ref={field.ref}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <div className="flex justify-end space-x-2 pt-4">
                  <Button
                    type="button"
                    variant="secondary"
                    onClick={handleCancel}
                    disabled={
                      isSubmitting ||
                      form.formState.isSubmitting ||
                      !contactInfoSchema.safeParse(info).success
                    }
                  >
                    Cancel
                  </Button>
                  <Button
                    type="submit"
                    // disabled={
                    //   !form.formState.isValid ||
                    //   isSubmitting ||
                    //   form.formState.isSubmitting
                    // }
                    variant={"brutalist"}
                    aria-label="Save changes"
                  >
                    {isSubmitting ? "Saving..." : "Save Changes"}
                  </Button>
                </div>
              </form>
            </Form>
          ) : (
            <div className="space-x-4 print:hidden flex flex-row justify-between items-center">
              <ContactSummary info={info} />
              <Button
                variant="brutalist"
                size="sm"
                onClick={() => {
                  form.reset(info);
                  setIsEditing(true);
                }}
              >
                <Edit2 className="h-4 w-4" />
              </Button>
            </div>
          )}
        </CardContent>
      </Card>
    );
  },
);

ContactInfo.displayName = "ContactInfo";



# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/EditNotes.tsx
"use client";

import { useState, useRef, type KeyboardEvent } from "react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Check, Pencil, X } from "lucide-react";

interface InlineEditTextareaProps {
  initialValue: string;
  onSave: (value: string) => void;
  placeholder?: string;
  className?: string;
  disabled?: boolean;
}

export function InlineEditTextarea({
  initialValue = "",
  onSave,
  placeholder = "Enter notes...",
  className = "",
  disabled = false,
}: InlineEditTextareaProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [value, setValue] = useState(initialValue);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleEdit = () => {
    if (disabled) return;
    setIsEditing(true);
    // Focus the textarea after rendering
    setTimeout(() => {
      textareaRef.current?.focus();
    }, 0);
  };

  const handleSave = () => {
    onSave(value);
    setIsEditing(false);
  };

  const handleCancel = () => {
    setValue(initialValue);
    setIsEditing(false);
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSave();
    } else if (e.key === "Escape") {
      handleCancel();
    }
  };

  return (
    <div className={`relative w-full ${className}`}>
      {isEditing ? (
        <div className="w-full space-y-2">
          <Textarea
            ref={textareaRef}
            value={value}
            onChange={(e) => setValue(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder={placeholder}
            className="min-h-[100px] p-2 pr-20 w-full"
            autoFocus
          />
          <div className="absolute top-2 right-2 flex space-x-4">
            <Button
              size="icon"
              variant="ghost"
              onClick={handleCancel}
              className="h-8 w-8 print:hidden"
              aria-label="Cancel editing"
            >
              <X className="h-4 w-4" />
            </Button>
            <Button
              size="icon"
              onClick={handleSave}
              className="h-8 w-8 print:hidden"
              aria-label="Save changes"
              variant={value ? "brutalist" : "destructive"}
            >
              <Check className="h-4 w-4" />
            </Button>
          </div>
        </div>
      ) : (
        <div className="group relative min-h-[40px] w-full rounded-md border border-input bg-background p-3">
          <div className="whitespace-pre-wrap pr-12">
            {value || (
              <p className="text-muted-foreground print:hidden">
                {placeholder}
              </p>
            )}
          </div>
          <Button
            size="icon"
            variant="ghost"
            onClick={handleEdit}
            className="absolute right-2 top-2 h-8 w-8 print:hidden"
            aria-label="Edit text"
          >
            <Pencil className="h-4 w-4" />
          </Button>
        </div>
      )}
    </div>
  );
}



# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/NewItemForm.tsx
// frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/NewItemForm.tsx
import { useState, useMemo, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Drawer,
  DrawerClose,
  DrawerContent,
  DrawerFooter,
  DrawerHeader,
  DrawerOverlay,
  DrawerTitle,
  DrawerTrigger,
} from "@/components/ui/drawer";
import { Plus, ListPlus, Loader2 } from "lucide-react";
import { useMediaQuery } from "@/hooks/use-media-query";
import {
  LineItem,
  MaterialItem,
} from "@/../../backend/functions/src/common/schemas/quote_schema";
import { allowedCurrencySchemaType } from "@/../../backend/functions/src/common/schemas/common_schemas";
import { ROLES_THAT_ADD } from "@/../../backend/functions/src/common/const"; // Import ROLES_THAT_ADD
import { ROLES } from "@/../../backend/functions/src/common/schemas/common_schemas"; // Import ROLES type
import { EntryItf } from "@/../../backend/functions/src/common/common_types"; // Import type for cache
import { formatCurrency, currencyToSymbol } from "@/lib/utils";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { useId } from "react";
import { NumericInput } from "@/components/InputUnit";
import * as z from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";

// --- Updated Props Interface ---
interface NewItemFormProps {
  onAddItem: (item: LineItem[]) => void;
  currency: allowedCurrencySchemaType; // Currency is required
  inventoryCache: Record<string, EntryItf>; // Receive inventory cache as prop
  userRole: (typeof ROLES)[number]; // Add userRole prop
}

// Helper function (no changes)
const getLaborDescription = (
  laborType: "quantity" | "fixed" | "percentage",
  laborRate: number,
  currencySymbol: string, // Added currency symbol for clarity
) => {
  const formattedRate = formatCurrency(laborRate, currencySymbol); // Use util
  switch (laborType) {
    case "percentage":
      return `↳ service fee of ${laborRate}% of line total`;
    case "fixed":
      return `↳ service fee fixed at ${formattedRate}`; // Use formatted rate
    case "quantity":
      return `↳ service fee of ${formattedRate} per unit`; // Use formatted rate
    default:
      return "";
  }
};

// Form schema (no changes)
const itemFormSchema = z
  .object({
    itemType: z.enum(["custom", "inventory"]),
    inventoryId: z.string().optional(),
    description: z.string().max(254, "Max 254 characters"),
    inventoryMaterialName: z
      .string()
      .max(254, "Max 254 characters")
      .optional(),
    quantity: z.number().min(0.01, "Quantity must be greater than 0"),
    unitPrice: z.number().min(0.01, "Unit price must be greater than 0"),
    dimensionType: z.string(),
    length: z.number().optional(),
    width: z.number().optional(),
    laborType: z.enum(["null", "percentage", "fixed", "quantity"]),
    laborRate: z.number().min(0).optional(),
  })
  .refine(
    (data) => {
      if (data.dimensionType.startsWith("area")) {
        return data.length !== undefined && data.length > 0;
      }
      return true;
    },
    { message: "Length > 0 required for area", path: ["length"] },
  )
  .refine(
    (data) => {
      if (data.dimensionType.startsWith("area")) {
        return data.width !== undefined && data.width > 0;
      }
      return true;
    },
    { message: "Width > 0 required for area", path: ["width"] },
  )
  .refine(
    (data) => {
      if (data.laborType !== "null") {
        return data.laborRate !== undefined && data.laborRate >= 0; // Allow 0 rate
      }
      return true;
    },
    { message: "Labor rate required", path: ["laborRate"] },
  )
  .refine(
    (data) => {
      if (data.itemType === "custom") {
        return data.description?.trim() !== "";
      }
      return true;
    },
    {
      message: "Description required for custom items",
      path: ["description"],
    },
  );

type ItemFormValues = z.infer<typeof itemFormSchema>;

// --- Main Component (Uses Props) ---
export function NewItemForm({
  onAddItem,
  currency,
  inventoryCache, // Use prop
  userRole, // Use prop
}: NewItemFormProps) {
  const [isOpen, setIsOpen] = useState(false);
  const isDesktop = useMediaQuery("(min-width: 1340px)");
  const [isLoadingInventory, setIsLoadingInventory] = useState(false); // Keep local loading state if needed

  // Check if user has permission to add
  const canAdd = useMemo(() => ROLES_THAT_ADD.has(userRole), [userRole]);

  const form = useForm<ItemFormValues>({
    resolver: zodResolver(itemFormSchema),
    defaultValues: {
      itemType: "custom",
      description: "",
      quantity: 1, // Default quantity to 1
      unitPrice: 0,
      inventoryMaterialName: "",
      dimensionType: "unit-unit",
      length: undefined, // Default to undefined
      width: undefined, // Default to undefined
      laborType: "null",
      laborRate: 0,
    },
  });

  // Convert inventory items using the passed `inventoryCache` and `currency` props
  const inventoryMaterials = useMemo(() => {
    if (!inventoryCache || !currency) return []; // Check currency too

    return (
      Object.entries(inventoryCache)
        // Filter by the currency prop
        .filter(([, item]) => item.details.currency === currency)
        .map(([id, item]) => ({
          id,
          description: `${item.name}`, // Use top-level name
          unitPrice: item.details.unitPrice || 0,
          dimensions: item.details.dimensions || {
            type: "unit" as const,
            unitLabel: "unit" as const,
          },
          currency: item.details.currency as allowedCurrencySchemaType,
          labor: item.details.labor || null,
        }))
    );
    // Depend on props
  }, [inventoryCache, currency]);

  // handleMaterialSelect remains largely the same, uses inventoryCache prop
  const handleMaterialSelect = (materialId: string) => {
    const itemType = materialId === "" ? "custom" : "inventory";
    form.setValue("itemType", itemType);
    form.setValue("inventoryId", materialId);
    form.resetField("description"); // Clear custom description when selecting inventory

    if (materialId === "") {
      // Reset to custom item defaults (keep quantity)
      form.setValue("unitPrice", 0);
      form.setValue("dimensionType", "unit-unit");
      form.setValue("length", undefined);
      form.setValue("width", undefined);
      form.setValue("laborType", "null");
      form.setValue("laborRate", 0);
      form.setValue("inventoryMaterialName", "");
    } else {
      // Find the selected material in the inventoryCache prop
      const inventoryItem = inventoryCache[materialId];
      if (inventoryItem) {
        form.setValue("inventoryMaterialName", inventoryItem.name || "");
        // Don't set description field for inventory items
        form.setValue("unitPrice", inventoryItem.details.unitPrice || 0);
        const dimensions = inventoryItem.details.dimensions || {
          type: "unit",
          unitLabel: "unit",
        };
        form.setValue(
          "dimensionType",
          `${dimensions.type}-${dimensions.unitLabel}`,
        );
        // Reset length/width if switching to unit type
        if (dimensions.type === "unit") {
          form.setValue("length", undefined);
          form.setValue("width", undefined);
        }

        if (inventoryItem.details.labor) {
          form.setValue("laborType", inventoryItem.details.labor.laborType);
          form.setValue("laborRate", inventoryItem.details.labor.laborRate);
        } else {
          form.setValue("laborType", "null");
          form.setValue("laborRate", 0);
        }
      }
    }
  };

  const calculateAreaQuantity = (length?: number, width?: number) => {
    if (length === undefined || width === undefined) return 0;
    console.log("Calculating area quantity:", length, width);
    return Number((length * width).toFixed(2));
  };

  const { watch } = form;
  const formValues = watch();
  const quantity = formValues.quantity || 0;
  const unitPrice = formValues.unitPrice || 0;
  const laborType = formValues.laborType;
  const laborRate = formValues.laborRate || 0;

  const materialTotal = quantity * unitPrice;

  const calculateLaborPrice = (): number => {
    if (laborType === "null" || laborRate === undefined) return 0;
    try {
      switch (laborType) {
        case "percentage":
          return Number((materialTotal * (laborRate / 100)).toFixed(2));
        case "fixed":
          return Number(laborRate.toFixed(2));
        case "quantity":
          return Number((laborRate * quantity).toFixed(2));
        default:
          return 0;
      }
    } catch (error) {
      console.error("Error calculating labor price:", error);
      return 0;
    }
  };

  const laborTotal = calculateLaborPrice();
  const grandTotal = materialTotal + laborTotal;

  const handleAddItem = async () => {
    const isValid = await form.trigger();
    console.log("Form validation result:", isValid, form.formState.errors);
    if (!isValid) return;

    const values = form.getValues();
    const [dimensionType, unitLabel] = values.dimensionType.split("-");

    // Create line item
    const lineItem: LineItem = {
      id: crypto.randomUUID(),
      parentId: "root",
      quantity: values.quantity,
      dimensions: {
        length: values.length, // Keep undefined if not set
        width: values.width, // Keep undefined if not set
      },
      // Use inventoryMaterialName if available, otherwise custom description
      description: values.description,
      material: {
        id: crypto.randomUUID(), // Or use inventoryId if needed upstream?
        description: values.inventoryMaterialName || "", //values.description, // Name for the material itself
        unitPrice: values.unitPrice,
        dimensions: {
          type: dimensionType as "area" | "unit",
          unitLabel: unitLabel as "m²" | "ft²" | "unit",
        },
        currency: currency, // Use prop
        labor: null, // Labor is handled as a separate line item now
      },
    };

    const items = [lineItem];
    console.log("Line item created:", items);

    // Add labor line item if laborType is not 'null'
    if (values.laborType !== "null" && values.laborRate !== undefined) {
      const laborQuantity =
        values.laborType === "quantity" ? values.quantity : 1;
      const laborUnitPrice = laborTotal / laborQuantity; // Calculate unit price for labor

      if (!isNaN(laborUnitPrice) && isFinite(laborUnitPrice)) {
        const laborItem: LineItem = {
          id: crypto.randomUUID(),
          parentId: lineItem.id, // Link labor to its material item
          quantity: laborQuantity,
          description: getLaborDescription(
            values.laborType as "percentage" | "fixed" | "quantity",
            values.laborRate || 0,
            currency,
          ),
          material: {
            id: crypto.randomUUID(),
            description: "Labor", // Generic description for labor material
            unitPrice: laborUnitPrice,
            currency: currency, // Use prop
            dimensions: { type: "unit", unitLabel: "unit" },
            labor: null,
          },
        };
        items.push(laborItem);
      } else {
        console.warn(
          "Calculated labor unit price is invalid, skipping labor item.",
        );
      }
    }

    onAddItem(items);
    // Reset form to initial defaults, keeping quantity=1
    form.reset({
      ...form.getValues(), // Keep current values for a moment
      itemType: "custom",
      description: "",
      quantity: 0, // Reset quantity to 0
      unitPrice: 0,
      inventoryMaterialName: "",
      dimensionType: "unit-unit",
      length: undefined,
      width: undefined,
      laborType: "null",
      laborRate: 0,
      inventoryId: "",
    });
    setIsOpen(false);
  };

  const formContent = (
    <Form {...form}>
      <form
        onSubmit={(e) => {
          e.preventDefault(); // Prevent default form submission
          handleAddItem();
        }}
        className="space-y-4 px-4 flex flex-col flex-grow overflow-y-auto" // Allow vertical scroll
        id="newItemForm" // Add ID for submitting from outside button
      >
        {/* Item Type Select */}
        <FormField
          control={form.control}
          name="inventoryId" // Bind to inventoryId to control selection
          render={({ field }) => (
            <FormItem className="space-y-2">
              <FormLabel>Select Item</FormLabel>
              <FormControl>
                <select
                  id="materialSelect"
                  className="w-full h-10 px-3 rounded-md border border-input bg-background"
                  onChange={(e) => {
                    handleMaterialSelect(e.target.value);
                    field.onChange(e.target.value); // Update form state for inventoryId
                  }}
                  value={field.value || ""} // Use inventoryId value
                  disabled={isLoadingInventory || !canAdd} // Disable if loading or no permission
                >
                  <option value="">-- Custom Item --</option>
                  {isLoadingInventory ? (
                    <option disabled>Loading inventory...</option>
                  ) : (
                    inventoryMaterials.map((material) => (
                      <option key={material.id} value={material.id}>
                        {material.description} -{" "}
                        {formatCurrency(material.unitPrice, currency)}
                      </option>
                    ))
                  )}
                </select>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Description (Only enabled for custom) */}
        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem className="space-y-2">
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Input
                  placeholder="Enter item description"
                  {...field}
                  disabled={!canAdd} // Disable if no permission
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Unit Price (Only enabled for custom) */}
        <FormField
          control={form.control}
          name="unitPrice"
          render={({ field }) => (
            <FormItem className="space-y-2">
              <FormLabel>Unit Price</FormLabel>
              <FormControl>
                <NumericInput
                  value={field.value.toString()}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                    const value = e.target.value;
                    field.onChange(Number.parseFloat(value) || 0);
                  }}
                  prefix={currencyToSymbol(currency || "")}
                  placeholder="0.00"
                  className="peer text-center" // Align center
                  disabled={
                    form.getValues("itemType") === "inventory" || !canAdd
                  } // Disable if inventory or no permission
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Dimension Type (Only enabled for custom) */}
        <FormField
          control={form.control}
          name="dimensionType"
          render={({ field }) => (
            <FormItem className="space-y-2">
              <FormLabel>Dimension Type</FormLabel>
              <FormControl>
                <RadioGroup
                  className="flex flex-wrap gap-2"
                  value={field.value}
                  onValueChange={(value) => {
                    field.onChange(value);
                    // Recalculate quantity if switching to area
                    if (value.startsWith("area")) {
                      const length = form.getValues("length");
                      const width = form.getValues("width");
                      const quantity = calculateAreaQuantity(length, width);
                      form.setValue("quantity", quantity);
                    } else {
                      // If switching back to unit, maybe reset quantity?
                      // form.setValue("quantity", 1); // Optional reset
                      form.setValue("length", undefined);
                      form.setValue("width", undefined);
                    }
                  }}
                  disabled={
                    form.getValues("itemType") === "inventory" || !canAdd
                  } // Disable if inventory or no permission
                >
                  {[
                    /* ... dimension options ... */
                    { value: "unit-unit", label: "Unit" },
                    { value: "area-m²", label: "Area (m²)" },
                    { value: "area-ft²", label: "Area (ft²)" },
                  ].map((item) => (
                    <div
                      key={item.value}
                      className="border-input hover:bg-accent/50 has-[data-state=checked]:border-primary has-[data-state=checked]:bg-secondary/50 relative flex flex-col items-start rounded-md border p-2 shadow-xs outline-none"
                    >
                      <div className="flex items-center gap-2">
                        <RadioGroupItem
                          value={item.value}
                          id={`dim-${item.value}`}
                          className="after:absolute after:inset-0"
                          disabled={!canAdd} // Disable radio item
                        />
                        <Label
                          htmlFor={`dim-${item.value}`}
                          className={`cursor-pointer ${
                            !canAdd ? "cursor-not-allowed opacity-50" : ""
                          }`} // Style label when disabled
                        >
                          {item.label}
                        </Label>
                      </div>
                    </div>
                  ))}
                </RadioGroup>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Length/Width Inputs (Conditional) */}
        {form.watch("dimensionType").startsWith("area") && (
          <div className="grid grid-cols-2 gap-4">
            <FormField
              control={form.control}
              name="length"
              render={({ field }) => (
                <FormItem className="space-y-2">
                  <FormLabel>Length</FormLabel>
                  <FormControl>
                    <NumericInput
                      // min="0.01"
                      // step="0.01"
                      className="peer text-center"
                      {...field}
                      value={field.value ?? ""} // Handle undefined
                      onChange={(e) => {
                        const length = Number(e.target.value);
                        console.log("Length:", length);
                        field.onChange(length || undefined); // Store undefined if empty/invalid
                        const width = form.getValues("width");
                        const areaQuantity = calculateAreaQuantity(
                          length,
                          width,
                        );
                        form.setValue("quantity", areaQuantity);
                        form.setValue("length", length); // Update length in form state
                      }}
                      disabled={!canAdd} // Disable if no permission
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="width"
              render={({ field }) => (
                <FormItem className="space-y-2">
                  <FormLabel>Width</FormLabel>
                  <FormControl>
                    <NumericInput
                      // type="number"
                      // min="0.01"
                      // step="0.01"
                      className="peer text-center"
                      {...field}
                      value={field.value ?? ""} // Handle undefined
                      onChange={(e) => {
                        const width = Number(e.target.value);
                        field.onChange(width || undefined); // Store undefined if empty/invalid
                        const length = form.getValues("length");
                        const areaQuantity = calculateAreaQuantity(
                          length,
                          width,
                        );
                        form.setValue("quantity", areaQuantity);
                        form.setValue("width", width); // Update width in form state
                      }}
                      disabled={!canAdd} // Disable if no permission
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            {/* Display calculated area */}
            <div className="col-span-2 text-right text-sm font-medium text-muted-foreground">
              Area: {form.watch("quantity")}{" "}
              {form.watch("dimensionType").split("-")[1] || ""}
            </div>
          </div>
        )}

        {/* Quantity (Only enabled for unit dimension) */}
        {!form.watch("dimensionType").startsWith("area") && (
          <FormField
            control={form.control}
            name="quantity"
            render={({ field }) => (
              <FormItem className="space-y-2">
                <FormLabel>Quantity</FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    // min="0.01"
                    // step="0.01"
                    className="peer text-center"
                    {...field}
                    value={field.value} // Keep as number
                    onChange={(e) =>
                      field.onChange(Number(e.target.value) || 0)
                    } // Ensure number
                    disabled={
                      (form.getValues("itemType") === "inventory" &&
                        form.watch("dimensionType").startsWith("area")) ||
                      !canAdd // Disable if inventory & area based OR no permission
                    }
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        )}

        {/* Labor Type */}
        <FormField
          control={form.control}
          name="laborType"
          render={({ field }) => (
            <FormItem className="space-y-2">
              <FormLabel>Service Fee</FormLabel>
              <FormControl>
                <RadioGroup
                  className="flex flex-wrap gap-2"
                  value={field.value}
                  onValueChange={field.onChange}
                  disabled={
                    form.getValues("itemType") === "inventory" || !canAdd
                  } // Disable if inventory or no permission
                >
                  {[
                    /* ... labor options ... */
                    { value: "null", label: "No fee" },
                    { value: "percentage", label: "%" },
                    { value: "fixed", label: "Flat" },
                    { value: "quantity", label: "Per Unit" },
                  ].map((item) => (
                    <div
                      key={item.value}
                      className="border-input hover:bg-accent/50 has-[data-state=checked]:border-primary has-[data-state=checked]:bg-secondary/50 relative flex flex-col items-start rounded-md border p-2 shadow-xs outline-none"
                    >
                      <div className="flex items-center gap-2">
                        <RadioGroupItem
                          value={item.value}
                          id={`labor-${item.value}`}
                          className="after:absolute after:inset-0"
                          disabled={!canAdd} // Disable radio item
                        />
                        <Label
                          htmlFor={`labor-${item.value}`}
                          className={`cursor-pointer ${
                            !canAdd ? "cursor-not-allowed opacity-50" : ""
                          }`} // Style label when disabled
                        >
                          {item.label}
                        </Label>
                      </div>
                    </div>
                  ))}
                </RadioGroup>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Labor Rate (Conditional) */}
        {form.watch("laborType") !== "null" && (
          <FormField
            control={form.control}
            name="laborRate"
            render={({ field }) => (
              <FormItem className="space-y-2">
                <FormLabel>
                  {form.watch("laborType") === "percentage"
                    ? "Labor %"
                    : "Labor Rate"}
                </FormLabel>
                <FormControl>
                  <NumericInput
                    value={field.value?.toString() ?? "0"} // Handle optional value
                    onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                      field.onChange(Number(e.target.value) || 0); // Ensure number
                    }}
                    prefix={
                      form.watch("laborType") === "percentage"
                        ? ""
                        : currencyToSymbol(currency || "")
                    }
                    suffix={
                      form.watch("laborType") === "percentage" ? "%" : ""
                    }
                    placeholder="0.00"
                    className="peer text-center" // Align center
                    disabled={
                      form.getValues("itemType") === "inventory" || !canAdd
                    } // Disable if inventory or no permission
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        )}

        {/* Total Display */}
        <div className="text-sm font-semibold text-right mt-auto pt-4 border-t">
          {" "}
          {/* Push totals down */}
          <div className="flex justify-between">
            <span>Material:</span>
            <span>{formatCurrency(materialTotal, currency)}</span>
          </div>
          <div className="flex justify-between">
            <span>Service Fee:</span>
            <span>{formatCurrency(laborTotal, currency)}</span>
          </div>
          <div className="flex justify-between border-t mt-2 pt-2 text-base">
            <span>Total:</span>
            <span>{formatCurrency(grandTotal, currency)}</span>
          </div>
        </div>
      </form>
    </Form>
  );

  if (isDesktop) {
    return (
      <div
        id="quote-add-item-form"
        // Ensure fixed positioning doesn't overlap printable area
        className="print-hide fixed bottom-4 right-4 z-50 bg-background border rounded-lg p-4 w-[400px] shadow-lg max-h-[calc(100vh-4rem)] flex flex-col" // Max height and flex column
      >
        <div className="mb-4 flex-shrink-0">
          {" "}
          {/* Prevent header shrink */}
          <h3 className="text-lg font-semibold">Add New Item</h3>
        </div>
        <div className="flex-grow overflow-y-auto pr-2">
          {" "}
          {/* Scrollable content */}
          {formContent}
        </div>
        <div className="flex justify-end gap-2 mt-4 flex-shrink-0">
          {" "}
          {/* Prevent footer shrink */}
          <Button
            onClick={form.handleSubmit(handleAddItem)}
            disabled={isLoadingInventory || !canAdd} // Disable if loading or no permission
            variant={"brutalist"}
            type="button" // Use type="button" to prevent default form submission if inside a <form>
            title={!canAdd ? "You don't have permission to add items" : ""} // Add tooltip
          >
            {isLoadingInventory ? (
              <>
                {" "}
                <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Loading...{" "}
              </>
            ) : (
              <>
                {" "}
                <Plus className="mr-2" size={16} /> Add Item{" "}
              </>
            )}
          </Button>
        </div>
      </div>
    );
  }

  // Mobile Drawer remains similar
  return (
    <div
      id="quote-add-item-form"
      className="relative mb-6 print-hide print:m-0"
    >
      <Drawer open={isOpen} onOpenChange={setIsOpen}>
        <DrawerTrigger asChild>
          <Button
            size="sm"
            className="w-full gap-2 print-hide"
            variant={"brutalist"}
            disabled={!canAdd} // Disable trigger button
            title={!canAdd ? "You don't have permission to add items" : ""} // Add tooltip
          >
            <ListPlus size={16} /> Add New Item
          </Button>
        </DrawerTrigger>
        <DrawerOverlay className="bg-black/40" />
        <DrawerContent className="flex flex-col max-h-[96%] rounded-t-[10px] bg-background">
          <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted flex-shrink-0" />{" "}
          {/* Drag handle */}
          <div className="max-w-md w-full mx-auto flex flex-col overflow-hidden p-4 rounded-t-[10px] flex-grow">
            <DrawerHeader className="flex-shrink-0">
              <DrawerTitle>Add New Item</DrawerTitle>
            </DrawerHeader>
            {formContent}
            <DrawerFooter className="pt-4 flex-shrink-0">
              <Button
                type="button" // Important for drawers
                onClick={form.handleSubmit(handleAddItem)}
                disabled={isLoadingInventory || !canAdd} // Disable add button
                variant={"brutalist"}
                className="w-full" // Make button full width
                title={!canAdd ? "You don't have permission to add items" : ""} // Add tooltip
              >
                {isLoadingInventory ? (
                  <>
                    {" "}
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />{" "}
                    Loading...{" "}
                  </>
                ) : (
                  <>
                    {" "}
                    <Plus className="mr-2" size={16} /> Add Item{" "}
                  </>
                )}
              </Button>
              <DrawerClose asChild>
                <Button variant="outline" className="w-full">
                  Cancel
                </Button>
              </DrawerClose>
            </DrawerFooter>
          </div>
        </DrawerContent>
      </Drawer>
    </div>
  );
}



# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/TEST_MATERIALS.tsx
import { materialItemSchemaType } from "@/../../backend/functions/src/common/schemas/InventorySchema";

// // Update TEST_MATERIALS
// export const TEST_MATERIALS: materialItemSchemaType[] = [
//   {
//     id: "mat-001",
//     description: "Standard Interior Paint (1 Gallon)",
//     unitPrice: 45.99,
//     dimensions: {
//       type: "unit",
//       unitLabel: "unit",
//     },
//     labor: {
//       id: "lab-001",
//       description: "Paint Application",
//       laborRate: 35.0,
//       laborType: "quantity",
//     },
//   },
//   {
//     id: "mat-002",
//     description: "Premium Exterior Paint (1 Gallon)",
//     unitPrice: 65.99,
//     dimensions: {
//       type: "unit",
//       unitLabel: "unit",
//     },
//     labor: {
//       id: "lab-002",
//       description: "Exterior Paint Application",
//       laborRate: 45.0,
//       laborType: "quantity",
//     },
//   },
//   {
//     id: "mat-003",
//     description: "Drywall Sheet 4x8ft",
//     unitPrice: 15.5,
//     dimensions: {
//       type: "unit",
//       unitLabel: "unit",
//     },
//     labor: {
//       id: "lab-003",
//       description: "Drywall Installation",
//       laborRate: 25,
//       laborType: "percentage",
//     },
//   },
//   {
//     id: "mat-004",
//     description: "Window Cleaning Service",
//     unitPrice: 10.0,
//     dimensions: {
//       type: "unit",
//       unitLabel: "unit",
//     },
//     labor: {
//       id: "lab-004",
//       description: "Basic Window Cleaning",
//       laborRate: 150.0,
//       laborType: "fixed",
//     },
//   },
//   {
//     id: "mat-005",
//     description: "Door Lock Installation Kit",
//     unitPrice: 85.99,
//     dimensions: {
//       type: "unit",
//       unitLabel: "unit",
//     },
//     labor: {
//       id: "lab-005",
//       description: "Lock Installation",
//       laborRate: 65.0,
//       laborType: "quantity",
//     },
//   },
//   {
//     id: "mat-006",
//     description: "Hardwood Flooring",
//     unitPrice: 65.99,
//     dimensions: {
//       type: "area",
//       unitLabel: "m²",
//     },
//     labor: {
//       id: "lab-006",
//       description: "Flooring Installation",
//       laborRate: 45.0,
//       laborType: "quantity",
//     },
//   },
// ];



# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/TaxForm.tsx
"use client";

import * as React from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import {
  Drawer,
  DrawerContent,
  DrawerHeader,
  DrawerTitle,
  DrawerClose,
  DrawerFooter,
  DrawerTrigger,
} from "@/components/ui/drawer";
import { useMediaQuery } from "@/hooks/use-media-query";
import { cn } from "@/lib/utils";
import { Plus } from "lucide-react";

interface TaxFormProps {
  onSubmit: (tax: number) => void;
  disabled?: boolean;
}

export function TaxForm({ onSubmit, disabled }: TaxFormProps) {
  const [adjustmentTax, setAdjustmentTax] = React.useState(0);
  const [isOpen, setIsOpen] = React.useState(false);
  const isMobile = useMediaQuery("(max-width: 768px)");

  const taxFormFields = (
    <form
      id="taxForm"
      onSubmit={(e) => {
        e.preventDefault();
        onSubmit(adjustmentTax);
      }}
      className="space-y-4 print-hide"
    >
      <div
        className={cn(
          "gap-4 items-center",
          !isMobile && "grid grid-cols-[2fr_2fr_1fr_auto]" // Added auto column for button
        )}
      >
        <div></div>
        <Label className="text-right" htmlFor="adjustmentTax">
          Tax:
        </Label>
        <div className="relative">
          <Input
            className="peer  text-center"
            placeholder="Enter tax percentage"
            id="adjustmentTax"
            type="number"
            min="0"
            step="0.01"
            max="100"
            value={adjustmentTax}
            onChange={(e) => setAdjustmentTax(Number(e.target.value))}
            disabled={disabled}
            required
          />
          <span className="pointer-events-none absolute inset-y-0 end-0 flex items-center justify-center pe-3 text-sm text-muted-foreground peer-disabled:opacity-50">
            %
          </span>
        </div>
        {!isMobile && (
          <Button type="submit" className="self-start" disabled={disabled}>
            <Plus />
          </Button>
        )}
      </div>
    </form>
  );
  if (!isMobile) {
    return <div className="mobile-form print-hide">{taxFormFields}</div>;
  }
  return (
    <Drawer open={isOpen} onOpenChange={setIsOpen}>
      <DrawerTrigger asChild>
        <Button className="w-full" variant="secondary" disabled={disabled}>
          Set Tax Rate
        </Button>
      </DrawerTrigger>

      <DrawerContent>
        <DrawerHeader>
          <DrawerTitle>Set Tax Rate</DrawerTitle>
          <DrawerClose
          //   onClick={() => {
          //     setActiveDrawer(null);
          //   }}
          />
        </DrawerHeader>
        {taxFormFields}
        <DrawerFooter>
          <Button
            type="submit"
            form="taxForm"
            className="w-full"
            onClick={() => setIsOpen(false)}
          >
            <Plus /> Add
          </Button>
          <Button variant="outline" onClick={() => setIsOpen(false)}>
            Cancel
          </Button>
        </DrawerFooter>
      </DrawerContent>
    </Drawer>
  );
}



# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/header.tsx
import Image from "next/image";
import { Building2, Mail, Phone } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { contactInfoSchemaType } from "../../../../../../../../backend/functions/src/common/schemas/common_schemas";

interface QuoteHeaderProps {
  contactInfo?: contactInfoSchemaType;
  logo?: string | null;
}

export function QuoteHeader({
  logo = "/placeholder.svg?height=40&width=120",
  contactInfo,
}: QuoteHeaderProps) {
  return (
    <div className="print:shadow-none print:max-w-none print:mx-0 print:w-full border-b p-4">
      <div className="flex flex-wrap justify-between items-center gap-4">
        {/* logo and address */}
        <div className="flex items-center space-x-3">
          <Image
            src={logo || "/placeholder.svg"}
            alt={`${contactInfo?.name || "Company"} logo`}
            width={40}
            height={40}
            className="h-16 w-auto"
          />
          <div className="flex flex-col">
            <h1 className="text-2xl font-bold tracking-tight text-primary">
              {contactInfo?.name || "Acme Industries"}
            </h1>
            {contactInfo?.address && (
              <div className="mt-2 text-xs text-muted-foreground hover:text-primary flex flex-wrap gap-2">
                <span>{contactInfo.address.street},</span>
                <span>
                  {contactInfo.address.city}, {contactInfo.address.state}{" "}
                  {contactInfo.address.zipCode}
                </span>
              </div>
            )}
          </div>
        </div>

        <div className="flex justify-between h-full grow text-xs text-muted-foreground hover:text-primary  sm:flex-col sm:items-end sm:space-y-5">
          <div className="flex items-center justify-end space-x-2 ">
            <Phone className="h-4 w-4" />
            <span>{contactInfo?.phone || "(555) 123-4567"}</span>
          </div>
          <div className="flex items-center justify-end space-x-2 grow">
            <Mail className="h-4 w-4" />
            <span>{contactInfo?.email || "billing@acmeindustries.com"}</span>
          </div>
        </div>
      </div>
      {/* <Separator className="my-6" /> */}
    </div>
  );
}



# frontend/src/app/(auth)/journal/journal-types/quote/subcomponents/quoteStatus.tsx
import { Button } from "@/components/ui/button";
import {
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenu,
} from "@/components/ui/dropdown-menu";

type StatusType = "pending" | "accepted" | "rejected";

const statusStyles: Record<StatusType, string> = {
  pending:
    "bg-yellow-100 border-yellow-500 hover:bg-yellow-100 dark:bg-yellow-900/50 dark:border-yellow-500 dark:hover:bg-yellow-900/50",
  accepted:
    "bg-green-100 border-green-500 hover:bg-green-100 dark:bg-green-900/50 dark:border-green-500 dark:hover:bg-green-900/50",
  rejected:
    "bg-red-100 border-red-500 hover:bg-red-100 dark:bg-red-900/50 dark:border-red-500 dark:hover:bg-red-900/50",
};

interface QuoteStatusProps {
  qstatus: StatusType;
  setStatus: (status: StatusType) => void;
}

export function QuoteStatus({ qstatus, setStatus }: QuoteStatusProps) {
  return (
    qstatus && (
      <div className="flex items-center gap-2">
        <div className="hidden md:flex gap-2">
          {(Object.keys(statusStyles) as StatusType[]).map((status) => (
            <Button
              key={status}
              variant="outline"
              size="sm"
              className={`rounded-full ${
                qstatus === status ? statusStyles[status] : ""
              }`}
              onClick={() => setStatus(status)}
            >
              {status.charAt(0).toUpperCase() + status.slice(1)}
            </Button>
          ))}
        </div>
        <div className="md:hidden">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="outline"
                size="sm"
                className={`rounded-full ${statusStyles[qstatus]}`}
              >
                {qstatus.charAt(0).toUpperCase() + qstatus.slice(1)}
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {(Object.keys(statusStyles) as StatusType[]).map((status) => (
                <DropdownMenuItem
                  key={status}
                  onClick={() => setStatus(status)}
                >
                  {status.charAt(0).toUpperCase() + status.slice(1)}
                </DropdownMenuItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
    )
  );
}



# frontend/src/app/(auth)/journal/layout.tsx
"use client";
// import { useJournalStore } from "@/lib/store/journalStore";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { JournalProvider, useJournalContext } from "@/context/JournalContext"; // Import provider and hook
import { useSearchParams } from "next/navigation";
import React, { Suspense } from "react"; // Import Suspense
import Link from "next/link";
import { Journal } from "@/lib/custom_types";

export default function JournalLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  // const currentJournal = useJournalStore((state) => state.currentJournal);

  return (
    // Wrap with Suspense because JournalProvider uses useSearchParams
    <Suspense fallback={<div>Loading journal context...</div>}>
      <JournalProvider>
        <div className="flex flex-col w-full">
          <JournalBreadcrumb /> {/* Render breadcrumbs that use the context */}
          <div className="flex-grow">{children}</div>
        </div>
      </JournalProvider>
    </Suspense>
  );
}
function JournalBreadcrumb() {
  const { journal } = useJournalContext(); // Use context hook
  if (!journal) return null; // Don't render breadcrumbs if no journal

  return (
    <div className="pt-2">
      {/* TODO: improve these breadcrumbs for longer names */}
      <Breadcrumb className="ml-2 overflow-hidden whitespace-nowrap">
        <BreadcrumbList className="overflow-hidden whitespace-nowrap">
          <BreadcrumbItem>
            <BreadcrumbLink asChild>
              <Link href="/">Home</Link>
            </BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbSeparator />
          <BreadcrumbItem className="truncate">
            <BreadcrumbLink asChild>
              <Link href={`/journal?jid=${journal.id}`}>{journal.title}</Link>
            </BreadcrumbLink>
          </BreadcrumbItem>
          {/* <BreadcrumbSeparator />
          <BreadcrumbItem className="truncate flex items-center space-x-1">
            <span className="truncate">{journal.title}</span>
          </BreadcrumbItem> */}
        </BreadcrumbList>
      </Breadcrumb>
    </div>
  );
}



# frontend/src/app/(auth)/journal/page.tsx
"use client";
import { useCallback, useEffect, useState } from "react";
import { fetchDateRangeEntries, useWatchJournal } from "@/lib/db_handler";
// --- Remove specific Add forms if not needed directly ---
// import { AddLogEntryForm } from "./journal-types/cash-flow/add-cf-entry";
import { AddContributers } from "@/components/ui/add-contributors";
import { useToolbar } from "../nav_tool_handler";
import { ChatBox } from "./comp/chat";
import Link from "next/link";
import { DatePickerWithRange } from "./actions/date-pick-with-range";
import { format } from "date-fns";
import { X } from "lucide-react";
import ExportToCSV from "./actions/export-to-csv";
import { useSearchParams, useRouter } from "next/navigation"; // useRouter added
import { getAddEntryForm, getJournalIcon } from "./journal-types/config"; // Keep these utils
import { ROLES_THAT_ADD } from "@/../../backend/functions/src/common/const";
import { useAuth } from "@/lib/auth_handler";
// import { useJournalStore } from "@/lib/store/journalStore";
import { useJournalContext } from "@/context/JournalContext";
import { DBentry, Journal } from "@/lib/custom_types"; // Import Journal type
import {
  EntryType,
  ENTRY_CONFIG,
} from "@/../../backend/functions/src/common/schemas/configmap"; // Import EntryType
import { JOURNAL_TYPES } from "@/../../backend/functions/src/common/const";
import { BusinessDetailsType } from "@/../../backend/functions/src/common/schemas/JournalSchema";
import { pendingAccessSchemaType } from "@/../../backend/functions/src/common/schemas/common_schemas";
// --- Import Tabs components ---
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";

// --- Interfaces/Components (FilterRangeBadge, NotFound) remain the same ---
interface DateRange {
  from: Date;
  to: Date;
}
const FilterRangeBadge = ({
  dateRange,
  setdateRange,
}: {
  dateRange: DateRange | undefined;
  setdateRange: React.Dispatch<React.SetStateAction<DateRange | undefined>>;
}) => {
  const clearRange = () => {
    setdateRange(undefined);
  };

  return dateRange ? (
    <button
      className="text-xs font-bold rounded-md border-2 p-1 px-2"
      onClick={clearRange}
    >
      <div className="flex flex-row items-center space-x-1">
        <p>
          {format(dateRange.from, "MMM d")} - {format(dateRange.to, "MMM d")}
        </p>
        <X size={16} className="ml-1" />
      </div>
    </button>
  ) : null;
};

const NotFound = () => (
  <main className="flex flex-col items-center justify-center w-full mt-12 h-screen">
    <p className="text-2xl font-bold">Log not found :/</p>
  </main>
);

// --- Main Page ---
export default function ListJournalPage() {
  const { authUser } = useAuth();
  const [dateRange, setDateRange] = useState<DateRange | undefined>();
  const [filterList, setFilterList] = useState<DBentry[]>([]);
  const [actionButton, setActionButton] = useState<React.ReactNode>(null);
  const { setToolBar } = useToolbar();
  const { journal, loading, error } = useJournalContext();
  const params = useSearchParams();
  const router = useRouter();
  const journalId = params.get("jid");
  const typeParam = params.get("type");
  // --- State for the currently selected tab/entryType ---
  const [displayEntryType, setDisplayEntryType] = useState<EntryType | null>(
    null,
  );
  // --- State to hold available entry types for the current journal ---
  const [availableEntryTypes, setAvailableEntryTypes] = useState<EntryType[]>(
    [],
  );

  // Function to update URL when tab changes
  const updateTabInURL = useCallback(
    (newType: EntryType) => {
      // Create new URLSearchParams object from current params
      const newParams = new URLSearchParams(params.toString());
      // Update the type parameter
      newParams.set("type", newType);
      // Replace the URL without causing navigation/reload
      const newURL = `${window.location.pathname}?${newParams.toString()}`;
      router.replace(newURL, { scroll: false });
    },
    [params, router],
  );

  // Handle tab change
  const handleTabChange = useCallback(
    (value: string) => {
      const newType = value as EntryType;
      setDisplayEntryType(newType);
      updateTabInURL(newType);
    },
    [updateTabInURL],
  );

  // Effect to fetch journal data
  useEffect(() => {
    if (!journalId) {
      router.push("/");
      return;
    }
    // Reset display type when ID changes
    setDisplayEntryType(null);
    setAvailableEntryTypes([]);
  }, [journalId, router]);

  // Effect to setup Toolbar, Action Button, Available Types, and Default Tab
  useEffect(() => {
    let defaultType: EntryType | null = null;
    let typesForJournal: EntryType[] = [];

    if (journal) {
      // Determine available entry types based on journal type
      if (journal.journalType === JOURNAL_TYPES.BUSINESS) {
        typesForJournal = Object.keys(ENTRY_CONFIG).filter(
          (key) =>
            ENTRY_CONFIG[key as keyof typeof ENTRY_CONFIG].category ===
            "business",
        ) as EntryType[];
        defaultType = "cashflow"; // Default to cashflow for business
      } else if (journal.journalType === JOURNAL_TYPES.BABY) {
        typesForJournal = Object.keys(ENTRY_CONFIG).filter(
          (key) =>
            ENTRY_CONFIG[key as keyof typeof ENTRY_CONFIG].category === "baby",
        ) as EntryType[];
        defaultType = "feed"; // Default to feed for baby
      }
      setAvailableEntryTypes(typesForJournal);

      // Check if the URL parameter for tab exists and is valid
      const validTypeParam =
        typeParam && typesForJournal.includes(typeParam as EntryType)
          ? (typeParam as EntryType)
          : null;

      // Set display type based on: URL parameter > default type
      if (!displayEntryType) {
        const newType = validTypeParam || defaultType;
        if (newType) {
          setDisplayEntryType(newType);
          // Update URL if no valid type param but we're setting a default
          if (!validTypeParam && newType) {
            updateTabInURL(newType);
          }
        }
      } else if (validTypeParam && displayEntryType !== validTypeParam) {
        // URL parameter changed, update the display type
        setDisplayEntryType(validTypeParam);
      } else if (!typesForJournal.includes(displayEntryType)) {
        // If current display type is not valid for this journal, reset to default
        const newType = defaultType;
        if (newType) {
          setDisplayEntryType(newType);
          updateTabInURL(newType);
        }
      }

      // --- Setup Toolbar ---
      setToolBar(
        <div className="flex flex-row justify-between items-center w-full">
          {/* Journal Title/Icon */}
          <div className="flex justify-start items-center gap-2 min-w-0 pr-2">
            {/* ... existing code ... */}
            {getJournalIcon(
              journal.journalType === JOURNAL_TYPES.BUSINESS
                ? "group"
                : journal.journalType,
            )}{" "}
            {/* Show group icon for business */}
            <p className="font-bold truncate" title={journal.title}>
              {journal.title}
            </p>
          </div>

          {/* Actions & Role Badge */}
          <div className="flex flex-row items-center space-x-2 flex-shrink-0">
            {/* Date Picker */}
            <DatePickerWithRange
              daterange={dateRange}
              setDate={setDateRange}
            />
            {/* Add Contributors Button (Admin only) */}
            {journal.access &&
              authUser?.uid &&
              journal.access[authUser?.uid]?.role === "admin" && (
                <AddContributers
                  journalId={journal.id} // Use currentJournal.id directly
                  access={journal.access}
                  pendingAccess={
                    (journal.pendingAccess || {}) as pendingAccessSchemaType
                  }
                />
              )}
            {/* Role Badge */}
            {authUser?.uid && journal?.access?.[authUser.uid]?.role && (
              <Badge variant="secondary">
                {journal.access[authUser.uid].role}
              </Badge>
            )}
          </div>
        </div>,
      );

      // --- Setup Action Button (based on *selected* displayEntryType) ---
      const AddEntryForm = displayEntryType
        ? getAddEntryForm(displayEntryType)
        : null;
      if (
        AddEntryForm &&
        authUser?.uid &&
        journal.access?.[authUser.uid] &&
        ROLES_THAT_ADD.has(journal.access[authUser.uid].role)
      ) {
        setActionButton(<AddEntryForm journalId={journalId!} />);
      } else {
        setActionButton(null);
      }
    } else {
      // Journal not loaded or not found
      setAvailableEntryTypes([]);
      setToolBar(null);
      setActionButton(null);
    }

    // Toolbar cleanup
    return () => {
      setToolBar(null);
    };
  }, [
    journal,
    authUser,
    journalId,
    dateRange,
    displayEntryType,
    setToolBar,
    typeParam,
    updateTabInURL,
  ]); // Add displayEntryType dependency

  // --- Fetch Filtered List based on Date Range and Selected Type ---
  const fetchFilterList = useCallback(async () => {
    // Ensure all required data is available
    if (!displayEntryType || !dateRange || !journalId) return;
    console.log(`Fetching filtered list for ${displayEntryType}`);
    const entries = await fetchDateRangeEntries(
      journalId,
      displayEntryType,
      dateRange.from,
      dateRange.to,
    );
    setFilterList(entries);
  }, [dateRange, journalId, displayEntryType]);

  // Re-fetch when dateRange or displayEntryType changes
  useEffect(() => {
    if (dateRange && displayEntryType) {
      fetchFilterList();
    } else {
      setFilterList([]); // Clear filter list if no range or type selected
    }
  }, [dateRange, displayEntryType, fetchFilterList]);

  // Callback to remove entry from filtered list
  const removeFilterEntry = useCallback((entry: DBentry) => {
    setFilterList((prevList) => prevList.filter((x) => x.id !== entry.id));
  }, []);

  // --- Render Logic ---
  if (!journalId) return null; // Should be handled by effect redirect
  if (journal === undefined)
    return <div className="text-center p-6">Loading Journal...</div>;
  if (journal === null) return <NotFound />;

  // Helper to get display name for tabs
  const getTabDisplayName = (type: EntryType): string => {
    const nameMap: Record<string, string> = {
      cashflow: "Cash Flow",
      inventory: "Inventory",
      quotes: "Quotes",
      naps: "Naps",
      diapers: "Diapers",
      feeds: "Feeds",
      growth: "Growth",
    };
    return nameMap[type] || type;
  };

  return (
    <div className="flex flex-col items-center justify-start w-full px-1">
      {/* --- Journal Info Card (Optional based on type) --- */}
      {/*       
      {currentJournal.journalType === JOURNAL_TYPES.BUSINESS && (
        <div className="mb-4 w-full max-w-md mx-auto flex flex-col items-center">
          {" "}
          <JournalInfoCard
            id={currentJournal.id}
            currency={
              (currentJournal.details as BusinessDetailsType)?.currency
            }
            contactInfo={
              (currentJournal.details as BusinessDetailsType)?.contactInfo
            }
            logo={(currentJournal.details as BusinessDetailsType)?.logo}
            journalSubcollections={ENTRY_CONFIG.business || {}} // Pass only relevant subcollections
          />
        </div>
      )} */}
      {/* TODO: Add specific card for Baby type? */}

      {/* --- Filter Badges --- */}
      <div
        id="filter-badges"
        className="flex flex-row items-center justify-center space-x-2 my-2"
      >
        <FilterRangeBadge dateRange={dateRange} setdateRange={setDateRange} />
      </div>

      {/* --- Tabs for Entry Types --- */}
      {availableEntryTypes.length > 0 && displayEntryType ? (
        <Tabs
          value={displayEntryType} // Controlled by state
          onValueChange={handleTabChange} // Use our new handler function here
          className="w-full max-w-2xl mx-auto" // Center tabs and content
        >
          <TabsList className="grid w-full grid-cols-3 mb-4">
            {" "}
            {/* Adjust grid-cols based on number of types */}
            {availableEntryTypes.map((type) => (
              <TabsTrigger key={type} value={type}>
                {getTabDisplayName(type)}
              </TabsTrigger>
            ))}
          </TabsList>

          {/* Render Content for each type, but only the active one is visible */}
          {availableEntryTypes.map((type) => (
            <TabsContent key={type} value={type} className="w-full m-0">
              {/* Render ChatBox only if this tab is active */}
              {displayEntryType === type && journal.access && journalId && (
                <ChatBox
                  journalId={journalId}
                  entryType={type} // Pass the specific type for this tab
                  access={journal.access}
                  actionButton={
                    dateRange ? (
                      <ExportToCSV
                        entry_list={filterList} // Filter list applies to active tab
                        filename={`${journal.title}-${getTabDisplayName(
                          type,
                        )}-${format(dateRange.from, "yyyyMMdd")}-${format(
                          dateRange.to,
                          "yyyyMMdd",
                        )}.csv`}
                        access={journal.access}
                      />
                    ) : (
                      actionButton // Action button is specific to the active tab type
                    )
                  }
                  filterList={filterList} // Pass filterList
                  hasFilter={!!dateRange}
                  removeFilterEntry={removeFilterEntry}
                />
              )}
            </TabsContent>
          ))}
        </Tabs>
      ) : // Handle case where journal type has no configured entry types or still loading
      !journal ? (
        <div className="text-center p-6">Loading...</div>
      ) : (
        <div className="text-center p-6 text-muted-foreground">
          No sections available for this journal type.
        </div>
      )}
    </div>
  );
}



# frontend/src/app/(auth)/layout.tsx
"use client";
import { useAuth } from "@/lib/auth_handler";
// import { JournalListProvider } from "@/lib/db_handler";
import { useEffect, useState } from "react";
import Link from "next/link";
import { UserNav } from "@/components/ui/user-nav";
import { toolbarContext } from "./nav_tool_handler";

function Header({
  user,
  signOut,
  tools,
}: {
  user: any;
  signOut: any;
  tools: React.ReactNode;
}) {
  const [atTop, setAtTop] = useState(true);
  useEffect(() => {
    const handleScroll = () => {
      const isAtTop = window.scrollY < 10;
      if (isAtTop !== atTop) {
        setAtTop(isAtTop);
      }
    };
    document.addEventListener("scroll", handleScroll);
    return () => {
      document.removeEventListener("scroll", handleScroll);
    };
  }, [atTop]);

  // header is fixed at the top of the page with a shadow and border at the bottom

  return (
    <header className="flex flex-row items-center justify-between w-full px-3 py-1 border-b-2 h-content">
      <Link href="/" className="text-xl font-semibold mr-4">
        <div className="flex items-center">
          <img src="/logo.svg" alt="logo" className="w-6 h-6" />
        </div>
      </Link>

      <div className="px-1 w-full">{tools}</div>

      <UserNav user={user} signOut={signOut} />
    </header>
  );
}

export default function NeedLoginLayout({
  children,
  login,
}: {
  children: React.ReactNode;
  login: React.ReactNode;
}) {
  const { authUser, signOut } = useAuth();
  const [toolbar, setToolBar] = useState(null as React.ReactNode);

  useEffect(() => {
    console.log("Loading Layout. User:", authUser);
  }, [authUser]);

  return (
    <>
      {authUser ? (
        <>
          <toolbarContext.Provider value={{ setToolBar }}>
            <Header user={authUser} signOut={signOut} tools={toolbar} />
            {children}
          </toolbarContext.Provider>
        </>
      ) : (
        login
      )}
    </>
  );
}



# frontend/src/app/(auth)/nav_tool_handler.tsx
import { useState, useContext, createContext } from "react";

// this component is used to provide a user context to pages so that they set the nav bar tools correctly
// the user context is provided by the layout component an any child page can use it

// create a context for toolbar
export const toolbarContext = createContext({
    // toolbar: null as React.ReactNode,
    setToolBar: (el:React.ReactNode) => { },
});

// create and export a hook to use the toolbarContext
export const useToolbar = () => useContext(toolbarContext);




# frontend/src/app/(auth)/page.tsx
"use client";
import Link from "next/link";
import { CreateNewJournal } from "@/app/(auth)/journal/journal-types/create-new-journal"; // This should be the refactored one
// --- Remove Card imports if JournalInfoCard is used ---
// import { Card, CardContent } from "@/components/ui/card";
// import { formattedDate } from "@/lib/utils";
// --- Update db_handler import and types ---
import { fetchJournals } from "@/lib/db_handler";
import { Journal } from "@/lib/custom_types"; // Use the updated Journal type
import { useAuth } from "@/lib/auth_handler";
// --- Remove getJournalIcon if not used directly here ---
// import { getJournalIcon } from "./journal/journal-types/config";
import { useToolbar } from "./nav_tool_handler";
import { useEffect, useState } from "react";
import { JournalInfoCard } from "@/components/ui/journal-info-card"; // Import the card
// --- Import Constants ---
import { JOURNAL_TYPES } from "@/../../backend/functions/src/common/const";
import { ENTRY_CONFIG } from "@/../../backend/functions/src/common/schemas/configmap"; // Import entry config
import { BusinessDetailsType } from "@/../../backend/functions/src/common/schemas/JournalSchema"; // Import details type

// --- Renamed Component: DisplayJournalList ---
// Renders the list of journals using JournalInfoCard
function DisplayJournalList({ journals }: { journals: Journal[] }) {
  if (journals.length === 0) {
    return (
      <p className="text-muted-foreground mt-4">
        No journals found. Create a new business to get started!
      </p>
    );
  }

  return (
    <div className="w-full flex flex-wrap gap-4 justify-center md:justify-start">
      {" "}
      {/* Use justify-center on small screens */}
      {journals.map((journal) => {
        // --- Extract props for JournalInfoCard ---
        // Handle different journal types for extracting details
        let cardProps: any = { id: journal.id };

        if (journal.journalType === JOURNAL_TYPES.BUSINESS) {
          const details = journal.details as BusinessDetailsType | undefined; // Cast safely
          cardProps = {
            ...cardProps,
            currency: details?.currency || "USD", // Default currency
            contactInfo: details?.contactInfo || {
              name: journal.title,
              address: {},
            },
            logo: details?.logo || null,
            // --- Pass Subcollection Info (example: map config) ---
            // get only config where entry.category="business"
            journalSubcollections: Object.entries(ENTRY_CONFIG)
              .filter(([_, config]) => config.category === "business")
              .map(([key, config]) => ({ key, ...config })),
          };
        } else if (journal.journalType === JOURNAL_TYPES.BABY) {
          // --- Handle Baby Journal Type ---
          // You'll need a specific BabyInfoCard or adapt JournalInfoCard
          // For now, use JournalInfoCard with baby-specific details extraction
          const details = journal.details as any; // Replace 'any' with BabyDetailsType later
          cardProps = {
            ...cardProps,
            // No currency for baby?
            contactInfo: { name: journal.title, address: {} }, // Just use title as name
            logo: null, // No logo for baby?
            journalSubcollections: Object.entries(ENTRY_CONFIG)
              .filter(([_, config]) => config.category === "baby")
              .map(([key, config]) => ({ key, ...config })),
          };
          // Consider a different Card component for Baby type
          // return <BabyInfoCard key={journal.id} {...babyProps} />;
        } else {
          // Handle other types or skip rendering
          console.warn(
            "Unsupported journal type for display:",
            journal.journalType,
          );
          return null; // Don't render unsupported types
        }

        return (
          // --- Render JournalInfoCard ---
          // Ensure JournalInfoCard props match what's passed
          <JournalInfoCard key={journal.id} {...cardProps} />
        );
      })}
    </div>
  );
}

// --- Main Page Component ---
export default function Home() {
  const { setToolBar } = useToolbar();
  // --- Simplified State: Just one list of journals ---
  const [journals, setJournals] = useState<Journal[]>([]);
  const [loading, setLoading] = useState(true); // Add loading state
  const [error, setError] = useState<string | null>(null); // Add error state
  const { authUser } = useAuth();

  // --- Fetch Journals Effect ---
  useEffect(() => {
    const loadJournals = async () => {
      if (!authUser?.uid) {
        setJournals([]); // Clear journals if no user
        setLoading(false);
        return;
      }
      setLoading(true);
      setError(null);
      try {
        // Use the refactored fetchJournals
        const fetchedJournals = await fetchJournals(authUser.uid);
        // No need to filter by group type anymore
        setJournals(fetchedJournals);
      } catch (err: any) {
        console.error("Error loading journals:", err);
        setError(err.message || "Failed to load journals.");
      } finally {
        setLoading(false);
      }
    };
    loadJournals();
  }, [authUser]); // Depend only on authUser

  // --- Toolbar Effect ---
  useEffect(() => {
    // Update toolbar title based on context (e.g., "My Journals", "Dashboard")
    setToolBar(<h1 className="text-lg font-bold">Dashboard</h1>);
    // Cleanup function
    return () => setToolBar(null);
  }, [setToolBar]); // Depend on setToolBar

  return (
    <div className="flex flex-col items-center justify-start min-h-screen py-4 md:py-6">
      {" "}
      {/* Adjusted padding */}
      <div className="flex flex-col items-center justify-start w-full max-w-6xl mx-auto flex-1 px-4 md:px-6 lg:px-8 text-center">
        {" "}
        {/* Use max-w-6xl */}
        {/* --- Loading and Error States --- */}
        {loading && (
          <p className="text-muted-foreground mt-8">Loading journals...</p>
        )}
        {error && <p className="text-destructive mt-8">Error: {error}</p>}
        {/* --- Display Journal List --- */}
        {!loading && !error && <DisplayJournalList journals={journals} />}
        {/* --- Create New Button (should be the refactored version) --- */}
        {/* Positioned at bottom right or similar */}
        <div className="mt-auto pt-10">
          {" "}
          {/* Push to bottom */}
          <CreateNewJournal />
        </div>
      </div>
    </div>
  );
}



# frontend/src/app/about/page.tsx
'use client'  
import React from "react";
import { Button } from "@/components/ui/button";
import Link from "next/link";

export default function About() {
  

  return (
    <>
      <main className="flex flex-col items-center justify-center min-h-screen m-4">
        <h1 className="text-4xl font-bold">About SimpleJ</h1>

        <p className="mt-3 text-2xl">
          SimpleJ is a simple daily logging app
        </p>

        <Link href="/" className="mt-8">
          <Button className="px-4 py-2 text-white bg-blue-500 rounded-md">
            Try it 
          </Button>
        </Link>

      </main>
      <footer className="flex items-center justify-center w-full h-24 border-t">
        <h2>
          {" "}
          Made with ❤️ by <a href="https://twitter.com/J3Cordeiro">Jhon</a>
        </h2>
      </footer>
    </>
  );
}



# frontend/src/app/layout.tsx
"use client";
import "./globals.css";
// import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { ThemeProvider } from "@/components/theme-provider";
import { AuthUserProvider } from "@/lib/auth_handler";

const inter = Inter({ subsets: ["latin"] });

// export const metadata: Metadata = {
//   title: "Simplelog",
//   description: "Simplelog is a simple blog.",
// };

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning translate="no">
      <body className={inter.className}>
        <ThemeProvider
          attribute="class"
          defaultTheme="light"
          enableSystem
          disableTransitionOnChange
        >
          <AuthUserProvider>{children}</AuthUserProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}



# frontend/src/app/share/page.tsx
"use client";
import { useEffect, useState, Suspense } from "react";
import { useSearchParams } from "next/navigation";
import { redirect } from "next/navigation";
import { useAuth } from "@/lib/auth_handler";
import { getFunctions, httpsCallable } from "firebase/functions";
import * as z from "zod";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";

const schema = z
  .object({
    journalID: z.string().min(20, "Please enter a valid journal id."),
  })
  .strict();

function SharePageContent() {
  const { authUser, loading, signOut, signInWithGoogle } = useAuth();
  const searchParams = useSearchParams();
  const [error, setError] = useState(null as string | null);
  const [accepted, setAccepted] = useState(false);
  const [journalId, setJournalId] = useState<string | null>(null);

  useEffect(() => {
    const journal_id = searchParams.get("journal");
    setJournalId(journal_id);

    if (authUser && journal_id) {
      // validate journal_id
      const r = schema.safeParse({ journalID: journal_id });
      if (!r.success) {
        setError(r.error.message);
      }
    }
  }, [authUser, searchParams]);

  const GoToJournal = () => {
    console.log("redirecting to journal", accepted);
    redirect(`/journal?jid=${journalId}`);
  };

  const accept = () => {
    if (!journalId) return;

    console.log("sending accept call to the backend");
    const acceptShare = httpsCallable(getFunctions(), "acceptShare", {
      limitedUseAppCheckTokens: true,
    });

    async function sendAccept(data: any) {
      try {
        const result = await acceptShare(data);
        setAccepted(true);
      } catch (error: any) {
        console.log("ops, something went wrong :/", error);
        setError(error?.message ?? "ops, something went wrong :/");
      }
    }

    let payload = { journalID: journalId, operation: "accept" };
    console.log("payload", payload);
    sendAccept(payload);
  };

  if (loading) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen p-4">
        <p>Loading...</p>
      </div>
    );
  }

  if (error) {
    return (
      <Dialog open={!!error}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Error</DialogTitle>
          </DialogHeader>
          <p>{error}</p>
          <Button
            variant="destructive"
            onClick={() => {
              setError(null);
              signOut();
            }}
          >
            Logout
          </Button>
        </DialogContent>
      </Dialog>
    );
  }

  if (accepted) {
    return <GoToJournal />;
  }

  return (
    <div className="flex flex-col items-center justify-center min-h-screen p-4">
      <div className="max-w-md w-full p-6 rounded-lg shadow-md">
        <h1 className="text-2xl font-bold mb-4">Shared Journal</h1>

        {!authUser ? (
          <>
            <p className="mb-4">
              Someone has shared a journal with you. Please log in to access
              the shared content.
            </p>
            <Button className="w-full" onClick={() => signInWithGoogle()}>
              Log in to accept
            </Button>
          </>
        ) : (
          <>
            <p className="mb-4">
              {"You've been invited to access a shared journal"}
            </p>
            <Button
              onClick={accept}
              className="w-full mb-2"
              disabled={!journalId}
            >
              Accept invitation
            </Button>
          </>
        )}
      </div>
    </div>
  );
}

// Loading fallback for the Suspense boundary
function SharePageLoading() {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen p-4">
      <div className="max-w-md w-full p-6 rounded-lg shadow-md">
        <p>Loading share details...</p>
      </div>
    </div>
  );
}

export default function SharePage() {
  return (
    <Suspense fallback={<SharePageLoading />}>
      <SharePageContent />
    </Suspense>
  );
}



# frontend/src/app/wip/page.tsx
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { QuoteDetails } from "@/app/(auth)/journal/journal-types/quote/addQuote";

export default function WIPPage() {
  const router = useRouter();
  const isDevelopment = process.env.NODE_ENV === "development";

  useEffect(() => {
    if (!isDevelopment) {
      router.replace("/");
    }
  }, [router]);

  if (!isDevelopment) {
    return null;
  }

  return (
    <div className="container mx-auto p-4">
      {/* <div className="bg-yellow-100 border-l-4 border-yellow-500 p-4 mb-4">
        <p className="text-yellow-700">
          ⚠️ This page is under development and only visible in development
          mode
        </p>
      </div> */}
      {/* <QuoteDetails /> */}
    </div>
  );
}



# frontend/src/components/InputUnit.tsx
"use client";
import { useState, useEffect } from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

interface NumericInputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  helperText?: string;
  prefix?: string;
  suffix?: string;
}

export function NumericInput({
  label,
  helperText,
  value: propValue,
  onChange: propOnChange,
  prefix,
  suffix,
  ...props
}: NumericInputProps) {
  const [displayValue, setDisplayValue] = useState("");

  // Handle external value changes
  useEffect(() => {
    if (propValue !== undefined) {
      setDisplayValue(String(propValue));
    }
  }, [propValue]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const inputValue = e.target.value;

    // Allow empty input
    if (inputValue === "") {
      setDisplayValue("");
      if (propOnChange) {
        e.target.value = "";
        propOnChange(e);
      }
      return;
    }

    // Check for non-numeric input after handling empty case
    if (isNaN(Number(inputValue))) {
      return;
    }

    // Allow valid numeric inputs with up to 2 decimal places
    const regex = /^[0-9]*\.?[0-9]{0,2}$/;
    if (!regex.test(inputValue)) {
      return;
    }

    // Format the value properly
    let formattedValue = inputValue;
    if (inputValue.includes(".")) {
      // For decimal numbers
      const [intPart, decPart] = inputValue.split(".");
      const cleanIntPart =
        intPart === "" ? "0" : intPart.replace(/^0+/, "") || "0";
      formattedValue = `${cleanIntPart}.${decPart}`;
    } else {
      // For whole numbers
      formattedValue = inputValue.replace(/^0+/, "") || "0";
    }

    // Update the display value
    setDisplayValue(formattedValue);

    // Call the parent onChange handler with the updated value
    if (propOnChange) {
      e.target.value = formattedValue;
      propOnChange(e);
    }
  };

  return (
    <div className="space-y-2">
      {label && <Label htmlFor={props.id}>{label}</Label>}
      <div className="relative">
        {prefix && (
          <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
            <span className="text-gray-500">{prefix}</span>
          </div>
        )}
        {suffix && (
          <div className="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
            <span className="text-gray-500">{suffix}</span>
          </div>
        )}
        <Input
          type="text"
          inputMode="decimal"
          value={displayValue}
          onChange={handleChange}
          className={`${prefix ? "pl-7" : ""} ${suffix ? "pr-7" : ""}`}
          {...props}
        />
      </div>
      {helperText && (
        <p className="text-sm text-muted-foreground">{helperText}</p>
      )}
    </div>
  );
}



# frontend/src/components/LogoUpload.tsx
"use client";

import { useState } from "react";
import Image from "next/image";
import { MinusCircle, UploadCloud } from "lucide-react";

interface LogoUploadProps {
  setLogo?: (logo: string | null) => void;
  logo?: string | null;
}

export function LogoUpload({ setLogo, logo }: LogoUploadProps) {
  const handleLogoUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      if (file.type !== "image/svg+xml") {
        alert("Please upload an SVG file");
        return;
      }
      const reader = new FileReader();
      reader.onloadend = () => {
        const result = reader.result as string;
        setLogo?.(result);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleRemoveLogo = () => {
    setLogo?.(null);
  };

  return (
    <div className="relative w-24 h-24 border rounded-md overflow-hidden">
      {logo ? (
        <div className="relative w-full h-full">
          <Image
            src={logo}
            alt="Company logo"
            fill
            className="object-contain"
          />
          <button
            onClick={handleRemoveLogo}
            className="absolute top-1 right-1 bg-white rounded-full p-1 shadow-sm hover:bg-gray-100"
          >
            <MinusCircle className="h-4 w-4 text-gray-600" />
          </button>
        </div>
      ) : (
        <label className="flex flex-col items-center justify-center w-full h-full cursor-pointer bg-gray-50 hover:bg-gray-100">
          <UploadCloud className="h-6 w-6 text-gray-400" />
          <span className="text-xs text-gray-500">Add Logo</span>
          <input
            type="file"
            className="hidden"
            accept=".svg"
            onChange={handleLogoUpload}
          />
        </label>
      )}
    </div>
  );
}



# frontend/src/components/RadioG.tsx
import { Badge } from "@/components/ui/badge";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { useId } from "react";

export default function RadioG() {
  const id = useId();

  const items = [
    { value: "1", label: "flat fee", price: "$9/mo" },
    { value: "2", label: "% fee", price: "$29/mo" },
    { value: "3", label: "Tax", price: "$49/mo" },
  ];

  const handleRadioChange = (value: string) => {
    console.log(value);
  };

  return (
    <fieldset className="space-y-4">
      <legend className="text-sm font-medium leading-none text-foreground">
        Choose plan
      </legend>
      <RadioGroup
        className="gap-0 -space-y-px rounded-lg shadow-sm shadow-black/5"
        defaultValue="2"
        onValueChange={handleRadioChange}
      >
        {items.map((item) => (
          <div
            key={`${id}-${item.value}`}
            className="relative flex flex-col gap-4 border border-input p-4 first:rounded-t-lg last:rounded-b-lg has-[[data-state=checked]]:z-10 has-[[data-state=checked]]:border-ring has-[[data-state=checked]]:bg-accent"
          >
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <RadioGroupItem
                  id={`${id}-${item.value}`}
                  value={item.value}
                  className="after:absolute after:inset-0"
                  aria-describedby={`${`${id}-${item.value}`}`}
                />
                <Label
                  className="inline-flex items-start"
                  htmlFor={`${id}-${item.value}`}
                >
                  {item.label}
                  {item.value === "3" && (
                    <Badge className="-mt-1 ms-2">%</Badge>
                  )}
                </Label>
              </div>
              {/* <div
                id={`${`${id}-${item.value}`}-price`}
                className="text-xs leading-[inherit] text-muted-foreground"
              >
                {item.price}
              </div> */}
            </div>
          </div>
        ))}
      </RadioGroup>
    </fieldset>
  );
}



# frontend/src/components/theme-provider.tsx
"use client"

'use client'
import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}



# frontend/src/components/ui/accordion.tsx
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }



# frontend/src/components/ui/add-contributors.tsx
import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@/components/ui/form";
import * as z from "zod";
import { zodResolver } from "@hookform/resolvers/zod";

import { useForm } from "react-hook-form";

import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Check, Copy, Link, Plus, UserPlus2, UserX } from "lucide-react";
import { httpsCallable } from "firebase/functions";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  UserSchemaType,
  AccessMap,
  pendingAccessSchemaType,
} from "@/../../backend/functions/src/common/schemas/common_schemas";
import { functions } from "@/lib/auth_handler";

import { SharableLink } from "@/components/ui/sharable-link";
//schema for an array of emails
const schema = z
  .object({
    email: z.string().email({ message: "Please enter a valid email." }),
    role: z.enum(["admin", "reporter", "viewer"]),
  })
  .strict();

type PersonType = z.infer<typeof schema>;

type AccessList = { email: string; role: string; is_pending?: boolean };

// Define the hostname for sharing links
const HOSTNAME =
  process.env.NODE_ENV === "development"
    ? "http://localhost:3000"
    : "https://nm.j3cordeiro.com";

export function AddContributers({
  journalId,
  access,
  pendingAccess,
}: {
  journalId: string | undefined;
  access: AccessMap;
  pendingAccess: pendingAccessSchemaType;
}) {
  const [isOpen, setIsOpen] = useState(false);
  const [people, setPeople] = useState([] as AccessList[]);
  const [pending, setPending] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const form = useForm<PersonType>({
    resolver: zodResolver(schema),
    defaultValues: { email: "", role: "viewer" },
  });

  const callAddContributor = async (data: any) => {
    setPending(true);
    setError(null);
    try {
      const addContributor = httpsCallable(functions, "addContributor", {
        limitedUseAppCheckTokens: true,
      });
      const result = await addContributor(data);
      console.log("Successfully updated contributors");
      return true;
    } catch (error: any) {
      console.error("Failed to update contributors:", error);
      // Extract error message for display
      const errorMessage =
        error.message || "Something went wrong updating contributors";
      setError(errorMessage);
      // Handle specific error codes if the Firebase function returns them
      if (error.code === "functions/permission-denied") {
        setError("You don't have permission to modify contributors");
      } else if (error.code === "functions/invalid-argument") {
        setError("Invalid contributor information provided");
      }
      return false;
    } finally {
      setPending(false);
    }
  };

  const onClose = () => {
    form.reset();
    setIsOpen(false);
  };

  const onOpenHandler = (open: boolean) => {
    if (open) {
      const a = Object.values(access).map((x: UserSchemaType) => ({
        email: x.email,
        role: x.role,
        is_pending: false,
      }));
      const p =
        (pendingAccess &&
          Object.entries(pendingAccess).map(([k, v]) => ({
            email: k,
            role: v,
            is_pending: true,
          }))) ||
        [];
      setPeople(a.concat(p));
      form.reset();
    }
    setIsOpen(open);
  };

  const onAddClick = async () => {
    form.trigger().then(async (isValid) => {
      if (isValid) {
        const email = form.getValues().email;
        const role = form.getValues().role;
        // Check if the email is already in the list
        const cur = people.find((person) => person.email === email);
        if (cur) {
          if (role === cur.role) {
            setError("This email is already in the list with the same role.");
            return;
          }
          if (cur.role == "admin") {
            setError("You cannot change the role of an admin.");
            return;
          }
        }
        // Submit changes immediately
        await callAddContributor({
          email,
          role: form.getValues().role,
          operation: "add",
          journalId,
        })
          .then((result) => {
            if (result) {
              const newPerson = {
                email,
                role: form.getValues().role,
                is_pending: cur ? cur.is_pending : true,
              };
              setPeople((prevPeople) => [...prevPeople, newPerson]);
              form.reset();
              setError(null);
              console.log("Contributor added successfully");
              return true;
            }
          })
          .catch((error) => {
            console.error("Error adding contributor:", error);
            setError("Failed to add contributor. Please try again.");
          });
      }
    });
  };

  const onClickRemove = async (idx: number) => {
    const updatedPeople = people.filter((person, index) => index !== idx);

    // Submit changes immediately
    await callAddContributor({
      email: people[idx].email,
      role: people[idx].role,
      operation: "remove",
      journalId,
    })
      .then((result) => {
        if (result) {
          setPeople(updatedPeople);
          console.log("Contributor removed successfully");
        } else {
          setError("Failed to remove contributor. Please try again.");
        }
      })
      .catch((error) => {
        console.error("Error removing contributor:", error);
        setError("Failed to remove contributor. Please try again.");
      });
  };

  // Generate the share link
  const shareLink = journalId ? `${HOSTNAME}/share?journal=${journalId}` : "";

  return (
    <Dialog open={isOpen} onOpenChange={onOpenHandler}>
      <DialogTrigger asChild>
        <Button variant="outline" size="icon" disabled={!journalId}>
          <UserPlus2 className="h-5 w-5" />
        </Button>
      </DialogTrigger>
      <DialogContent className="" onCloseAutoFocus={onClose}>
        <DialogHeader>
          <DialogTitle>Add Contributors</DialogTitle>
          <DialogDescription>
            Add contributors to your journal
          </DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <div className="grid grid-cols-6 gap-2 -mb-5 -mt-2">
            <div className="col-span-3">
              <Label htmlFor="email">Email</Label>
            </div>
            <div className="col-span-2">
              <Label htmlFor="role">Role</Label>
            </div>
          </div>
          <form className="space-y-6">
            <div className="grid grid-cols-6 gap-2">
              <div className="col-span-3">
                <FormField
                  control={form.control}
                  name={"email"}
                  render={({ field }) => (
                    <FormItem>
                      <FormControl>
                        <Input
                          onChange={(e) => {
                            field.onChange(e.target.value);
                          }}
                          value={field.value}
                          id={field.name}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
              <div className="col-span-2">
                <FormField
                  control={form.control}
                  name={"role"}
                  render={({ field }) => (
                    <FormItem>
                      <FormControl>
                        <Select
                          onValueChange={field.onChange}
                          value={field.value}
                          defaultValue={field.value}
                        >
                          <SelectTrigger>
                            <SelectValue placeholder="Select a role" />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="admin">Admin</SelectItem>
                            <SelectItem value="reporter">Reporter</SelectItem>
                            <SelectItem value="viewer">Viewer</SelectItem>
                          </SelectContent>
                        </Select>
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
              <Button
                type="button"
                id="add-new-contributor"
                variant="outline"
                size="icon"
                onClick={onAddClick}
                aria-label="Add new contributor"
                disabled={pending}
              >
                <Plus />
              </Button>
            </div>
          </form>
          {/* Display error message */}
          {error && (
            <div
              className="text-destructive-foreground px-4 py-3 rounded relative mt-2"
              role="alert"
            >
              <span className="block sm:inline">{error}</span>
            </div>
          )}
          {/* People list with improved overflow handling */}
          {people.length > 0 && (
            <div className="space-y-2 max-h-[200px] overflow-y-auto pr-1">
              {people.map((person, idx) => (
                <div
                  className="flex items-center justify-between border-b"
                  key={`p-${idx}`}
                >
                  <div className="max-w-[80%] overflow-hidden">
                    <p className="truncate">{person.email}</p>
                    <p className="text-xs text-ellipsis">
                      {`${person.is_pending ? "Pending:" : ""} ${person.role}`}
                    </p>
                  </div>

                  <Button
                    key={`rm-${idx}`}
                    variant="outline"
                    size="icon"
                    type="button"
                    className={
                      person.role === "admin" && !person.is_pending
                        ? "hidden"
                        : "flex-shrink-0 items-center justify-center bg-accent mb-1"
                    }
                    onClick={() => onClickRemove(idx)}
                    disabled={pending}
                  >
                    <UserX />
                    <span className="sr-only">Remove</span>
                  </Button>
                </div>
              ))}
            </div>
          )}
          <DialogFooter>
            {/* Share link section  */}
            <div className="flex flex-col space-y-4 w-full">
              {journalId && (
                <SharableLink link={shareLink} maxDisplayLength={30} />
              )}
              <Button
                type="button"
                variant={"outline"}
                onClick={() => setIsOpen(false)}
              >
                Close
              </Button>
            </div>
          </DialogFooter>
        </Form>
      </DialogContent>
    </Dialog>
  );
}



# frontend/src/components/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}



# frontend/src/components/ui/avatar.tsx
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }



# frontend/src/components/ui/badge.tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }



# frontend/src/components/ui/breadcrumb.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}



# frontend/src/components/ui/button.tsx
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        brutalist:
          "bg-background border-2 border-foreground text-foreground shadow-[2px_2px_0px_0px] shadow-foreground hover:translate-x-[4px] hover:translate-y-[4px] hover:shadow-[0px_0px_0px_0px] active:translate-x-[4px] active:translate-y-[4px] active:shadow-[0px_0px_0px_0px]",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };



# frontend/src/components/ui/calendar.tsx
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }



# frontend/src/components/ui/card.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



# frontend/src/components/ui/checkbox.tsx
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }



# frontend/src/components/ui/data-table.tsx
"use client"

import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  useReactTable,
} from "@tanstack/react-table"

import {    
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[]
  data: TData[]
}

export function DataTable<TData, TValue>({
  columns,
  data,
}: DataTableProps<TData, TValue>) {
  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
  })

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          {table.getHeaderGroups().map((headerGroup) => (
            <TableRow key={headerGroup.id}>
              {headerGroup.headers.map((header) => {
                return (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : 
                      flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )
                      
                        }
                  </TableHead>
                )
              })}
            </TableRow>
          ))}
        </TableHeader>
        <TableBody>
          {table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <TableRow
                key={row.id}
                data-state={row.getIsSelected() && "selected"}
              >
                {row.getVisibleCells().map((cell) => (
                  <TableCell key={cell.id}>
                    {cell.getValue() as string}
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : (
            <TableRow>
              <TableCell colSpan={columns.length} className="h-24 text-center">
                No results.
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  )
}



# frontend/src/components/ui/dialog.tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}



# frontend/src/components/ui/drawer.tsx
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}



# frontend/src/components/ui/dropdown-menu.tsx
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}



# frontend/src/components/ui/form.tsx
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form";

import { cn } from "@/lib/utils";
import { Label } from "@/components/ui/label";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
});
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = "FormMessage";

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};



# frontend/src/components/ui/input.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }



# frontend/src/components/ui/journal-info-card.tsx
import Link from "next/link";
import Image from "next/image";
import { Card, CardFooter, CardHeader } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import {
  MapPin,
  Mail,
  Phone,
  ExternalLink,
  PencilIcon,
  Trash2,
  GripVertical,
} from "lucide-react"; // Added GripVertical
import { CreateNewJournal } from "@/app/(auth)/journal/journal-types/create-new-journal";
import { getJournalIcon } from "@/app/(auth)/journal/journal-types/config"; // Keep if used for icons
import { useState } from "react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { useToast } from "@/hooks/use-toast";
import { getFunctions, httpsCallable } from "firebase/functions";
import { useRouter } from "next/navigation";
// --- Import specific types ---
import { BusinessDetailsType } from "@/../../backend/functions/src/common/schemas/JournalSchema";
import { functions } from "@/lib/auth_handler"; // Use configured functions

// --- Update Types for Props ---
type Address = BusinessDetailsType["contactInfo"]["address"]; // Use nested type
type ContactInfo = BusinessDetailsType["contactInfo"];

// --- Add subcollection info prop type ---
type SubcollectionInfo = {
  subcollection: string; // e.g., "cashflow_entries"
  // Add other relevant info like display name, icon?
  // displayName?: string;
  // icon?: React.ReactNode;
};

interface InfoCardProps {
  id: string; // Journal ID is required
  currency?: string; // Optional for non-business types
  contactInfo: ContactInfo; // Required, structure might vary slightly by type
  logo: string | null;
  // --- Updated Prop: journalSubcollections ---
  // Pass the config for subcollections relevant to *this* journal
  journalSubcollections: Record<string, SubcollectionInfo>;
}

export function JournalInfoCard({
  id,
  currency,
  contactInfo,
  logo,
  journalSubcollections,
}: InfoCardProps) {
  // --- State and Hooks ---
  const [isDeleting, setIsDeleting] = useState(false);

  const [isEditing, setIsEditing] = useState(false);
  const { toast } = useToast();
  const router = useRouter();

  // --- Prepare Data for Edit Form ---
  // This assumes the card is primarily for Business type for editing
  // Adjust if editing different types directly from the card
  const initialEditData = {
    title: contactInfo.name, // Use contact name as title for form
    details: {
      currency: (currency === "USD" || currency === "BRL"
        ? currency
        : "USD") as "USD" | "BRL",
      contactInfo,
      logo,
    },
  };

  const hasAddress =
    contactInfo.address.street ||
    contactInfo.address.city ||
    contactInfo.address.state ||
    contactInfo.address.zipCode;

  // --- Use correct backend function name ---
  const handleDeleteJournal = async () => {
    setIsDeleting(true); // Set pending state
    try {
      // Call deleteJournal function
      const deleteJournalFn = httpsCallable(functions, "deleteJournal"); // Use correct name
      await deleteJournalFn({ journalId: id }); // Pass journalId

      toast({
        title: "Journal deleted",
        description: "The journal has been successfully deleted.",
      });
      router.push("/"); // Navigate home after delete
      router.refresh(); // Force refresh
    } catch (error: any) {
      console.error("Error deleting journal:", error);
      toast({
        title: "Error",
        description: "Failed to delete the journal. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsDeleting(false);
    }
  };

  // --- Get Subcollection Display Names (Example) ---
  // You might want a mapping from subcollection key ('cashflow') to display name ('Cash Flow')
  const getSubcollectionDisplayName = (key: string): string => {
    const nameMap: Record<string, string> = {
      cashflow: "Cash Flow",
      inventory: "Inventory",
      quotes: "Quotes",
      naps: "Naps",
      diapers: "Diapers",
      feeds: "Feeds",
      growth: "Growth",
    };
    return nameMap[key] || key.charAt(0).toUpperCase() + key.slice(1); // Default capitalization
  };

  const DeleteAction = (
    <AlertDialog>
      <AlertDialogTrigger asChild>
        <button aria-label="Delete journal" disabled={isDeleting}>
          <Trash2 className="h-4 w-4 text-muted-foreground hover:text-destructive" />
        </button>
      </AlertDialogTrigger>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
          <AlertDialogDescription>
            This action will mark the journal as deleted. This journal and all
            its entries will no longer be accessible.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={handleDeleteJournal}
            disabled={isDeleting}
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
          >
            {isDeleting ? "Deleting..." : "Delete Journal"}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );

  return (
    <Card className="w-full overflow-hidden shadow-md hover:shadow-lg transition-shadow duration-200">
      <CardHeader className="bg-muted p-2 pb-0">
        {/* Title in the header */}
        <Link href={`/journal?jid=${id}`} className="group">
          <h3
            className="text-lg font-semibold truncate group-hover:text-primary group-hover:underline"
            title={contactInfo.name}
          >
            {contactInfo.name}
          </h3>
        </Link>
      </CardHeader>

      {/* --- Main Info Display --- */}
      <div className="flex justify-between items-start">
        <div className="flex items-start gap-4 my-2">
          {/* Logo and Currency */}
          {(logo || currency) && (
            <div className="flex-shrink-0 w-16 flex flex-col items-center gap-2">
              {logo && (
                <div className="w-16 h-16 relative bg-muted/50 rounded-md overflow-hidden">
                  {" "}
                  {/* Added background */}
                  <Image
                    src={logo || "/placeholder.svg"}
                    alt="Logo"
                    fill
                    className="object-contain"
                    onError={(e) => {
                      const target = e.target as HTMLImageElement;
                      target.src = "/placeholder.svg?height=64&width=64";
                    }}
                  />
                </div>
              )}
              {currency && (
                <Badge variant="outline" className="text-xs">
                  {currency}
                </Badge>
              )}
            </div>
          )}

          {/* Contact Info - without the title */}
          <div className="flex-1 min-w-0">
            <div className="space-y-1 text-sm text-muted-foreground">
              {contactInfo.email && (
                <div className="flex items-center gap-2">
                  <Mail className="h-3.5 w-3.5" />
                  <span className="truncate">{contactInfo.email}</span>
                </div>
              )}

              {contactInfo.phone && (
                <div className="flex items-center gap-2">
                  <Phone className="h-3.5 w-3.5" />
                  <span>{contactInfo.phone}</span>
                </div>
              )}

              {hasAddress && (
                <div className="flex items-start gap-2">
                  <MapPin className="h-3.5 w-3.5 mt-0.5" />
                  <div className="flex flex-col text-sm text-muted-foreground justify-start">
                    {contactInfo.address.street && (
                      <div className="text-left">
                        {contactInfo.address.street}
                      </div>
                    )}
                    {(contactInfo.address.city ||
                      contactInfo.address.state ||
                      contactInfo.address.zipCode) && (
                      <span className="text-left">
                        {contactInfo.address.city &&
                          `${contactInfo.address.city}, `}
                        {contactInfo.address.state &&
                          `${contactInfo.address.state} `}
                        {contactInfo.address.zipCode &&
                          contactInfo.address.zipCode}
                      </span>
                    )}
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
        {/* Vertical button menu - moved from header to body */}
        <div className="flex flex-col space-y-2 ml-auto h-full">
          <div className="p-1 hover:bg-muted rounded">{DeleteAction}</div>

          <CreateNewJournal
            isEdit
            initialData={initialEditData as any}
            journalId={id}
            onClose={() => setIsEditing(false)}
            trigger={
              <button
                onClick={() => setIsEditing(true)}
                aria-label="Edit"
                className="p-1 hover:bg-muted rounded"
              >
                <PencilIcon className="h-4 w-4 text-muted-foreground" />
              </button>
            }
          />
        </div>
      </div>
      {/* </CardHeader> */}
      {/* --- Footer for Subcollection Links --- */}
      {Object.keys(journalSubcollections).length > 0 && (
        // Link the entire footer to the main journal page for simplicity
        <Link href={`/journal?jid=${id}`}>
          <CardFooter className="border-t flex flex-wrap justify-start p-3 mt-2 bg-secondary/50 hover:bg-secondary/80 transition-colors cursor-pointer">
            <span className="text-xs font-medium mr-2 text-secondary-foreground/80">
              Sections:
            </span>
            {Object.entries(journalSubcollections).map(([key, info]) => (
              <Badge
                key={key}
                variant="secondary"
                className="mr-1 mb-1 text-xs"
              >
                {/* Optionally add icon: getJournalIcon(key) */}
                {getSubcollectionDisplayName(key)} {/* Use display name */}
              </Badge>
            ))}
          </CardFooter>
        </Link>
      )}
    </Card>
  );
}



# frontend/src/components/ui/label.tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }



# frontend/src/components/ui/popover.tsx
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }



# frontend/src/components/ui/radio-group.tsx
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, children, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }



# frontend/src/components/ui/scroll-area.tsx
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }



# frontend/src/components/ui/select.tsx
"use client";

import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};



# frontend/src/components/ui/separator.tsx
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }



# frontend/src/components/ui/sharable-link.tsx
"use client";

import { useState } from "react";
import { Check, Copy } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface SharableLinkProps {
  link: string;
  maxDisplayLength?: number;
  className?: string;
}

export function SharableLink({
  link,
  maxDisplayLength = 50,
  className = "",
}: SharableLinkProps) {
  const [copied, setCopied] = useState(false);

  const displayLink =
    link.length > maxDisplayLength
      ? `${link.substring(
          0,
          Math.floor(maxDisplayLength / 2),
        )}...${link.substring(link.length - Math.floor(maxDisplayLength / 2))}`
      : link;

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(link);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy text: ", err);
    }
  };

  return (
    <Card className={`flex items-center p-2 w-full ${className}`}>
      <div className="flex-1 min-w-0 mr-2">
        <p className="text-sm truncate" title={link}>
          {displayLink}
        </p>
      </div>
      {/* <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild> */}
      <Button
        variant="outline"
        size="sm"
        onClick={copyToClipboard}
        aria-label="Copy link to clipboard"
        className="flex-shrink-0"
      >
        {copied ? (
          <Check className="h-4 w-4 text-green-500" />
        ) : (
          <Copy className="h-4 w-4" />
        )}
        <span className="ml-2 hidden sm:inline">
          {copied ? "Copied!" : "Copy"}
        </span>
      </Button>
      {/* </TooltipTrigger>
          <TooltipContent> */}
      {/* <p>{copied ? "Copied to clipboard!" : "Copy to clipboard"}</p>
          </TooltipContent> */}
      {/* </Tooltip>
      </TooltipProvider> */}
    </Card>
  );
}



# frontend/src/components/ui/skeleton.tsx
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }



# frontend/src/components/ui/switch.tsx
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }



# frontend/src/components/ui/table.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}



# frontend/src/components/ui/tabs.tsx
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }



# frontend/src/components/ui/textarea.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }



# frontend/src/components/ui/toast.tsx
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}



# frontend/src/components/ui/toaster.tsx
"use client";

import { useToast } from "@/hooks/use-toast";
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}



# frontend/src/components/ui/tooltip.tsx
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



# frontend/src/components/ui/user-nav.tsx
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { User } from "@/lib/custom_types";

export function UserNav({
  user,
  signOut,
}: {
  user: User;
  signOut: () => void;
}) {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="relative h-8 w-8 rounded-full ml-4">
          <Avatar className="h-9 w-9">
            <AvatarImage
              src={user.photoURL || ""}
              alt="User profile picture"
              referrerPolicy="no-referrer"
            />
            <AvatarFallback>
              {(user.email ?? "U")[0].toUpperCase()}
            </AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56" align="end" forceMount>
        <DropdownMenuLabel className="font-normal">
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium leading-none">
              {user.displayName}
            </p>
            <p className="text-xs leading-none text-muted-foreground">
              {user.email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        {/* <DropdownMenuGroup>
          <DropdownMenuItem>
            Profile
            <DropdownMenuShortcut>⇧⌘P</DropdownMenuShortcut>
          </DropdownMenuItem>
          <DropdownMenuItem>
            Billing
            <DropdownMenuShortcut>⌘B</DropdownMenuShortcut>
          </DropdownMenuItem>
          <DropdownMenuItem>
            Settings
            <DropdownMenuShortcut>⌘S</DropdownMenuShortcut>
          </DropdownMenuItem>
          <DropdownMenuItem>New Team</DropdownMenuItem>
        </DropdownMenuGroup>
        <DropdownMenuSeparator /> */}
        <DropdownMenuItem onClick={signOut}>
          Log out
          <DropdownMenuShortcut>⇧⌘Q</DropdownMenuShortcut>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}



# frontend/src/context/JournalContext.tsx
// frontend/src/context/JournalContext.tsx
import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  ReactNode,
} from "react";
import { useSearchParams } from "next/navigation"; // To get journalId
import { useWatchJournal } from "@/lib/db_handler";
import { Journal } from "@/lib/custom_types"; // Assuming Journal type exists

interface JournalContextProps {
  journal: Journal | null | undefined; // undefined while loading, null if not found
  loading: boolean;
  error: string | null; // Add basic error state
}

const JournalContext = createContext<JournalContextProps>({
  journal: undefined,
  loading: true,
  error: null,
});

export const useJournalContext = () => useContext(JournalContext);

interface JournalProviderProps {
  children: ReactNode;
  // Pass journalId explicitly if preferred over reading from params here
  // journalId: string | null;
}

export const JournalProvider: React.FC<JournalProviderProps> = ({
  children,
}) => {
  const searchParams = useSearchParams();
  const journalId = searchParams.get("jid"); // Read journalId from URL
  const { journal: watchedJournal, loading: watchLoading } =
    useWatchJournal(journalId);
  const [error, setError] = useState<string | null>(null);

  // Basic error handling: if loading finished and no journal found
  useEffect(() => {
    if (!watchLoading && !watchedJournal && journalId) {
      setError("Journal not found or access denied.");
    } else {
      setError(null); // Clear error if journal is found or loading
    }
  }, [watchLoading, watchedJournal, journalId]);

  const value = {
    journal: watchedJournal,
    loading: watchLoading,
    error: error,
  };

  return (
    <JournalContext.Provider value={value}>{children}</JournalContext.Provider>
  );
};



# frontend/src/hooks/use-media-query.ts
import { useState, useEffect } from "react";

export function useMediaQuery(query: string) {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);
    if (media.matches !== matches) {
      setMatches(media.matches);
    }

    const listener = () => setMatches(media.matches);
    media.addEventListener("change", listener);

    return () => media.removeEventListener("change", listener);
  }, [matches, query]);

  return matches;
}



# frontend/src/hooks/use-toast.ts
"use client";

// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t,
        ),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) =>
      dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };



# frontend/src/lib/auth_handler.tsx
// import firebase from 'firebase/app';
"use client";
import { initializeApp } from "firebase/app";
import {
  getAuth,
  GoogleAuthProvider,
  signInWithPopup,
  connectAuthEmulator,
  signInWithRedirect,
  User,
} from "firebase/auth";
import { useState, useEffect, createContext, useContext } from "react";
import {
  CustomProvider,
  initializeAppCheck,
  ReCaptchaEnterpriseProvider,
} from "firebase/app-check";
import { getFunctions, connectFunctionsEmulator } from "firebase/functions";
// import the config.json file
import devConfig from "./config.dev.json";
import prodConfig from "./config.json";

const config = process.env.NODE_ENV === "development" ? devConfig : prodConfig;

const firebaseConfig = config.firebaseConfig;

export const app = initializeApp(firebaseConfig);

export const functions = getFunctions(app);

if (process.env.NODE_ENV === "development") {
  console.log(
    `node_env: ${process.env.NODE_ENV} -- hitting local auth and firestore emulators`,
  );
  console.log("testing locally -- hitting local auth and firestore emulators");
  connectAuthEmulator(getAuth(), "http://localhost:9099", {
    disableWarnings: true,
  });

  connectFunctionsEmulator(functions, "localhost", 5001);
}

if (typeof window !== "undefined") {
  window.onload = () => {
    console.log("window loaded");

    if (process.env.NODE_ENV === "development") {
      initializeAppCheck(app, {
        provider: new CustomProvider({
          getToken: () => {
            return Promise.resolve({
              token: "fake-token",
              expireTimeMillis: Date.now() + 1000 * 60 * 60 * 24, // 1 day
            });
          },
        }),

        isTokenAutoRefreshEnabled: true,
      });
    } else {
      initializeAppCheck(app, {
        provider: new ReCaptchaEnterpriseProvider(config.recaptchaSiteKey),
        isTokenAutoRefreshEnabled: true,
      });
    }
  };
}

export const useFirebaseAuth = () => {
  const [authUser, setAuthUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const auth = getAuth();

  const clear = () => {
    setAuthUser(null);
    setLoading(false);
  };

  const signOut = () => auth.signOut().then(clear);

  const signInWithGoogle = () => {
    const provider = new GoogleAuthProvider();
    signInWithPopup(auth, provider);
    // signInWithRedirect(auth, provider);
  };

  const handleAuthStateChanged = (user: User | null) => {
    if (user) {
      setAuthUser(user);
    } else {
      setAuthUser(null);
    }
    setLoading(false);
  };

  useEffect(() => {
    const unsubscribe = auth.onAuthStateChanged(handleAuthStateChanged);
    return () => unsubscribe();
  }, []);

  return {
    authUser,
    loading,
    signOut,
    signInWithGoogle,
  };
};

const authUserContext = createContext({
  authUser: null as User | null,
  loading: true,
  signOut: () => {},
  signInWithGoogle: () => {},
});

// create and export a provider
export function AuthUserProvider({ children }: { children: React.ReactNode }) {
  const auth = useFirebaseAuth();

  return (
    <authUserContext.Provider value={auth}>
      {children}
    </authUserContext.Provider>
  );
}

// create and export a hook to use the authUserContext
export const useAuth = () => useContext(authUserContext);



# frontend/src/lib/custom_types.tsx
// frontend/src/lib/custom_types.tsx
import { z } from "zod";
import { Timestamp } from "firebase/firestore";
import { EntryItf } from "../../../backend/functions/src/common/common_types";
// --- Import backend types if possible, otherwise redefine/simplify ---
import {
  JournalSchemaType,
  AccessMap as BackendAccessMap,
} from "../../../backend/functions/src/common/schemas/JournalSchema";
import { EntryType } from "../../../backend/functions/src/common/schemas/configmap";

// Keep User type simple on frontend if full details aren't always needed
export interface User {
  uid: string;
  displayName?: string | null; // Allow null
  email?: string | null; // Allow null
  photoURL?: string | null; // Allow null
  role?: string; // Role might be needed
}

// Use the imported backend AccessMap type or redefine if necessary
export type AccessMap = BackendAccessMap;
// export interface AccessMap {
//   [uid: string]: User;
// }

// --- Update Journal interface ---
// Align with backend JournalSchemaType, simplify if needed for frontend context
export interface Journal
  extends Omit<
    JournalSchemaType,
    "createdAt" | "updatedAt" | "access" | "pendingAccess"
  > {
  id: string;
  // Use JournalSchemaType properties directly:
  // title: string;
  // journalType: string; // Will be 'business', 'baby', etc.
  // details: any; // Keep as any for now, or use discriminated union if preferred frontend
  // access: AccessMap;
  // pendingAccess?: { [email: string]: string }; // Use optional and match backend role type
  // isActive: boolean;
  createdAt: Timestamp; // Keep timestamps if needed for display
  updatedAt?: Timestamp;
  access: AccessMap; // Explicitly include access
  pendingAccess?: { [email: string]: string }; // Optional pending access
}

// DBentry remains largely the same, represents an entry within a subcollection
export interface DBentry extends Omit<EntryItf, "createdAt" | "updatedAt"> {
  id: string;
  createdBy: string;
  createdAt: Timestamp;
  updatedAt?: Timestamp; // Add optional updatedAt
  entryType?: EntryType; // --- ADD entryType if needed when fetching generic lists ---
  // details are already part of EntryItf
}

export interface DBentryMap {
  [id: string]: DBentry;
}



# frontend/src/lib/db_handler.tsx
// frontend/src/lib/db_handler.tsx
import { useState, useEffect } from "react";
import {
  collection,
  doc,
  query,
  where,
  onSnapshot,
  getDocs,
  getDoc,
  getFirestore,
  connectFirestoreEmulator,
  orderBy,
  limit,
  startAfter,
  // endBefore, // Not currently used
  Firestore,
  DocumentData,
  Timestamp, // Import Timestamp
} from "firebase/firestore";
import { app } from "@/lib/auth_handler";
import { DBentry, DBentryMap, Journal } from "./custom_types"; // Use updated types
// --- Import frontend/backend constants ---
import {
  JOURNAL_COLLECTION,
  // ENTRY_CONFIG, // Need frontend equivalent or direct use
  // BABY_ENTRY_TYPES // Potentially needed if logic differs
} from "@/../../backend/functions/src/common/const"; // Adjust path as needed
import {
  ENTRY_CONFIG,
  EntryType,
} from "@/../../backend/functions/src/common/schemas/configmap";

// --- Define Frontend ENTRY_CONFIG (or import if possible/preferred) ---
// This avoids direct dependency if backend changes often, but requires duplication
// const FE_ENTRY_CONFIG = {
//   cashflow: { subcollection: "cashflow_entries", sortField: "details.date" },
//   inventory: { subcollection: "inventory_items", sortField: "createdAt" },
//   quote: { subcollection: "quotes", sortField: "createdAt" },
//   nap: { subcollection: "naps", sortField: "details.start" },
//   diaper: { subcollection: "diapers", sortField: "details.time" },
//   feed: { subcollection: "feeds", sortField: "details.time" },
//   growth: { subcollection: "growth_entries", sortField: "details.date" },
// } as const;
// --- End Frontend ENTRY_CONFIG ---

export const db = getFirestore(app);

if (process.env.NODE_ENV === "development") {
  console.log("Firestore connected to emulator");
  connectFirestoreEmulator(db, "localhost", 8080);
}

// Helper to get subcollection config
function getEntryConfig(entryType: EntryType) {
  const config = ENTRY_CONFIG[entryType as keyof typeof ENTRY_CONFIG];
  if (!config) {
    console.error(`Invalid entryType provided: ${entryType}`);
    return null;
  }
  return config;
}

// --- fetchDateRangeEntries ---
// Now requires entryType and assumes the sort field exists in details
export async function fetchDateRangeEntries(
  journalId: string | null,
  entryType: EntryType, // --- ADD entryType ---
  from: Date | undefined,
  to: Date | undefined,
): Promise<DBentry[]> {
  // Return type updated
  if (!journalId || !from || !to) {
    return [];
  }

  const config = getEntryConfig(entryType);
  if (!config || !config.sortField.startsWith("details.")) {
    console.error(
      `Date range fetch not supported or configured for entryType: ${entryType}`,
    );
    return []; // Or throw error
  }
  const subcollectionName = config.subcollection;
  const dateSortField = config.sortField; // e.g., "details.date"

  try {
    const colPath = `${JOURNAL_COLLECTION}/${journalId}/${subcollectionName}`;
    const q = query(
      collection(db, colPath),
      where("isActive", "==", true),
      orderBy(dateSortField, "desc"), // Use dynamic sort field
      // orderBy("createdAt", "desc"), // Secondary sort
      where(dateSortField, ">=", from),
      where(dateSortField, "<=", to),
    );

    const querySnapshot = await getDocs(q);
    const docsList: DBentry[] = querySnapshot.docs.map((doc) => ({
      id: doc.id,
      entryType: entryType, // Add entryType to result if needed
      ...(doc.data() as any), // Cast needed as data structure varies
    }));
    console.log(
      `Fetched ${docsList.length} ${entryType} entries for date range.`,
    );
    return docsList;
  } catch (error) {
    console.error(`fetchDateRangeEntries (${entryType}): error`, error);
    return [];
  }
}

// --- fetchOlderEntrys ---
// Now requires entryType
export async function fetchOlderEntrys(
  journalId: string,
  entryType: EntryType, // --- ADD entryType ---
  oldestEntry: DBentry, // Use DBentry type
  past_k: number,
): Promise<DBentryMap> {
  // Return type updated
  const config = getEntryConfig(entryType);
  if (!config) return {};
  const subcollectionName = config.subcollection;
  const primarySortField = config.sortField; // e.g., "details.date" or "createdAt"

  try {
    const colPath = `${JOURNAL_COLLECTION}/${journalId}/${subcollectionName}`;
    // Ensure oldestEntry has the required sort fields
    const primarySortValue = primarySortField.startsWith("details.")
      ? (oldestEntry.details as any)?.[primarySortField.split(".")[1]]
      : oldestEntry[primarySortField as keyof DBentry];
    const secondarySortValue = oldestEntry.createdAt;

    if (primarySortValue === undefined || secondarySortValue === undefined) {
      console.error("Oldest entry is missing sort field values", {
        primarySortField,
        oldestEntry,
      });
      return {};
    }

    const q = query(
      collection(db, colPath),
      where("isActive", "==", true),
      orderBy(primarySortField, "desc"),
      // orderBy("createdAt", "desc"),
      startAfter(primarySortValue, secondarySortValue), // Use potentially dynamic sort field value
      limit(past_k),
    );

    const querySnapshot = await getDocs(q);
    const docsDict: DBentryMap = {};
    querySnapshot.forEach((doc) => {
      docsDict[doc.id] = {
        id: doc.id,
        entryType: entryType, // Add entryType
        ...(doc.data() as any),
      } as DBentry;
    });
    console.log(
      `Fetched ${Object.keys(docsDict).length} older ${entryType} entries.`,
    );
    return docsDict;
  } catch (error) {
    console.error(`fetchOlderEntrys (${entryType}): error`, error);
    return {};
  }
}

// --- useEntriesSubCol ---
// Now requires entryType
export function useEntriesSubCol(
  journalId: string,
  entryType: EntryType,
): DBentryMap {
  // Return type updated
  const [docs, setDocs] = useState<DBentryMap>({}); // Use updated type
  const FETCH_LIMIT = 20;

  useEffect(() => {
    // Reset docs when journalId or entryType changes
    setDocs({});

    const config = getEntryConfig(entryType);
    if (!journalId || !config) {
      console.warn(
        `useEntriesSubCol: Invalid journalId or entryType (${entryType})`,
      );
      return () => {}; // Return empty cleanup
    }
    const subcollectionName = config.subcollection;
    const primarySortField = config.sortField;

    let unsubscribe = () => {};

    try {
      const colPath = `${JOURNAL_COLLECTION}/${journalId}/${subcollectionName}`;
      console.log(
        `Watching entries in: ${colPath} ordered by ${primarySortField}`,
      );

      const q = query(
        collection(db, colPath),
        where("isActive", "==", true),
        orderBy(primarySortField, "desc"),
        // orderBy("createdAt", "desc"),
        limit(FETCH_LIMIT),
      );

      unsubscribe = onSnapshot(
        q,
        (snapshot) => {
          setDocs((prevDocs) => {
            const newDocs = { ...prevDocs };
            let changed = false;
            snapshot.docChanges().forEach((change) => {
              const docData = {
                id: change.doc.id,
                entryType: entryType,
                ...change.doc.data(),
              } as DBentry;
              if (change.type === "added" || change.type === "modified") {
                if (
                  JSON.stringify(newDocs[change.doc.id]) !==
                  JSON.stringify(docData)
                ) {
                  // Basic change check
                  newDocs[change.doc.id] = docData;
                  changed = true;
                  console.log(
                    `Doc ${change.type}: ${change.doc.id} in ${subcollectionName}`,
                  );
                }
              } else if (change.type === "removed") {
                if (newDocs[change.doc.id]) {
                  delete newDocs[change.doc.id];
                  changed = true;
                  console.log(
                    `Doc removed: ${change.doc.id} from ${subcollectionName}`,
                  );
                }
              }
            });
            return changed ? newDocs : prevDocs; // Only update state if changes occurred
          });
        },
        (error) => {
          // Add error handler for onSnapshot
          console.error(`Error watching collection ${colPath}: `, error);
          // Optionally set an error state here
        },
      );
    } catch (error) {
      console.error(`useEntriesSubCol (${entryType}): setup error`, error);
    }

    // Cleanup function
    return () => {
      console.log(
        `Unsubscribing from ${entryType} entries for journal ${journalId}`,
      );
      unsubscribe();
    };
  }, [journalId, entryType]); // Re-run effect if journalId or entryType changes

  return docs;
}

// --- useWatchJournal ---
// Path updated to JOURNAL_COLLECTION
export function useWatchJournal(journalId: string | null) {
  // Allow null journalId
  const [journal, setJournal] = useState<Journal | undefined | null>(
    undefined,
  ); // Allow null for not found
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    setJournal(undefined); // Reset on ID change
    setLoading(true);

    if (!journalId) {
      setLoading(false);
      setJournal(null); // Set to null if no ID
      return () => {}; // Return empty cleanup
    }

    console.log("Watching journal: ", journalId);
    const docRef = doc(db, JOURNAL_COLLECTION, journalId); // Use JOURNAL_COLLECTION

    const unsubscribe = onSnapshot(
      docRef,
      (doc) => {
        if (doc.exists()) {
          setJournal({ id: doc.id, ...doc.data() } as Journal); // Use updated Journal type
        } else {
          console.warn(`Journal ${journalId} not found.`);
          setJournal(null); // Set to null if not found
        }
        setLoading(false);
      },
      (error) => {
        // Add error handler
        console.error(`Error watching journal ${journalId}: `, error);
        setJournal(null);
        setLoading(false);
        // Optionally set an error state
      },
    );

    return () => {
      console.log(`Unsubscribing from journal ${journalId}`);
      unsubscribe();
    };
  }, [journalId]); // Depend on journalId

  return { journal, loading };
}

// Doc type might be redundant now with Journal type
// export interface Doc extends DocumentData {
//   id: string;
// }

// --- fetchJournals ---
// Query simplified, filtering by type happens client-side if needed
export async function fetchJournals(userID: string): Promise<Journal[]> {
  // Return Journal[]
  console.log("Fetching journals for user ", userID);
  try {
    const q = query(
      collection(db, JOURNAL_COLLECTION), // Use JOURNAL_COLLECTION
      where("isActive", "==", true),
      where("access_array", "array-contains", userID),
      orderBy("createdAt", "desc"), // Optional: order by creation date
    );

    const querySnapshot = await getDocs(q);
    const journals: Journal[] = querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...(doc.data() as any), // Cast needed
    }));

    console.log("Journals fetched:", journals.length);
    return journals;
  } catch (error) {
    console.error("Error fetching journals:", error);
    return [];
  }
}

// --- fetchEntry ---
// Now requires entryType
export async function fetchEntry(
  journalId: string,
  entryType: EntryType, // --- ADD entryType ---
  entryId: string,
): Promise<DBentry | null> {
  // Return type updated
  const config = getEntryConfig(entryType);
  if (!config) return null;
  const subcollectionName = config.subcollection;

  try {
    const docPath = `${JOURNAL_COLLECTION}/${journalId}/${subcollectionName}/${entryId}`;
    const docRef = doc(db, docPath);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      return {
        id: docSnap.id,
        entryType: entryType, // Add entryType
        ...(docSnap.data() as any),
      } as DBentry;
    } else {
      console.log(`No such entry document: ${docPath}`);
      return null;
    }
  } catch (error) {
    console.error(`Error getting entry (${entryType}): ${entryId}`, error);
    return null;
  }
}

// --- fetchJournal ---
// Path updated to JOURNAL_COLLECTION
export async function fetchJournal(
  journalId: string,
): Promise<Journal | null> {
  // Return Journal | null
  try {
    console.log("Fetching journal ", journalId);
    const docRef = doc(db, JOURNAL_COLLECTION, journalId); // Use JOURNAL_COLLECTION
    const docSnap = await getDoc(docRef);
    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() } as Journal; // Use updated Journal type
    } else {
      console.log(`No such journal document: ${journalId}`);
      return null;
    }
  } catch (error) {
    console.error(`Error getting journal document: ${journalId}`, error);
    return null;
  }
}



# frontend/src/lib/schemas/contact-info.ts
import * as z from "zod";

export const contactInfoSchema = z.object({
  name: z
    .string()
    .min(3, { message: "Name longer than 3 letters is required" })
    .max(50, { message: "Name must be less than 50 characters" }),
  email: z.string().email({ message: "Please enter a valid email address" }),
  phone: z
    .string()
    .min(10, { message: "Phone number must be at least 10 digits" })
    .regex(/^\+?[\d\s-()]+$/, {
      message: "Please enter a valid phone number",
    }),
  address: z.object({
    street: z.string().min(1, { message: "Street address is required" }),
    city: z.string().min(1, { message: "City is required" }),
    state: z.string().min(1, { message: "State is required" }),
    zipCode: z.string().regex(/^\d{5}(-\d{0,4})?$/, {
      message: "Please enter a valid ZIP code",
    }),
  }),
});

export type ContactInfoSchema = z.infer<typeof contactInfoSchema>;



# frontend/src/lib/utils.ts
import { type ClassValue, clsx } from "clsx";
import { Timestamp } from "firebase/firestore";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
export function formattedDate(entryDate: Timestamp | Date) {
  // console.log(entryDate);

  let date: Date = new Date();
  if (entryDate instanceof Timestamp) {
    date = new Date(entryDate.toDate());
  }
  let options: Intl.DateTimeFormatOptions = {
    month: "short",
    day: "numeric",
  };
  if (date.getFullYear() === new Date().getFullYear()) {
    options["year"] = "numeric";
  }
  return date.toLocaleDateString("en-US", options);
}

// Format currency
export const formatCurrency = (amount: number, currencySymbol: string) => {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: currencySymbol,
  }).format(amount);
};

export const currencyToSymbol = (currency: string): string => {
  if (!currency || typeof currency !== "string") {
    return "$"; // Default to USD symbol
  }

  try {
    const formatter = new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: currency.toUpperCase(),
    });

    const parts = formatter.formatToParts(0);
    const symbol = parts.find((part) => part.type === "currency")?.value;
    return symbol || "$";
  } catch (error) {
    // Return default USD symbol if currency code is invalid
    return "$";
  }
};



# frontend/tailwind.config.ts
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: 0,
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: 0,
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};

